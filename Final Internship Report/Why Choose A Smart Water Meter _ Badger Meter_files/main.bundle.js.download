(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var bookmarks = function bookmarks() {
  var bookmarkItems = document.querySelectorAll('.bookmark-container');

  var bookmarkConstructor = function bookmarkConstructor(id) {
    _vueMin["default"].component('bookmark', {
      props: ['data'],
      data: function data() {
        return {
          isBookmarked: false,
          id: null,
          type: null
        };
      },
      computed: {
        saved: function saved() {
          return _store["default"].state.favorites["".concat(this.type)];
        }
      },
      watch: {
        saved: function saved() {
          this.isBookmarked = this.saved.includes(this.id) ? true : false;
        }
      },
      methods: {
        handleBookmark: function handleBookmark() {
          _store["default"].commit('updateFavorites', {
            id: this.id,
            type: this.type,
            action: this.isBookmarked ? "remove" : "add"
          });

          _store["default"].dispatch('checkFavorites');
        }
      },
      mounted: function mounted() {
        this.id = this.$refs.bookmark.dataset.productId ? this.$refs.bookmark.dataset.productId : this.$refs.bookmark.dataset.articleId ? this.$refs.bookmark.dataset.articleId : this.$refs.bookmark.dataset.documentId ? this.$refs.bookmark.dataset.documentId : this.$refs.bookmark.dataset.softwareId ? this.$refs.bookmark.dataset.softwareId : null;
        this.type = this.$refs.bookmark.dataset.productId ? "productId" : this.$refs.bookmark.dataset.articleId ? "articleId" : this.$refs.bookmark.dataset.documentId ? "documentId" : this.$refs.bookmark.dataset.softwareId ? "softwareId" : null; // console.log("saved",this.saved);

        this.isBookmarked = this.saved.includes("".concat(this.id)) ? true : false;
      }
    });

    new _vueMin["default"]({
      el: ".bookmark-container-".concat(id)
    }).$mount(".bookmark-container-".concat(id), true);
  };

  if (bookmarkItems.length > 0) {
    bookmarkItems.forEach(function (item, index) {
      item.classList.add("bookmark-container-".concat(index));
      bookmarkConstructor(index);
    });
  }
};

var _default = bookmarks;
exports["default"] = _default;

},{"./store":51,"vue/dist/vue.min.js":234}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ComponentModule = {
  AddModule: function AddModule(target, options) {
    ComponentModule._modules.push(_objectSpread({
      target: target
    }, options));
  },
  Init: function Init() {
    ComponentModule._modules.forEach(function (_ref) {
      var prefix = _ref.prefix,
          components = _ref.components,
          initFunc = _ref.initFunc,
          target = _ref.target,
          template = _ref.template,
          _ref$mount = _ref.mount,
          mount = _ref$mount === void 0 ? true : _ref$mount,
          vueOptions = _objectWithoutProperties(_ref, ["prefix", "components", "initFunc", "target", "template", "mount"]);

      var _prfx = prefix || '';

      var found = document.querySelectorAll(target);
      found.forEach(function (el) {
        initFunc && initFunc(_vueMin["default"]);
        var instance = new _vueMin["default"](_objectSpread({
          el: !template && el,
          store: _store["default"],
          components: components === null || components === void 0 ? void 0 : components.reduce(function (obj, _ref2) {
            var name = _ref2.name,
                options = _objectWithoutProperties(_ref2, ["name"]);

            obj[_prfx + name] = options;
            return obj;
          }, {}),
          template: template
        }, vueOptions));
        mount && instance.$mount(el, true);
      });
    });
  }
};
ComponentModule._modules = [];
var _default = ComponentModule;
exports["default"] = _default;

},{"./store":51,"vue/dist/vue.min.js":234}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// import { contactModal } from "./modals";
var ContactUs = function ContactUs() {
  _vueMin["default"].use(_vueJsModal["default"]);

  _vueMin["default"].component('contact-us', {
    props: ['contactOpen'],
    methods: {
      toggleModal: function toggleModal() {
        _eventBus["default"].$emit('close-contact'); // this.$modal.show(
        //     contactModal.template,
        //     contactModal.name,
        //     contactModal.options,
        //     contactModal.events
        // )

      }
    },
    mounted: function mounted() {}
  });
};

var _default = ContactUs;
exports["default"] = _default;

},{"./event-bus":9,"vue-js-modal":233,"vue/dist/vue.min.js":234}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _contactUs = _interopRequireDefault(require("./contact-us"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var ctaBarBottom = function ctaBarBottom() {
  var ctaBar = document.querySelectorAll('.persistent-cta--bottom');

  var ctaBarConstructor = function ctaBarConstructor(id) {
    _vueMin["default"].component('cta-bar-bottom-template', {
      data: function data() {
        return {
          isSticky: false,
          isMobile: _store["default"].state.isMobile,
          scrolled: false,
          isFinalPosition: false,
          observer: null,
          contactOpen: false,
          store: _store["default"]
        };
      },
      computed: {
        computedIsMobile: function computedIsMobile() {
          return _store["default"].state.isMobile;
        }
      },
      watch: {
        computedIsMobile: function computedIsMobile() {
          var _this = this;

          if (this.computedIsMobile == true) {
            this.initShow();
            this.detectFooter();
            this.isMobile = true;

            _eventBus["default"].$on('stick-nav', function () {
              _this.stickyNav();

              _this.isSticky = true;
            });

            _eventBus["default"].$on('unstick-nav', function () {
              if (!_this.isFinalPosition) {
                _this.unstickyNav();

                _this.isSticky = false;
              } else {
                return;
              }
            });
          } else {
            this.isMobile = false;

            _eventBus["default"].$off('stick-nav');

            _eventBus["default"].$off('unstick-nav');

            document.querySelector('.persistent-cta--bottom-final').classList.remove('active');
            this.unstickyNav();
            document.querySelector('.persistent-cta--bottom').style.display = "none";
            var target = document.querySelector('.footer');
            this.observer.disconnect(target);
          }
        } // isSticky: function() {
        //     this.contactOpen = this.isSticky ? this.contactOpen : false; 
        // }

      },
      methods: {
        toggleContact: function toggleContact() {
          this.contactOpen = !this.contactOpen;
        },
        stickyNav: function stickyNav() {
          if (!this.$el.parentNode.classList.contains('active') && !this.isSticky && this.computedIsMobile) {
            this.$el.parentNode.classList.add("active");
          }
        },
        unstickyNav: function unstickyNav() {
          if (this.isSticky) {
            this.$el.parentNode.classList.remove("active");
          }
        },
        initShow: function initShow() {
          var _this2 = this;

          // show bottom after 3 seconds
          setTimeout(function () {
            _this2.$el.parentNode.classList.add('active');
          }, 3000);
        },
        detectFooter: function detectFooter() {
          var _this3 = this;

          var options = {
            root: null,
            rootMargin: '0px',
            threshold: 0
          };

          var handleSticky = function handleSticky(changes) {
            changes.forEach(function (change) {
              if (!(change.intersectionRatio > 0)) {
                _this3.isFinalPosition = false;
                document.querySelector('.persistent-cta--bottom').style.display = 'block';
              } else {
                _this3.isFinalPosition = true;
                document.querySelector('.persistent-cta--bottom').style.display = 'none';
              }
            });
          };

          var observer = new IntersectionObserver(handleSticky, options);
          this.observer = observer;
          var target = document.querySelector('.footer');
          observer.observe(target);
        }
      },
      mounted: function mounted() {
        var _this4 = this;

        _eventBus["default"].$on('stick-nav', function () {
          _this4.stickyNav();

          _this4.isSticky = true;
          _this4.scrolled = true;
        });

        _eventBus["default"].$on('unstick-nav', function () {
          if (!_this4.isFinalPosition) {
            _this4.unstickyNav();

            _this4.isSticky = false;
            _this4.scrolled = true;
          } else {
            return;
          }
        });

        _eventBus["default"].$on('close-contact', function () {
          _this4.contactOpen = false;
        });

        if (this.isMobile) {
          this.initShow();
          this.detectFooter();
        }
      }
    });

    (0, _contactUs["default"])();
    new _vueMin["default"]({
      el: ".persistent-cta--bottom-".concat(id),
      store: _store["default"]
    }).$mount(".persistent-cta--bottom-".concat(id), true);
  };

  if (ctaBar.length > 0) {
    ctaBar.forEach(function (item, index) {
      item.classList.add("persistent-cta--bottom-".concat(index));
      ctaBarConstructor(index);
    });
  }
};

var _default = ctaBarBottom;
exports["default"] = _default;

},{"./contact-us":3,"./event-bus":9,"./store":51,"vue/dist/vue.min.js":234}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _contactUs = _interopRequireDefault(require("./contact-us"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// import {quoteModal} from './modals';
var ctaBarTop = function ctaBarTop() {
  var ctaBar = document.querySelector('.persistent-cta--top');

  _vueMin["default"].use(_vueJsModal["default"]);

  var ctaBarConstructor = function ctaBarConstructor() {
    _vueMin["default"].component('cta-bar-top-template', {
      data: function data() {
        return {
          title: _store["default"].state.pageTitle || '',
          showTitle: false,
          anchorLinks: {
            test: 'test'
          },
          currentAnchor: null,
          // store: store, //for testing only
          hasAnchors: false,
          isMobile: false,
          scrollDir: null,
          contactOpen: false,
          contactOpenText: '',
          store: _store["default"]
        };
      },
      created: function created() {
        window.addEventListener('scroll', this.handleScroll);
        this.handleScroll();
      },
      destroyed: function destroyed() {
        window.removeEventListener('scroll', this.handleScroll);
      },
      computed: {
        computedIsMobile: function computedIsMobile() {
          return _store["default"].state.isMobile;
        }
      },
      watch: {
        computedIsMobile: function computedIsMobile() {
          this.isMobile = this.computedIsMobile; // this.scrollDirection();
        },
        scrollDir: function scrollDir() {
          if (this.scrollDir == "up") {
            this.stickyNav();
          } else if (this.scrollDir == "down") {
            this.unstickyNav();
          } else if (this.scrollDir == "top") {
            this.$el.parentNode.classList.remove("active");
          }
        },
        contactOpen: function contactOpen() {
          this.contactOpenText = this.contactOpen ? '' : this.$refs.contactBtn.querySelector('.button-text').dataset.openText;
        }
      },
      methods: {
        handleScroll: function handleScroll() {
          var el = this.$parent.$el;
          var wTop = document.documentElement.scrollTop || document.body.scrollTop;
          var eTop = this.parentTop || el.getBoundingClientRect().top;

          if (this.parentTop === null) {
            this.parentTop = eTop;
          }

          if (wTop > eTop) {
            el.classList.add("persistent-cta--top-fixed");
          } else {
            el.classList.remove("persistent-cta--top-fixed");
          }
        },
        toggleContact: function toggleContact(e) {
          this.contactOpen = !this.contactOpen;
        },
        // toggleModal() {
        //     this.$modal.show(
        //         quoteModal.template(),
        //         quoteModal.name, 
        //         quoteModal.options,
        //         quoteModal.events
        //     )
        // },
        setTitle: function setTitle() {
          if (document.querySelector('h1')) {
            var pageTitle = document.querySelector('h1').innerText;

            _store["default"].commit('updateTitle', pageTitle);

            this.title = _store["default"].state.pageTitle;
          }
        },
        detectHero: function detectHero() {
          var _this = this;

          var options = {
            root: null,
            rootMargin: '0px',
            threshold: 0
          };

          var toggleTitle = function toggleTitle(changes) {
            changes.forEach(function (change) {
              if (!(change.intersectionRatio > 0)) {
                // console.log('hero NOT visible');
                _this.showTitle = true;
              } else {
                // console.log('hero visible');
                _this.showTitle = false;
              }
            });
          };

          var observer = new IntersectionObserver(toggleTitle, options);

          if (document.querySelector('h1')) {
            var target = document.querySelector('h1').parentNode;
            observer.observe(target);
          } else {
            return;
          }
        },
        setAnchors: function setAnchors() {
          var _this2 = this;

          var anchorContainer = document.querySelectorAll('.sub-nav__list-container li a');
          var anchors = [];
          this.hasAnchors = anchorContainer.length > 0 ? true : false;

          if (this.hasAnchors) {
            // let test = '';
            // document.addEventListener('click', () => {
            //     console.log("clicked");
            // });
            anchorContainer.forEach(function (item, index) {
              anchors.push({
                name: item.innerText,
                key: item.getAttribute('href').substr(1)
              }); // console.log(item)
              // this.$nextTick(() => {
              //     item.addEventListener("click", () => {
              //         console.log("CLICKED");
              //     }, false);
              // })
            }); // console.log(anchors);

            this.anchorLinks = anchors;

            _store["default"].commit('setPageAnchors', anchors);

            this.$nextTick(function () {
              _this2.observeAnchors();
            });
          }
        },
        initMobile: function initMobile() {
          this.isMobile = _store["default"].state.isMobile;
        },
        scrollDirection: function scrollDirection() {
          var scrollPos = 0;
          var self = this;

          function handleScroll() {
            if (self.computedIsMobile) {
              if (document.body.getBoundingClientRect().top == 0) {
                self.scrollDir = "top";
              } else if (document.body.getBoundingClientRect().top > scrollPos) {
                _eventBus["default"].$emit('unstick-nav');

                self.scrollDir = "up"; // this.stickyNav();
              } else {
                _eventBus["default"].$emit('stick-nav');

                self.scrollDir = "down"; // this.unstickyNav();
              }

              scrollPos = document.body.getBoundingClientRect().top;
            } else {
              return;
            }
          }

          window.addEventListener("scroll", handleScroll, true);
        },
        stickyNav: function stickyNav() {
          if (!this.$el.parentNode.classList.contains('active')) {
            this.$el.parentNode.classList.add("active");
          }
        },
        unstickyNav: function unstickyNav() {
          this.$el.parentNode.classList.remove("active");
        },
        observeAnchors: function observeAnchors() {
          var _this3 = this;

          var options = {
            root: null,
            rootMargin: '0px',
            // threshold: .25
            threshold: [0, .1, .2, .3, .4, .5, .6, .7, .8, .9, 1] // more thresholds = more accuracy

          };

          var setCurrentAnchor = function setCurrentAnchor(entries) {
            var _iterator = _createForOfIteratorHelper(entries),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var entry = _step.value;
                entry.target._intersectionHeight = entry.intersectionRect.height;
              } // compare visibility of sections(all) after every intersection

            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            var mostVisibleSection = targets.reduce(function (prev, current) {
              if (current._intersectionHeight > (prev ? prev._intersectionHeight : 0)) {
                return current;
              } else {
                return prev;
              }
            }, null);

            if (mostVisibleSection) {
              _this3.currentAnchor = mostVisibleSection.dataset.id;
            }
          };

          var observer = new IntersectionObserver(setCurrentAnchor, options);
          var targets = [];
          this.anchorLinks.forEach(function (anchor) {
            var target = document.querySelector("[data-id=\"".concat(anchor.key, "\"]"));

            if (target) {
              targets.push(target);
            }
          }); // console.log(targets);

          targets.forEach(function (target) {
            observer.observe(target);
          });
        }
      },
      mounted: function mounted() {
        var _this4 = this;

        // console.log(this.$el)
        this.setTitle();
        this.detectHero();
        this.setAnchors();
        this.initMobile();
        this.scrollDirection();
        this.contactOpenText = this.$refs.contactBtn.querySelector('.button-text').dataset.openText; // for opening the contact tooltip from other modules

        _eventBus["default"].$on("open-contact", function () {
          _this4.contactOpen = true;
        }); // for toggling the contact tooltip in the cta top bar only


        _eventBus["default"].$on('toggle-contact', function () {
          _this4.toggleContact();
        });

        _eventBus["default"].$on('close-contact', function () {
          _this4.contactOpen = false;
        });
      }
    });

    _vueMin["default"].component('anchor-dropdown', {
      props: ['anchorLinks', 'showTitle', 'hasAnchors', 'isMobile', 'currentAnchor'],
      data: function data() {
        return {
          showAnchors: false,
          dropdownAnchor: null // showTopBar: true,

        };
      },
      computed: {
        computedCurrentAnchor: function computedCurrentAnchor() {
          return this.currentAnchor;
        }
      },
      watch: {
        "currentAnchor": function currentAnchor() {
          this.dropdownAnchor = this.currentAnchor;
        },
        // showTopBar: function() {
        //     let topBar = document.querySelector('.persistent-cta--top');
        //     if (this.isMobile) {
        //         if (this.showTopBar == true) {
        //             topBar.classList.remove('hide-bar');
        //         } else if (this.showTopBar == false) {
        //             topBar.classList.add('hide-bar');
        //         }
        //     }
        // },
        hasAnchors: function hasAnchors() {
          this.detectAnchors();
        }
      },
      template: "\n            <select name=\"pageSection\" class=\"persistent-cta__dropdown\" :anchor-links=anchorLinks v-on:change=\"jump\" v-if=\"showAnchors\" v-model=\"dropdownAnchor\">\n                <anchor-dropdown-item v-for=\"(item, index) in anchorLinks\" :key=\"index\" :data=\"item\"/>\n            </select>\n            ",
      methods: {
        jump: function jump(e) {
          // console.log("jump");
          window.location.hash = "#".concat(e.target.value); // console.log(e.target.value);
        },
        detectAnchors: function detectAnchors() {
          var _this5 = this;

          var subNav = document.querySelector(".sub-nav");
          window.addEventListener("scroll", function () {
            if (window.scrollY > subNav.offsetTop) {
              _this5.showAnchors = true;
            } else {
              _this5.showAnchors = false;
            }
          });
        }
      },
      mounted: function mounted() {
        this.$nextTick(function () {
          if (this.hasAnchors) {
            this.detectAnchors();
          }
        });
      }
    });

    _vueMin["default"].component('anchor-dropdown-item', {
      props: ['data'],
      template: "\n                <option :value=\"data.key\">{{data.name}}</option>\n            "
    });

    (0, _contactUs["default"])();
    new _vueMin["default"]({
      el: '.persistent-cta--top',
      store: _store["default"]
    }).$mount('.persistent-cta--top', true);
  };

  if (ctaBar) {
    ctaBarConstructor();
  }
};

var _default = ctaBarTop;
exports["default"] = _default;

},{"./contact-us":3,"./event-bus":9,"./store":51,"vue-js-modal":233,"vue/dist/vue.min.js":234}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var documentationContextual = function documentationContextual() {
  var docs = document.querySelectorAll('.doc-con');

  var documentationConstructor = function documentationConstructor(id) {
    _vueMin["default"].component('documentation-contextual-template', {
      data: function data() {
        return {
          emailDocs: [],
          //for emailing,
          mailto: null,
          mailtoAll: null,
          totalItems: null,
          items: []
        };
      },
      watch: {
        "emailDocs": function emailDocs() {
          var mailto = "mailto:?subject=Badger%20Meter%20Document%20Links&body=";
          this.emailDocs.forEach(function (item) {
            mailto = "".concat(mailto).concat(encodeURIComponent(item.name), ":%20").concat(item.url, "%0D%0A");
          });
          this.mailto = mailto;
        },
        "items": function items() {
          this.shareAll();
        }
      },
      methods: {
        updateEmailDocs: function updateEmailDocs(data) {
          var item = this.emailDocs.find(function (item) {
            return item.id == data.id;
          });

          if (!item) {
            this.emailDocs = [].concat(_toConsumableArray(this.emailDocs), [data]);
          } else {
            this.emailDocs.splice(this.emailDocs.indexOf(item), 1);
          }
        },
        updateItems: function updateItems(data) {
          this.items.push(data);
        },
        shareAll: function shareAll() {
          var mailto = "mailto:?subject=Badger%20Meter%20Document%20Links&body=";
          this.items.forEach(function (item) {
            mailto = "".concat(mailto).concat(item.name, ": ").concat(item.url, "%0D%0A");
          });
          this.mailtoAll = mailto;
        }
      },
      mounted: function mounted() {
        var _this = this;

        _eventBus["default"].$on('email-docs', function (data) {
          _this.updateEmailDocs(data);
        });

        _eventBus["default"].$on('update-items', function (data) {
          _this.updateItems(data);
        });

        this.shareAll(); //init share all

        this.totalItems = Array.from(this.$el.querySelectorAll('.doc-card')).length;
      }
    });

    _vueMin["default"].component('doc-con-item', {
      data: function data() {
        return {
          isBookmarked: false,
          id: null,
          type: "documentId",
          name: null,
          url: null,
          seeAll: null,
          //is "see all" feature enabled,
          seeAllOpen: null,
          seeAllLabel: null,
          //label
          moreContent: null
        };
      },
      computed: {
        saved: function saved() {
          return _store["default"].state.favorites["".concat(this.type)];
        }
      },
      watch: {
        saved: function saved() {
          this.isBookmarked = this.saved.includes(this.id) ? true : false;
        },
        "seeAll": function seeAll() {
          if (this.seeAll) {
            this.seeAllLabel = this.seeAllOpen ? window.seeLessLabel : window.seeAllLabel;
          }
        },
        "seeAllOpen": function seeAllOpen() {
          if (this.seeAll) {
            this.seeAllLabel = this.seeAllOpen ? window.seeLessLabel : window.seeAllLabel;
          }
        }
      },
      methods: {
        emailDoc: function emailDoc() {
          _eventBus["default"].$emit('email-docs', {
            "name": this.name,
            "url": this.url,
            "id": this.id
          });
        },
        handleBookmark: function handleBookmark() {
          _store["default"].commit('updateFavorites', {
            id: this.id,
            type: this.type,
            action: this.isBookmarked ? "remove" : "add"
          });

          _store["default"].dispatch('checkFavorites');
        },
        toggleSeeAll: function toggleSeeAll() {
          this.seeAllOpen = !this.seeAllOpen;
        },
        initSeeAll: function initSeeAll() {
          if (this.$refs.seeAllContent) {
            var details = this.$refs.seeAllContent.innerHTML.split(',');
            this.seeAll = details.length > 3 ? true : false;
            var truncatedDetails = details.slice(0, 3).join();
            var moreDetails = details.slice(3).join();
            this.moreContent = moreDetails;
            this.$refs.seeAllContent.innerHTML = "".concat(truncatedDetails, ",");
          }
        }
      },
      mounted: function mounted() {
        var _this2 = this;

        this.id = this.$refs.bookmark.dataset.documentId;
        this.isBookmarked = this.saved.includes("".concat(this.id)) ? true : false;
        this.name = this.$refs.name.innerText;
        this.url = this.$refs.name.getAttribute('href');
        this.$nextTick(function () {
          _eventBus["default"].$emit('update-items', {
            "name": _this2.name,
            "url": _this2.url,
            "id": _this2.id
          });
        });
        this.initSeeAll();
      }
    });

    new _vueMin["default"]({
      el: ".doc-con-".concat(id)
    }).$mount(".doc-con-".concat(id), true);
  };

  if (docs.length > 0) {
    docs.forEach(function (item, index) {
      item.classList.add("doc-con-".concat(index));
      documentationConstructor(index);
    });
  }
};

var _default = documentationContextual;
exports["default"] = _default;

},{"./event-bus":9,"./store":51,"vue/dist/vue.min.js":234}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _axios = _interopRequireDefault(require("axios"));

var _db = _interopRequireDefault(require("../../../db.json"));

var _filterComponents = require("./filter-components");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var safeString = function safeString(str) {
  return encodeURIComponent(str);
};

var Documentation = function Documentation() {
  var documentation = document.querySelectorAll('.documentation');

  var documentationConstructor = function documentationConstructor(id) {
    _vueMin["default"].component('documentation-template', {
      data: function data() {
        return {
          data: {
            currentPage: 1,
            //current page #
            totalPages: null,
            //total returns pages
            totalResults: null,
            //total results
            shownResults: null,
            //total shown items
            filtersVisible: null,
            //are filters visible
            filterAreaVisible: true,
            filters: [],
            products: [],
            results: [],
            emailDocs: [],
            //for emailing
            savedDocs: [],
            //bookmarked items
            savedDocsLabel: null,
            //label for saved docs,
            savedDocsOnly: null,
            //is saved docs only checked?
            isMobile: null,
            nextActive: null,
            prevActive: null,
            // apiUrl: null, //for api call
            urlParams: null,
            //for deeplinking in-browser
            shareAll: false,
            query: null,
            //search query
            // store: store
            "class": 'documentation',
            trackingType: 'document'
          },
          isLoading: null
        };
      },
      components: {
        'filter-accordion-template': _filterComponents.Accordion,
        'selectedFilters': _filterComponents.SelectedFiltersComponent,
        'checkbox-item': _filterComponents.Checkbox,
        'pagination': _filterComponents.Pagination
      },
      computed: {
        computedIsMobile: function computedIsMobile() {
          return _store["default"].state.isMobile;
        },
        saved: function saved() {
          return _store["default"].state.favorites.documentId;
        },
        pageRange: function pageRange() {
          if (this.data.totalResults > 10) {
            if (this.data.currentPage == 1) {
              return "1-".concat(this.data.shownResults);
            } else if (this.data.currentPage == this.data.totalPages) {
              return "".concat(this.data.totalResults - this.data.shownResults + 1, "-").concat(this.data.totalResults);
            } else {
              return "".concat(this.data.shownResults * (this.data.currentPage - 1) + 1, "-").concat(this.data.shownResults * this.data.currentPage);
            }
          } else {
            return this.data.shownResults;
          }
        },
        page: function page() {
          return this.data.currentPage;
        },
        lang: function lang() {
          return _store["default"].state.currentLang;
        }
      },
      watch: {
        saved: function saved() {
          this.data.savedDocs = this.saved; // remove saved only filter if no saved items

          if (this.saved.length == 0) {
            var index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf('savedDocuments');

            if (index > -1) {
              this.data.filters.splice(index, 1);
            }
          }
        },
        computedIsMobile: function computedIsMobile() {
          this.data.isMobile = this.computedIsMobile;
          this.data.filtersVisible = !this.computedIsMobile ? true : this.data.filtersVisible;
        },
        "data.filters": function dataFilters() {
          var _this = this;

          this.addLoading();
          this.getResults(); // handle api call
          // this.updateHistory(); // handle history record
          // this.data.currentPage = 1; //reset page to 1

          this.data.emailDocs = []; // check for if brand is selected

          var brands = this.data.filters.filter(function (el) {
            return el.type == "brand";
          }).map(function (el) {
            return el.value;
          });

          if (brands.length > 0) {
            this.populateProducts(brands);
          } else {
            //if not brand selected, empty the products array
            this.data.products = []; // remove selected product filters

            this.data.filters.filter(function (el) {
              return el.type == "product";
            }).forEach(function (item) {
              _this.removeFilter(_this.data["class"], item.value);
            });
          } // set savedDocsOnly value


          var savedOnly = this.data.filters.find(function (item) {
            return item.type == "savedDocuments";
          });
          this.data.savedDocsOnly = savedOnly ? savedOnly.value : null;
        },
        page: function page() {
          if (this.data.currentPage == 1) {
            this.data.nextActive = true;
            this.data.prevActive = false;
          } else if (this.data.currentPage == this.data.totalPages) {
            this.data.nextActive = false;
            this.data.prevActive = true;
          } else {
            this.data.nextActive = true;
            this.data.prevActive = true;
          } // this.getResults();
          // this.updateHistory();

        },
        "data.totalResults": function dataTotalResults() {
          this.initPages();
        }
      },
      methods: {
        toggleFilters: function toggleFilters() {
          // console.log("clicked");
          if (this.data.isMobile) {
            // console.log("is mobile");
            this.data.filtersVisible = !this.data.filtersVisible;
          }
        },
        updateFilters: function updateFilters(el, e, type) {
          if (el !== this.data["class"]) {
            return; //abort if not documentation module
          }

          var type = type;
          var value = safeString(e.currentTarget.value);
          var label = e.currentTarget.parentNode.innerText;
          var checked = e.currentTarget.checked;
          this.data.currentPage = 1; // console.log("type", type)
          // console.log(e);
          // console.log("value", safeString(e.target.value));
          // console.log("checked",e.target.checked);

          if (checked) {
            if (type !== "savedDocuments") {
              this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                "value": value,
                "type": type,
                "name": label
              }]);
            } else {
              this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                "value": checked,
                "type": type,
                "name": label
              }]);
            }
          } else {
            var index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf(value); // console.log("INDEX", index);

            this.data.filters.splice(index, 1);
          }
        },
        // removes specific filter
        removeFilter: function removeFilter(el, value, type) {
          if (el !== this.data["class"]) {
            return;
          }

          var index = this.data.filters.map(function (e) {
            return e.value;
          }).indexOf(value);
          this.data.filters.splice(index, 1);
        },
        // clears filters
        removeAll: function removeAll() {
          this.data.filters = [];
          this.data.currentPage = 1; //reset page to 1
        },
        populateProducts: function populateProducts(brands) {
          // need to concat options from all selected brands and remove options when brands are unselected 
          var brandStr = decodeURIComponent(brands.join('|')); // // console.log(brandStr);

          var apiUrl = "/api/GetDocumentProductsByBrand"; // let apiUrl = "http://localhost:3003/productsByBrand"; //from json-server

          var self = this;

          _axios["default"].get(apiUrl, {
            params: {
              brand: brandStr,
              lang: this.lang
            }
          }).then(function (response) {
            // console.log(response);
            self.data.products = response.data.results;
          })["catch"](function (error) {
            console.log(error);
          });
        },
        getUrl: function getUrl() {
          var _this2 = this;

          var savedParams = this.data.savedDocs.toString();
          var query = this.data.query;
          var productParams = this.data.filters.filter(function (item) {
            return item.type == "product";
          }).map(function (item) {
            return item.value;
          }).toString();
          var langParams = this.data.filters.filter(function (item) {
            return item.type == "lang";
          }).map(function (item) {
            return item.value;
          }).toString();
          var brandParams = this.data.filters.filter(function (item) {
            return item.type == "brand";
          }).map(function (item) {
            return item.value;
          }).toString();
          var docTypeParams = this.data.filters.filter(function (item) {
            return item.type == "docType";
          }).map(function (item) {
            return item.value;
          }).toString();

          var savedDocumentsTrueParams = function savedDocumentsTrueParams() {
            var savedOnly = _this2.data.filters.find(function (item) {
              return item.type == "savedDocuments";
            });

            if (savedOnly) {
              return savedOnly.value;
            } else {
              return false;
            }
          };

          var pageParams = this.data.currentPage;
          this.data.urlParams = "?";

          if (query) {
            this.data.urlParams += "q=" + encodeURIComponent(query);
          }

          this.data.urlParams += "".concat(productParams !== "" ? "&product=" + productParams : "").concat(langParams !== "" ? "&lang=" + langParams : "").concat(brandParams !== "" ? "&brand=" + brandParams : "").concat(docTypeParams !== "" ? "&docType=" + docTypeParams : "", "&savedDocuments=").concat(savedDocumentsTrueParams(), "&page=").concat(pageParams);
        },
        didYouMean: function didYouMean(e) {
          var didyoumeanEl = document.querySelectorAll('.peoplealsosearchedfor');
          var didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__peoplealsosearchedfor');
          didyoumeanContainer.forEach(function (element) {
            return element.classList.remove('show');
          });
          didyoumeanEl = document.querySelectorAll('.didyoumean');
          didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__didyoumean');
          didyoumeanContainer.forEach(function (element) {
            return element.classList.remove('show');
          }); //console.log('didYouMean',e);

          var query;

          if (e.target) {
            query = e.target.innerText;
          } else {
            query = e;
          }

          this.data.query = query; //this.updateHistory();

          document.querySelector('.hero-center__search-input').value = query;
          this.addLoading();
          this.getResults(e);
        },
        addLoading: function addLoading() {
          this.isLoading = true;
          var inputField = document.querySelector('.hero-center__search-input-container');
          if (inputField) inputField.classList.add('loading');
        },
        removeLoading: function removeLoading() {
          this.isLoading = false;
          var inputField = document.querySelector('.hero-center__search-input-container');
          if (inputField) inputField.classList.remove('loading');
        },
        getResults: function getResults(query) {
          var _this3 = this;

          // let apiUrl = "api/documents?";
          // console.log("QUERY", query);
          this.data.query = query === null ? null : query ? query : this.data.query;
          this.data.currentPage = query ? 1 : this.data.currentPage;
          this.getUrl();
          var baseUrl = window.documentAPIUrl;
          var apiUrl = "".concat(baseUrl).concat(baseUrl.indexOf('?') > -1 ? '' : '?'); // let apiUrl = "http://localhost:3003/documentation"; //from json-server
          // let apiUrlTest = "http://localhost:3003/documentationTest"; //from json-server

          var self = this;

          var savedDocumentsTrueParams = function savedDocumentsTrueParams() {
            var savedOnly = _this3.data.filters.find(function (item) {
              return item.type == "savedDocuments";
            });

            if (savedOnly) {
              return true;
            } else {
              return false;
            }
          };

          var product = [];
          var lang = [];
          var brand = [];
          var docType = [];
          this.data.filters.map(function (item) {
            switch (item.type) {
              case "product":
                product.push(item.value);
                break;

              case "lang":
                lang.push(item.value);
                break;

              case "brand":
                brand.push(item.value);
                break;

              case "docType":
                docType.push(item.value);
                break;

              default:
                return;
            }
          });
          var productStr = decodeURIComponent(product.join('|'));
          var langStr = decodeURIComponent(lang.join('|'));
          var brandStr = decodeURIComponent(brand.join('|'));
          var docTypeStr = decodeURIComponent(docType.join('|'));
          var axiosParams = {
            q: this.data.query ? this.data.query : null,
            saved: this.data.savedDocs.join('|') == "" ? null : this.data.savedDocs.join('|').charAt(0) == "," ? this.data.savedDocs.join('|').slice(1) : this.data.savedDocs.join('|'),
            //@TODO make this less insane. Send NULL if empty string. Remove leading comma if present.
            product: productStr == "" ? null : productStr,
            language: langStr == "" ? null : langStr,
            brand: brandStr == "" ? null : brandStr,
            docType: docTypeStr == "" ? null : docTypeStr,
            savedDocuments: savedDocumentsTrueParams(),
            page: this.data.currentPage
          }; // console.log(axiosParams);

          _axios["default"].get(apiUrl, {
            params: _objectSpread({}, axiosParams)
          }).then(function (response) {
            ///
            /// Did you mean query logic from episerver find:
            ///
            var didyoumeanEl, didyoumeanContainer;

            if (response.data.results.length == 0) {
              didyoumeanEl = document.querySelectorAll('.didyoumean');
              didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__didyoumean');
            } else {
              didyoumeanEl = document.querySelectorAll('.peoplealsosearchedfor');
              didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__peoplealsosearchedfor');
            }

            if (response.data.didYouMean && response.data.didYouMean.length > 0) {
              var commaEl;

              (function () {
                var allElements = []; //console.log('  --> Creating clickable elements');

                response.data.didYouMean.forEach(function (dym) {
                  var anchorElement = document.createElement('a');
                  anchorElement.href = "#";
                  anchorElement.innerText = dym;
                  anchorElement.addEventListener("click", function (e) {
                    e.stopPropagation();
                    self.didYouMean(anchorElement.innerText);
                  });
                  allElements.push(anchorElement);
                }); //clear out all previous elements
                //console.log('  --> clearing out elements from ', didyoumeanEl);

                didyoumeanEl.forEach(function (parent) {
                  while (parent.firstChild) {
                    console.log('      -> removing: ', parent.firstChild);
                    parent.removeChild(parent.firstChild);
                  }
                }); //console.log('  --> Appending to ', didyoumeanEl);

                var _loop = function _loop(i) {
                  didyoumeanEl.forEach(function (el) {
                    return el.append(allElements[i]);
                  });

                  if (i + 1 < allElements.length) {
                    commaEl = document.createElement('span');
                    commaEl.style.paddingLeft = "7px";
                    didyoumeanEl.forEach(function (el) {
                      return el.append(commaEl);
                    });
                  }
                };

                for (var i = 0; i < allElements.length; i++) {
                  _loop(i);
                } //console.log('  --> Showing', didyoumeanContainer);


                didyoumeanContainer.forEach(function (element) {
                  return element.classList.add('show');
                });
              })();
            } else {
              didyoumeanContainer.forEach(function (element) {
                return element.classList.remove('show');
              });
            } ///
            /// End of did you mean query logic
            ///


            self.data.results = response.data.results;
            self.data.totalResults = response.data.totalResults;
            self.data.shownResults = response.data.results.length;
            self.data.trackId = response.data.trackId;
            self.removeLoading();
          })["catch"](function (error) {
            console.log(error);
            self.removeLoading();
          });
        },
        changePage: function changePage(dir) {
          if (dir == "prev" && this.data.currentPage !== 1) {
            this.data.currentPage--;
          } else if (dir == "next" && this.data.currentPage !== this.data.totalPages) {
            this.data.currentPage++;
          } else {
            return;
          }

          _eventBus["default"].$emit('scroll-to-top', this.data["class"]);

          this.addLoading();
          this.getResults();
        },
        updateEmailDocs: function updateEmailDocs(data) {
          var item = this.data.emailDocs.find(function (item) {
            return item.id == data.id;
          });

          if (!item) {
            this.data.emailDocs = [].concat(_toConsumableArray(this.data.emailDocs), [data]);
          } else {
            this.data.emailDocs.splice(this.data.emailDocs.indexOf(item), 1);
          }
        },
        //update history record when filters change
        updateHistory: function updateHistory() {
          this.getUrl();
          var url = "".concat(window.location.pathname).concat(this.data.urlParams);
          history.pushState("", "", url);
        },
        // handle deep linking on history change
        deeplink: function deeplink() {
          var _this4 = this;

          var didyoumeanEl = document.querySelectorAll('.peoplealsosearchedfor');
          var didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__peoplealsosearchedfor');
          didyoumeanContainer.forEach(function (element) {
            return element.classList.remove('show');
          });
          didyoumeanEl = document.querySelectorAll('.didyoumean');
          didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__didyoumean');
          didyoumeanContainer.forEach(function (element) {
            return element.classList.remove('show');
          });
          var params = window.location.search.substr(1).split("&").filter(function (item) {
            return item != "";
          }); // console.log(params);
          // this.data.filters = []; //clear filters array first

          var initFilters = [];
          var page;
          params.forEach(function (param) {
            var type = param.slice(0, param.indexOf('='));
            var content = param.slice(param.indexOf('=') + 1); // console.log("TYPE",type);
            // console.log("CONTENT", content);

            var entry = {};

            if (type == "page") {
              // console.log("PAGE", parseInt(content));
              // this.data.currentPage = parseInt(content);
              page = parseInt(content);
            } else if (type == "savedDocuments") {
              if (content == "false" || content == false) {
                return;
              } else {
                entry = {
                  "type": type,
                  "value": true,
                  "name": _this4.data.savedDocsLabel
                };
                initFilters = [].concat(_toConsumableArray(initFilters), [entry]);
              }
            } else if (content.indexOf(',') > -1) {
              var contentArray = content.split(',');
              contentArray.forEach(function (item) {
                entry = {
                  "type": type,
                  "value": item,
                  "name": decodeURIComponent(item)
                };
                initFilters = [].concat(_toConsumableArray(initFilters), [entry]);
              });
            } else {
              entry = {
                "type": type,
                "value": content,
                "name": decodeURIComponent(content)
              };
              initFilters = [].concat(_toConsumableArray(initFilters), [entry]);
            }

            _this4.data.filters = initFilters; // console.log(this.initFilters);
          });
          this.data.currentPage = page;
        },
        scrollToTop: function scrollToTop(el) {
          if (el !== this.data["class"]) {
            return;
          }

          var top = this.$el.querySelector('.documentation__area-cards').getBoundingClientRect().top + window.scrollY - 100; // console.log(top);

          setTimeout(function () {
            window.scrollTo({
              top: top,
              behavior: 'smooth'
            });
          }, 500);
        },
        initPages: function initPages() {
          // based on total result count, divide by 10 to get total pages needed
          // math ceil to round up
          // set active for prev/next based on current page
          this.data.totalPages = Math.ceil(this.data.totalResults / 10);
          this.data.prevActive = this.data.currentPage !== 1 ? true : false;
          this.data.nextActive = this.data.currentPage !== this.data.totalPages ? true : false;
        },
        init: function init() {
          var _this5 = this;

          this.data.isMobile = _store["default"].state.isMobile;
          this.data.savedDocs = _store["default"].state.favorites.documentId[0] == "" ? _store["default"].state.favorites.documentId.slice(1) : _store["default"].state.favorites.documentId;
          this.data.filtersVisible = this.data.isMobile ? false : true; //init show/hide filters if/is mobile
          // listen for filter updates in children

          _eventBus["default"].$on('updateFilters', function (el, e, type) {
            _this5.updateFilters(el, e, type);
          });

          _eventBus["default"].$on('remove-filter', function (el, value, type) {
            _this5.removeFilter(el, value, type);
          });

          _eventBus["default"].$on('change-page-to', function (el, num) {
            if (el !== _this5.data["class"]) {
              return;
            }

            ;
            _this5.data.currentPage = num;

            _this5.addLoading();

            _this5.getResults();
          });

          _eventBus["default"].$on('email-docs', function (data) {
            _this5.updateEmailDocs(data);
          });

          _eventBus["default"].$on('internal-search', function (value, type) {
            if (type == "documentation") {
              //this.updateHistory(value);
              var didyoumeanEl = document.querySelectorAll('.peoplealsosearchedfor');
              var didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__peoplealsosearchedfor');
              didyoumeanContainer.forEach(function (element) {
                return element.classList.remove('show');
              });
              didyoumeanEl = document.querySelectorAll('.didyoumean');
              didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__didyoumean');
              didyoumeanContainer.forEach(function (element) {
                return element.classList.remove('show');
              });

              _this5.addLoading();

              _this5.getResults(value);
            }
          });

          _eventBus["default"].$on('scroll-to-top', function (el) {
            _this5.scrollToTop(el);
          }); // init results


          this.data.results = window.initialDocumentationApiResults.results;
          this.data.totalResults = window.initialDocumentationApiResults.totalResults;
          this.data.shownResults = window.initialDocumentationApiResults.results.length; // this.data.results = fpodb.documentation.results;
          // this.data.totalResults = fpodb.documentation.totalResults;
          // this.data.shownResults = fpodb.documentation.results.length;
          // hide filters if less then 10 initial results

          this.data.filterAreaVisible = parseInt(this.data.totalResults) <= 10 ? false : true; // enable "share all" if 5 of less results

          this.data.shareAll = parseInt(this.data.totalResults) <= 5 ? true : false;

          window.onpopstate = function () {
            _this5.deeplink();
          };
        }
      },
      mounted: function mounted() {
        this.init();
        this.initPages(); // for deeplinking
        // if (window.location.search) {
        //     this.$nextTick(() => {
        //         this.deeplink();
        //     });
        // }
      }
    });

    _vueMin["default"].component('doc-products', {
      props: ['data', 'category'],
      data: function data() {
        return {
          type: "product"
        };
      },
      components: {
        'checkbox-item': _filterComponents.Checkbox
      },
      template: "\n            <div class=\"documentation__products-content\">\n                <checkbox-item v-for=\"(productItem, i) in data.products\" :key=i :type=\"type\" :label=\"productItem.value\" :value=\"productItem.key\" :data=\"data\" :category=\"category\"/>\n            </div>\n            ",
      methods: {},
      mounted: function mounted() {}
    }); // results list


    _vueMin["default"].component('doc-results-list', {
      props: ['data', 'isLoading'],
      data: function data() {
        return {
          type: "product"
        };
      },
      template: "\n            <div class=\"documentation__cards-content\" :data=\"data\">\n                <doc-results-item v-for=\"(result, index) in data.results\" :content=\"result\" :isSelected=\"isSelected(result)\" :key=\"result.id\" :data=\"data\" :isLoading=\"isLoading\" />\n            </div>\n            ",
      methods: {
        isSelected: function isSelected(result) {
          return this.data.emailDocs.find(function (i) {
            return i.id == result.id;
          }) !== undefined;
        }
      },
      mounted: function mounted() {}
    }); // single results item


    _vueMin["default"].component('doc-results-item', {
      props: ['data', 'content', 'isSelected', 'isLoading'],
      data: function data() {
        return {
          isChecked: this.isSelected,
          isBookmarked: false,
          id: null,
          seeAll: null,
          //is "see all" feature enabled,
          seeAllOpen: null,
          seeAllLabel: null,
          //label
          moreContent: null
        };
      },
      computed: {
        saved: function saved() {
          return _store["default"].state.favorites.documentId;
        },
        encodedUrl: function encodedUrl() {
          return encodeURIComponent(this.content.url);
        },
        newTabLink: function newTabLink() {
          return this.content.url ? this.content.url.replace('download=true', 'download=false') : null;
        },
        tagMetaBody: function tagMetaBody() {
          return JSON.stringify({
            "type": "document",
            "category": this.content.eyebrow,
            "label": this.content.name,
            "productLine": this.content.details,
            "language": this.content.language
          });
        }
      },
      watch: {
        saved: function saved() {
          this.isBookmarked = this.saved.includes(this.id) ? true : false;
        },
        "data.emailDocs": function dataEmailDocs() {
          if (this.data.emailDocs.length === 0) {
            this.isChecked = false;
          }
        },
        "content": function content() {
          var _this6 = this;

          // update id when content changes
          this.$nextTick(function () {
            // console.log(this.$refs.bookmark.dataset.documentId);
            _this6.id = _this6.$refs.bookmark.dataset.documentId;
            _this6.isBookmarked = _this6.saved.includes("".concat(_this6.id)) ? true : false;
          });
        },
        "seeAll": function seeAll() {
          if (this.seeAll) {
            this.seeAllLabel = this.seeAllOpen ? window.seeLessLabel : window.seeAllLabel;
          }
        },
        "seeAllOpen": function seeAllOpen() {
          if (this.seeAll) {
            this.seeAllLabel = this.seeAllOpen ? window.seeLessLabel : window.seeAllLabel;
          }
        }
      },
      template: "\n            <div class=\"doc-card doc-card--checkbox\" :class=\"{'hide-bookmark': (data.savedDocsOnly === true) && (isBookmarked === false)}\" data-tag-trigger=\"click\" :data-tag-meta='tagMetaBody'>\n                <div class=\"doc-card__wrapper\">\n                    <div class=\"doc-card__row\">\n                        <div class=\"doc-card__area doc-card__area-checkbox\">\n                        <div class=\"checkbox\">\n                                <label class=\"checkbox__label\">\n                                    <input type=\"checkbox\" class=\"checkbox__input\" :value=\"content.id\" v-on:change=\"emailDoc\" v-model=\"isChecked\" :checked=\"isChecked\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"document\", \"action\": \"Select\"}'>\n                                    <span class=\"checkbox__checkmark\"></span>\n                                </label>\n                            </div>\n                        </div>\n                        \n                        <div class=\"doc-card__area doc-card__area-info\">\n                            <div class=\"doc-card__area doc-card__area-left\">\n                                <span class=\"doc-card__eyebrow\">\n                                    {{content.eyebrow}}\n                                </span>\n                                <a :href=\"newTabLink\" class=\"doc-card__title\" target=\"_blank\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"document\", \"action\": \"Preview\"}'>\n                                    {{content.name}}\n                                </a>\n                                <span class=\"doc-card__subtitle\">\n                                    <span class=\"doc-card__subtitle-content\" ref=\"seeAllContent\">{{content.details}}</span> <span class=\"doc-card__subtitle-more\" v-if=\"seeAll && seeAllOpen\">{{moreContent}}</span> <a href=\"#\" v-on:click.prevent=\"toggleSeeAll\" v-if=\"seeAll\">{{seeAllLabel}}</a> | {{content.language}}\n                                </span> \n                            </div>\n                            <div class=\"doc-card__area doc-card__area-right\">\n                                <a class=\"doc-card__icon doc-card__icon-download\" :href=\"content.url\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"document\", \"action\": \"Download\"}'></a>\n                                <a class=\"doc-card__icon doc-card__icon-email\" :href=\"'mailto:?subject=Badger%20Meter%20Document%20Links&body=' + content.name + ': ' + this.encodedUrl\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"document\", \"action\": \"Email\"}'></a>\n                                <a class=\"doc-card__icon doc-card__icon-bookmark\" :data-document-id=\"content.id\" ref=\"bookmark\" v-on:click=\"handleBookmark\" :class=\"{active: isBookmarked}\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"document\", \"action\": \"Favorite\"}'></a>\n                            </div>\n                        </div>\n                        \n                    </div>\n                </div>\n            </div>\n            ",
      methods: {
        emailDoc: function emailDoc() {
          _eventBus["default"].$emit('email-docs', {
            "name": this.content.name,
            "url": this.content.url,
            "id": this.content.id
          });
        },
        handleBookmark: function handleBookmark() {
          _store["default"].commit('updateFavorites', {
            id: this.id,
            type: "documentId",
            action: this.isBookmarked ? "remove" : "add"
          });

          _store["default"].dispatch('checkFavorites');
        },
        toggleSeeAll: function toggleSeeAll() {
          this.seeAllOpen = !this.seeAllOpen;
        },
        initSeeAll: function initSeeAll() {
          if (this.$refs.seeAllContent) {
            var details = this.$refs.seeAllContent.innerHTML.split(',');
            this.seeAll = details.length > 3 ? true : false;
            var truncatedDetails = details.slice(0, 3).join();
            var moreDetails = details.slice(3).join();
            this.moreContent = moreDetails;
            this.$refs.seeAllContent.innerHTML = "".concat(truncatedDetails).concat(moreDetails == "" ? '' : ',');
          }
        }
      },
      mounted: function mounted() {
        this.id = this.$refs.bookmark.dataset.documentId; // console.log("saved",this.saved);

        this.isBookmarked = this.saved.includes("".concat(this.id)) ? true : false;
        this.initSeeAll();
        var self = this;
        this.$nextTick(function () {
          var trackId = self.data.trackId;

          if (trackId) {
            var hitId = self.content.hitId;
            var query = self.data.query;
            var url = "/api/SearchHit?q=".concat(encodeURIComponent(query), "&h=").concat(encodeURIComponent(hitId), "&t=").concat(encodeURIComponent(trackId));
            var allAnchors = self.$el.querySelectorAll('a');
            allAnchors.forEach(function (el) {
              return el.addEventListener('click', function (e) {
                return _axios["default"].get(url).then(function (response) {});
              });
            });
          }
        });
      }
    });

    _vueMin["default"].component('email-docs', {
      props: ['data'],
      data: function data() {
        return {
          mailto: null // mailtoAll: null

        };
      },
      watch: {
        "data.emailDocs": function dataEmailDocs() {
          var mailto = "mailto:?subject=Badger%20Meter%20Document%20Links&body=";
          this.data.emailDocs.forEach(function (item) {
            mailto = "".concat(mailto).concat(encodeURIComponent(item.name), ": ").concat(encodeURIComponent(item.url), "%0D%0A");
          });
          this.mailto = mailto;
        }
      },
      methods: {// shareAll() {
        //     let mailto = "mailto:?subject=Badger%20Meter%20Document%20Links&body=";
        //     this.data.results.forEach(item => {
        //         mailto = `${mailto}${item.name}: ${item.url}%0D%0A`;
        //     });
        //     this.mailtoAll = mailto;
        // }
      },
      mounted: function mounted() {// if (parseInt(this.data.totalResults) <= 5) {
        //     this.shareAll();
        // }
      }
    });

    new _vueMin["default"]({
      el: ".documentation-".concat(id),
      store: _store["default"]
    }).$mount(".documentation-".concat(id), true);
  };

  if (documentation.length > 0) {
    documentation.forEach(function (item, index) {
      item.classList.add("documentation-".concat(index));
      documentationConstructor(index);
    });
  } // window.seeLessLabel = "see less";
  // window.seeAllLabel = "see more";

};

var _default = Documentation;
exports["default"] = _default;

},{"../../../db.json":64,"./event-bus":9,"./filter-components":11,"./store":51,"axios":66,"vue/dist/vue.min.js":234}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _store = _interopRequireDefault(require("./store"));

var _pardotForm = require("./pardot-form");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Drawer = function Drawer() {
  var drawers = document.querySelectorAll('.drawer__wrapper');

  var drawerConstructor = function drawerConstructor(id) {
    // main component wrapper
    _vueMin["default"].component('drawer-template', {
      data: function data() {
        return {
          activeTab: '',
          isMobile: _store["default"].state.isMobile,
          store: _store["default"]
        };
      },
      computed: {
        mobileState: function mobileState() {
          return _store["default"].state.isMobile;
        }
      },
      watch: {
        mobileState: function mobileState() {
          this.isMobile = this.mobileState;
        }
      },
      methods: {
        setActiveTab: function setActiveTab(e) {
          this.activeTab = e;
        },
        handleTab: function handleTab(e) {
          var tabTarget = e.currentTarget.dataset.target;

          if (tabTarget !== this.activeTab) {
            // console.log("derp");
            this.setActiveTab(tabTarget);
            this.$el.querySelector('.drawer__tab-item.active').classList.remove('active');
            this.$el.querySelector("[data-target=".concat(tabTarget, "]")).classList.add('active');
          }
        },
        setResponsive: function setResponsive() {
          if (!isMobile) {
            // remove inline styles from accordions
            var accordionContainers = this.$el.querySelectorAll('.drawer__drawer-content-container');
            accordionContainers.forEach(function (item) {
              item.style = null;
            });
          }
        },
        // set the first tab to active
        initDesktop: function initDesktop() {
          if (this.isMobile) {//under 768px
          } else {
            //over 768px
            // if desktop, check for desktop buttons and set initial tab
            var initial = this.$el.querySelector('[data-target]').dataset.target;
            this.activeTab = initial;
            this.$el.querySelector('[data-target]').classList.add('active');
          }
        }
      },
      mounted: function mounted() {
        var _this = this;

        // console.log(store.state.isMobile);
        this.initDesktop(); //set the first tab to active on init
        //listen for child click events on the labels and pass targets to parent

        _eventBus["default"].$on('handle-mobile', function (e) {
          _this.setActiveTab(e);
        });

        _eventBus["default"].$on('handle-desktop', function (e) {
          _this.setActiveTab(e);
        });
      }
    }); // desktop labels


    _vueMin["default"].component('drawer-tab-label', {
      props: ['activeTab', 'isMobile'],
      data: function data() {
        return {
          tabTarget: '',
          isActive: false
        };
      },
      watch: {
        activeTab: function activeTab() {
          this.isActive = this.activeTab == this.tabTarget ? true : false;
        }
      },
      methods: {
        handleTab: function handleTab(e) {
          _eventBus["default"].$emit('handle-desktop', this.tabTarget);
        }
      },
      mounted: function mounted() {
        this.tabTarget = this.$el.dataset.target;
      }
    }); // mobile accordion containers & labels


    _vueMin["default"].component('drawer-content-template', {
      props: ['activeTab', 'isMobile'],
      //active tab 
      data: function data() {
        return {
          tabName: '',
          isActive: false,
          //is current tab the selected tab 'activeTab'
          isOpen: false //is tab open

        };
      },
      watch: {
        activeTab: function activeTab(tab) {
          this.isActive = this.tabName == tab ? true : false;
        },
        isActive: function isActive() {
          if (!this.isActive) {
            this.isOpen = false; //set accodion to close when not the active item
            // close the accordion

            if (this.isMobile) {
              var contentArea = this.$el.querySelector('.drawer__drawer-content-container');
              var contentHeight = this.$el.querySelector('.drawer__drawer-content-inner').getBoundingClientRect().height;
              requestAnimationFrame(function () {
                //set content area height to content height to prevent transitioning from auto
                contentArea.style.maxHeight = contentHeight + 'px'; // have the element transition to height: 0

                requestAnimationFrame(function () {
                  contentArea.style.maxHeight = '0px';
                });
              });
              contentArea.addEventListener('transitionend', function () {
                contentArea.style.maxHeight = '0';
              });
              this.scrollToTop();
            }
          } else {
            // if this is the active tab, set isOpen to true when isActive is true to pre open the tab on mobile
            this.isOpen = true;
          }
        }
      },
      methods: {
        handleMobile: function handleMobile(e) {
          var mobileTarget = e.currentTarget.parentNode.dataset.tabId;

          _eventBus["default"].$emit('handle-mobile', mobileTarget);

          if (this.isMobile) {
            // toggle the accordion
            this.handleAccordion(e);
          }
        },
        // toggle accordions
        handleAccordion: function handleAccordion(e) {
          var contentArea = this.$el.querySelector('.drawer__drawer-content-container');
          var contentHeight = this.$el.querySelector('.drawer__drawer-content-inner').getBoundingClientRect().height;

          if (this.isOpen == true) {
            this.isOpen = false;
            requestAnimationFrame(function () {
              //set content area height to content height to prevent transitioning from auto
              contentArea.style.maxHeight = contentHeight + 'px'; // have the element transition to height: 0

              requestAnimationFrame(function () {
                contentArea.style.maxHeight = '0px';
              });
            });
            contentArea.addEventListener('transitionend', function () {
              contentArea.style.maxHeight = '0';
            });
          } else {
            this.isOpen = true;
            contentArea.style.maxHeight = contentHeight + "px";
            contentArea.addEventListener('transitionend', function () {
              contentArea.style.maxHeight = 'none';
            });
          }
        },
        scrollToTop: function scrollToTop() {
          var elmOffset = this.$el.offsetTop;
          var scrollOffset = window.scrollY; // console.log("el",elmOffset);
          // console.log("window",scrollOffset);

          if (elmOffset < scrollOffset) {
            var elmPos = this.$el.getBoundingClientRect().top + window.scrollY;
            setTimeout(function () {
              window.scrollTo({
                top: elmPos - 70,
                behavior: 'smooth'
              });
            }, 500);
          }
        },
        initMobile: function initMobile() {
          if (this.isMobile) {// console.log("is mobile");
          } else {
            // console.log("not mobile");
            // remove all inline styles for accordions on desktop
            var contentContainers = this.$el.querySelectorAll('.drawer__drawer-content-container');
            contentContainers.forEach(function (item) {
              item.style = '';
            });
          }
        }
      },
      mounted: function mounted() {
        var initialTab = this.$el.dataset.tabId;
        this.tabName = initialTab;
        this.initMobile();
      }
    }); // import pardot form component instance


    _pardotForm.pardotFormInstance;
    new _vueMin["default"]({
      el: ".drawer-".concat(id),
      store: _store["default"]
    }).$mount(".drawer-".concat(id), true);
  };

  if (drawers.length > 0) {
    drawers.forEach(function (item, index) {
      item.classList.add("drawer-".concat(index));
      drawerConstructor(index);
    });
  }
};

var _default = Drawer;
exports["default"] = _default;

},{"./event-bus":9,"./pardot-form":40,"./store":51,"vue/dist/vue.min.js":234}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var EventBus = new _vueMin["default"]();
var _default = EventBus;
exports["default"] = _default;

},{"vue/dist/vue.min.js":234}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _axios = _interopRequireDefault(require("axios"));

var _misc = require("lib/misc");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var fetcher = function fetcher(_ref) {
  var _ref$name = _ref.name,
      name = _ref$name === void 0 ? 'fetch' : _ref$name,
      props = _ref.props,
      dataProp = _ref.data,
      _created = _ref.created,
      watch = _ref.watch,
      methods = _ref.methods,
      options = _objectWithoutProperties(_ref, ["name", "props", "data", "created", "watch", "methods"]);

  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _conf$fetchOnCreated = conf.fetchOnCreated,
      fetchOnCreated = _conf$fetchOnCreated === void 0 ? true : _conf$fetchOnCreated,
      _conf$fetchOnUpdatePo = conf.fetchOnUpdatePostData,
      fetchOnUpdatePostData = _conf$fetchOnUpdatePo === void 0 ? true : _conf$fetchOnUpdatePo,
      _conf$fetchOnUpdatePa = conf.fetchOnUpdateParams,
      fetchOnUpdateParams = _conf$fetchOnUpdatePa === void 0 ? true : _conf$fetchOnUpdatePa,
      url = conf.url,
      _conf$method = conf.method,
      method = _conf$method === void 0 ? 'GET' : _conf$method,
      _conf$fetchOptions = conf.fetchOptions,
      _fetchOptions = _conf$fetchOptions === void 0 ? {} : _conf$fetchOptions,
      fetchTrigger = conf.fetchTrigger,
      _conf$debounceWait = conf.debounceWait,
      debounceWait = _conf$debounceWait === void 0 ? 500 : _conf$debounceWait;

  var _fetchOptions$data = _fetchOptions.data,
      postData = _fetchOptions$data === void 0 ? {} : _fetchOptions$data,
      _fetchOptions$params = _fetchOptions.params,
      params = _fetchOptions$params === void 0 ? {} : _fetchOptions$params,
      fetchOptions = _fetchOptions.fetchOptions;
  return _objectSpread({
    name: name,
    props: _objectSpread({
      urlProp: String,
      methodProp: String,
      fetchOnCreatedProp: {
        type: Boolean,
        "default": undefined
      },
      fetchOnUpdatePostDataProp: {
        type: Boolean,
        "default": undefined
      },
      fetchOnUpdateParamsProp: {
        type: Boolean,
        "default": undefined
      }
    }, props),
    data: function data() {
      var _dataProp = dataProp && dataProp.call(this);

      var data = _objectSpread({
        url: this.urlProp || url,
        method: this.methodProp || method,
        fetchOptions: fetchOptions,
        fetchOnCreated: fetchOnCreated,
        fetchOnUpdateParams: fetchOnUpdateParams,
        fetchOnUpdatePostData: fetchOnUpdatePostData,
        fetchTrigger: this.fetchTriggerProp || fetchTrigger,
        data: null,
        params: params,
        postData: postData
      }, _dataProp);

      if (this.fetchOnCreatedProp !== undefined) {
        data.fetchOnCreated = this.fetchOnCreatedProp;
      }

      if (this.fetchOnUpdateParamsProp !== undefined) {
        data.fetchOnUpdateParams = this.fetchOnUpdateParamsProp;
      }

      if (this.fetchOnUpdatePostDataProp !== undefined) {
        data.fetchOnUpdatePostData = this.fetchOnUpdatePostDataProp;
      }

      return data;
    },
    created: function created() {
      _created && _created.call(this);

      if (this.fetchOnCreated) {
        this.fetch();
      }
    },
    watch: _objectSpread({
      params: {
        handler: function handler() {
          if (this.fetchOnUpdateParams) {
            this.debounceFetch();
          }
        },
        deep: true
      },
      postData: {
        handler: function handler() {
          if (this.fetchOnUpdatePostData) {
            this.debounceFetch();
          }
        },
        deep: true
      }
    }, watch),
    methods: _objectSpread({
      debounceFetch: (0, _misc.debounce)(function () {
        this.fetch();
      }, debounceWait),
      fetch: function fetch(successFunc, options) {
        var _this = this;

        if (this.url || this.fetchOptions) {
          return (0, _axios["default"])(_objectSpread(_objectSpread({
            url: this.url,
            method: this.method,
            params: this.params,
            data: this.postData
          }, this.fetchOptions), options)).then(function (response) {
            if (!successFunc || successFunc(response)) {
              _this.data = response.data;
            }
          });
        }
      }
    }, methods)
  }, options);
};

var _default = fetcher;
exports["default"] = _default;

},{"axios":66,"lib/misc":28}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Pagination = exports.PageNum = exports.SelectedFiltersComponent = exports.Accordion = exports.Checkbox = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Checkbox = {
  props: ['data', 'label', 'value', 'type', 'category'],
  data: function data() {
    return {
      id: null,
      isChecked: false
    };
  },
  // template for product checkboxes only
  // static checkboxes are inline templates 
  template: "\n        <div class=\"checkbox\">\n            <label class=\"checkbox__label\">\n                <input type=\"checkbox\" class=\"checkbox__input\" ref=\"input\" v-on:change=\"updateFilters(data.class, $event, type)\" :value=\"value\" :checked=\"isChecked\" data-tag-trigger=\"click\" :data-tag-meta=\"taggingMeta\">\n                <span class=\"checkbox__checkmark\"></span>\n                <span class=\"checkbox__label-text\" v-html=\"label\"></span>\n            </label>\n        </div>\n    ",
  watch: {
    "data.filters": function dataFilters() {
      this.checkState();
    },
    "data.products": function dataProducts() {
      this.checkProductState();
    }
  },
  computed: {
    taggingMeta: function taggingMeta() {
      return JSON.stringify({
        "type": this.data.trackingType,
        "action": this.category || null,
        "label": decodeURIComponent(this.id)
      });
    }
  },
  methods: {
    updateFilters: function updateFilters(el, e, type) {
      _eventBus["default"].$emit('updateFilters', el, e, type);
    },
    checkState: function checkState() {
      var _this = this;

      var item = this.data.filters.find(function (el) {
        return el.value == _this.id;
      });
      this.isChecked = item ? true : false;
    },
    checkProductState: function checkProductState() {
      var _this2 = this;

      if (this.type === "product") {
        // console.log("is product");
        var item = this.data.filters.find(function (el) {
          // console.log("el", el.value);
          // console.log("id", this.id);
          return el.value == _this2.id;
        });
        this.isChecked = item ? true : false; // console.log(this.isChecked);
      }
    }
  },
  mounted: function mounted() {
    this.id = encodeURIComponent(this.$refs.input.value); // this.category = null;

    this.checkState(); // if has saved docs filter, get the label

    if (this.$refs.input.dataset.savedLabel) {
      this.data.savedDocsLabel = this.$refs.input.dataset.savedLabel;
    }
  }
};
exports.Checkbox = Checkbox;
var Accordion = {
  props: ['data'],
  components: {
    'checkbox-item': Checkbox
  },
  data: function data() {
    return {
      isOpen: false,
      //is the accordion open
      isTruncated: null,
      //is accordion content truncated 
      openText: null,
      closeText: null
    };
  },
  watch: {
    isTruncated: function isTruncated() {
      if (this.isTruncated == true) {
        this.openText = this.$refs.expandText.dataset.expandText;
        this.closeText = this.$refs.expandText.dataset.collapseText;
      }
    },
    "data.products": {
      deep: true,
      handler: function handler() {
        var _this3 = this;

        this.$nextTick(function () {
          _this3.isTruncated = _this3.data.products.length > 0 ? _this3.isTruncated : null;

          if (_this3.$el.querySelector('.checkbox:nth-of-type(6)')) {
            _this3.toggleTruncation(true);
          } else {
            _this3.isTruncated = null;
          }
        });
      }
    }
  },
  methods: {
    handleClick: function handleClick() {
      this.toggleAccordion();
    },
    toggleAccordion: function toggleAccordion() {
      var contentArea = this.$refs.outerContainer;
      var contentHeight = this.$refs.innerContainer.getBoundingClientRect().height;

      if (this.isOpen == true) {
        this.isOpen = false;
        requestAnimationFrame(function () {
          //set content area height to content height to prevent transitioning from auto
          contentArea.style.maxHeight = contentHeight + 'px'; // have the element transition to height: 0

          requestAnimationFrame(function () {
            contentArea.style.maxHeight = '0px';
          });
        });
        contentArea.addEventListener('transitionend', function () {
          contentArea.style.maxHeight = '0';
        });
      } else {
        this.isOpen = true;
        contentArea.style.maxHeight = contentHeight + "px";
        contentArea.addEventListener('transitionend', function () {
          contentArea.style.maxHeight = 'none';
        });
      }
    },
    toggleTruncation: function toggleTruncation(state) {
      var _this4 = this;

      // console.log("truncate this");
      if (state) {
        this.isTruncated = state;
      } else {
        this.isTruncated = this.isTruncated == null ? true : !this.isTruncated;
      }

      var truncHeight = 0;
      var container = this.$refs.innerContainer;

      var truncate = function truncate() {
        for (var i = 1; i < 6; i++) {
          var el = _this4.$el.querySelector(".checkbox:nth-of-type(".concat(i, ")"));

          var itemHeight = el.getBoundingClientRect().height;
          var elStyles = window.getComputedStyle(el);
          var itemMargin = parseFloat(elStyles.marginBottom);
          truncHeight = truncHeight + itemHeight + itemMargin;
        }

        truncHeight = truncHeight + 5; //little bit of wiggleroom
      };

      truncate();

      if (this.isTruncated == true) {
        container.style.maxHeight = truncHeight + "px";
      } else {
        container.style.maxHeight = 'none';
      }
    }
  },
  mounted: function mounted() {}
};
exports.Accordion = Accordion;
var SelectedFiltersComponent = {
  props: ['data'],
  data: function data() {
    return {};
  },
  computed: {
    className: function className() {
      return "".concat(this.data["class"], "__selected-filters");
    }
  },
  template: "\n        <div :class=\"className\" :data=\"data\">\n            <div class=\"filter-label\" v-for=\"filter in data.filters\" :key=\"filter.value\" :data-value=\"filter.value\" :data-type=\"filter.type\" v-on:click=\"removeFilter($event)\">\n                <div class=\"filter-label__wrapper\">\n                    <span class=\"filter-label__icon\"></span>\n                    <span class=\"filter-label__text\">{{filter.name}}</span>\n                </div>\n            </div>\n        </div>\n    ",
  methods: {
    removeFilter: function removeFilter(e) {
      var type = e.currentTarget.dataset.type;
      var value = e.currentTarget.dataset.value;

      _eventBus["default"].$emit('remove-filter', this.data["class"], value, type);
    }
  },
  mounted: function mounted() {}
};
exports.SelectedFiltersComponent = SelectedFiltersComponent;
var PageNum = {
  props: ['data', 'num'],
  data: function data() {
    return {
      page: null,
      isActive: false,
      isSpacer: false
    };
  },
  watch: {
    "data.currentPage": function dataCurrentPage() {
      this.isActive = this.data.currentPage == this.num ? true : false;
    }
  },
  template: "\n        <span :class=\"{active: isActive}\" v-on:click=\"changePageTo(num)\">{{num}}</span>\n    ",
  methods: {
    changePageTo: function changePageTo(num) {
      if (num !== "...") {
        _eventBus["default"].$emit('change-page-to', this.data["class"], num);

        _eventBus["default"].$emit('scroll-to-top', this.data["class"]);
      } else {
        return;
      }
    }
  },
  mounted: function mounted() {
    this.isActive = this.data.currentPage == this.num ? true : false;
  }
};
exports.PageNum = PageNum;
var Pagination = {
  props: ['data'],
  data: function data() {
    return {
      pageNums: []
    };
  },
  computed: {
    className: function className() {
      return "".concat(this.data["class"], "__pagination-nums");
    }
  },
  components: {
    'page-num': PageNum
  },
  watch: {
    "data.currentPage": function dataCurrentPage() {
      this.pageNums = [];
      this.initPages();

      if (this.data.currentPage > this.data.totalPages) {
        _eventBus["default"].$emit('change-page-to', this.data["class"], 1);
      }
    },
    "data.totalPages": function dataTotalPages() {
      this.pageNums = [];
      this.initPages();

      _eventBus["default"].$emit('change-page-to', this.data["class"], 1);
    }
  },
  template: "\n    <div :class=\"className\">\n        <page-num v-for=\"(num, index) in pageNums\" :num=\"num\" :data=\"data\" :key=\"index\"/>\n    </div>\n    ",
  methods: {
    initPages: function initPages() {
      if (this.data.totalPages <= 6) {
        // if less than 6 pages, list all pages
        for (var page = 1; page < this.data.totalPages + 1; page++) {
          this.pageNums.push(page);
        }
      } else {
        if (this.data.currentPage > this.data.totalPages - 6) {
          // on the last 6 pages, do not add ellipsis
          for (var _page = this.data.totalPages - 5; _page < this.data.currentPage + 6 && _page < this.data.totalPages + 1; _page++) {
            this.pageNums.push(_page); // console.log(page);
          }
        } else {
          // if not on the last 6 pages, add ellpisis
          for (var _page2 = this.data.currentPage; _page2 < this.data.currentPage + 3 && _page2 < this.data.totalPages - 1; _page2++) {
            this.pageNums.push(_page2);
          }

          this.pageNums.push("...");

          for (var _page3 = this.data.totalPages - 1; _page3 < this.data.totalPages + 1; _page3++) {
            this.pageNums.push(_page3);
          }
        }
      }
    }
  },
  mounted: function mounted() {
    this.initPages();
  }
};
exports.Pagination = Pagination;

},{"./event-bus":9,"vue/dist/vue.min.js":234}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var FooterUnits = function FooterUnits() {
  var footerUnits = document.querySelector('.footer__units-container');

  var FooterUnitsConstructor = function FooterUnitsConstructor() {
    _vueMin["default"].component('footer-unit-toggler', {
      data: function data() {
        return {
          selectedUnit: _store["default"].state.units,
          selectedUnitText: null
        };
      },
      computed: {
        units: function units() {
          return _store["default"].state.units;
        },
        taggingMeta: function taggingMeta() {
          return JSON.stringify({
            "type": "cta",
            "category": "Preference",
            "action": "Unit of measure",
            "label": this.selectedUnitText
          });
        }
      },
      watch: {
        units: function units() {
          this.selectedUnit = this.units;
          this.setTags();
        }
      },
      methods: {
        handleChange: function handleChange(e) {
          _store["default"].commit('setUnits', e.target.value);

          this.setWidth();
        },
        setTags: function setTags() {
          var select = this.$refs.select; // console.log(select);

          var selectedText = select.options[select.selectedIndex] ? select.options[select.selectedIndex].text : null;
          this.selectedUnitText = selectedText;
        },
        initTags: function initTags() {
          var text = this.$el.querySelector("option[value=\"".concat(_store["default"].state.units, "\"]")) ? this.$el.querySelector("option[value=\"".concat(_store["default"].state.units, "\"]")).innerText : null;
          this.selectedUnitText = text;
        },
        setWidth: function setWidth() {
          var select = this.$refs.select;
          var selectedText = select.options[select.selectedIndex].text;
          var width = "".concat(selectedText.length / 2 + 2, "em"); //assumes each chara is ~.5em width, +2em buffer

          select.style.maxWidth = width;
        }
      },
      mounted: function mounted() {
        var _this = this;

        this.$nextTick(function () {
          _this.initTags();

          _this.setWidth();
        });
        this.setTags();
      }
    });

    _vueMin["default"].component('footer-lang-toggler', {
      data: function data() {
        return {
          selectedLang: _store["default"].state.currentLang,
          selectedLangText: null,
          languages: [],
          store: _store["default"]
        };
      },
      computed: {
        taggingMeta: function taggingMeta() {
          return JSON.stringify({
            "type": "cta",
            "category": "Preference",
            "action": "Language",
            "label": this.selectedLangText
          });
        }
      },
      watch: {},
      methods: {
        handleChange: function handleChange(e) {
          var url = e.target.value;
          var el = this.$refs.select;
          var lang = el.options[el.selectedIndex].dataset.lang;

          if (lang) {
            document.cookie = "selectedLanguage=".concat(lang, "; path=/; max-age=31536000;");
          }

          this.setWidth();
          window.location.href = url;
        },
        setTags: function setTags() {
          var text = this.$el.querySelector("option[value=\"".concat(_store["default"].state.currentLang, "\"]")) ? this.$el.querySelector("option[value=\"".concat(_store["default"].state.currentLang, "\"]")).innerText : null;
          this.selectedLangText = text;
        },
        setWidth: function setWidth() {
          var select = this.$refs.select;
          var selectedText = select.options[select.selectedIndex].text;
          var width = "".concat(selectedText.length / 2 + 2, "em"); //assumes each chara is ~.5em width, +2em buffer

          select.style.maxWidth = width;
        }
      },
      mounted: function mounted() {
        var _this2 = this;

        this.setTags();
        this.$nextTick(function () {
          _this2.setWidth();
        });
      }
    });

    new _vueMin["default"]({
      el: ".footer__units-container"
    }).$mount(".footer__units-container", true);
  };

  if (footerUnits) {
    FooterUnitsConstructor();
  }
};

var _default = FooterUnits;
exports["default"] = _default;

},{"./store":51,"vue/dist/vue.min.js":234}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _modals = require("./modals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var FWMedia = function FWMedia() {
  var media = document.querySelectorAll('.fw-media--video');

  _vueMin["default"].use(_vueJsModal["default"]);

  var mediaConstructor = function mediaConstructor(id) {
    _vueMin["default"].component('fw-media-template', {
      data: function data() {
        return {
          videoUrl: '',
          videoName: null
        };
      },
      methods: {
        launchVideo: function launchVideo() {
          // console.log("clicked");
          this.$modal.show(_modals.videoModal.template(this.videoUrl, this.videoName), _modals.videoModal.name, _modals.videoModal.options);
        }
      },
      mounted: function mounted() {
        this.videoUrl = this.$el.querySelector('.fw-media__play-button').dataset.videoUrl;
        this.videoName = this.$refs.name ? this.$refs.name.innerHTML : null;
      }
    });

    new _vueMin["default"]({
      el: ".fw-media-video-".concat(id)
    }).$mount(".fw-media-video-".concat(id), true);
  };

  if (media.length > 0) {
    media.forEach(function (item, index) {
      item.classList.add("fw-media-video-".concat(index));
      mediaConstructor(index);
    });
  }
};

var _default = FWMedia;
exports["default"] = _default;

},{"./modals":30,"vue-js-modal":233,"vue/dist/vue.min.js":234}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _modals = require("./modals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/* 
Allows for inline text links to trigger vue modals with any content
*/
_vueMin["default"].use(_vueJsModal["default"]);

var genericModals = function genericModals() {
  var instance = new _vueMin["default"]({
    methods: {
      triggerModal: function triggerModal(content) {
        this.$modal.show(_modals.genericModal.template(content), _modals.genericModal.name, _modals.genericModal.options, _modals.genericModal.events);
      }
    }
  });
  var modalData = [];
  document.querySelectorAll('.gen-modal').forEach(function (item) {
    var data = {
      "hashtag": item.dataset.hashtag,
      "content": item.innerHTML
    };
    modalData.push(data);
  });

  if (modalData) {
    document.addEventListener('click', function (e) {
      if (e.target.getAttribute('href')) {
        var target = e.target.getAttribute('href');
        modalData.forEach(function (item) {
          if (target.includes("#".concat(item.hashtag))) {
            e.preventDefault();
            instance.triggerModal(item.content);
          } else {
            return;
          }
        });
      }
    });
  }
};

var _default = genericModals;
exports["default"] = _default;

},{"./modals":30,"vue-js-modal":233,"vue/dist/vue.min.js":234}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _specTable = require("./spec-table");

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _store = _interopRequireDefault(require("./store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var HeroProduct = function HeroProduct() {
  var heros = document.querySelectorAll('.hero-products');

  var heroProductConstructor = function heroProductConstructor(id) {
    _vueMin["default"].component('hero-product-template', {
      data: function data() {
        return {
          sizeSelect: null,
          viewConfig: null,
          gallery: null,
          galleryItems: [],
          selectedImage: 1,
          selectedItem: null //product name for passing to child spec table component

        };
      },
      watch: {
        selectedImage: function selectedImage() {}
      },
      methods: {
        init: function init() {
          var _this = this;

          // assign unique ID to each gallery item
          // if multiple images, set gallery array
          if (this.$el.querySelectorAll('.hero-products__gallery-image').length > 1) {
            this.gallery = true; // push images and their heights to array

            this.$el.querySelectorAll('.hero-products__gallery-image').forEach(function (item, index) {
              item.dataset.id = index + 1; // console.log(item.clientHeight);

              _this.galleryItems.push({
                src: item.src
              });
            });
          } else {
            // if only one image, set id to 1 (the default selected image id)
            this.$el.querySelector('.hero-products__gallery-image').dataset.id = 1;
          }

          this.selectedItem = this.$refs.title ? this.$refs.title.innerText : null;
        },
        handleImageSelect: function handleImageSelect(id) {
          this.selectedImage = id;
        }
      },
      mounted: function mounted() {
        var _this2 = this;

        this.init(); // recieve selected gallery item from child

        _eventBus["default"].$on('selectedImage', function (id) {
          _this2.handleImageSelect(id);
        });
      }
    });

    _vueMin["default"].component('hero-products-image', {
      props: ['selectedImage'],
      data: function data() {
        return {
          id: null,
          isActive: false
        };
      },
      watch: {
        selectedImage: function selectedImage() {
          this.isActive = this.selectedImage == this.id ? true : false;
        }
      },
      methods: {},
      mounted: function mounted() {
        var _this3 = this;

        this.$nextTick(function () {
          _this3.id = _this3.$el.dataset.id;
          _this3.isActive = _this3.selectedImage == _this3.id ? true : false;
        });
      }
    });

    _vueMin["default"].component('hero-products-thumbnails', {
      props: ['galleryItems', 'selectedImage'],
      data: function data() {
        return {};
      },
      template: "\n            <ul class=\"hero-products__thumbnail-container\">\n                <hero-products-thumbnail-item v-for=\"(item, index) in galleryItems\" :image=\"item.src\" :id=\"index + 1\" :selected-image=\"selectedImage\" :key=\"index\"/>\n            </ul>\n            ",
      methods: {},
      mounted: function mounted() {}
    });

    _vueMin["default"].component('hero-products-thumbnail-item', {
      props: ['image', 'id', 'selectedImage'],
      data: function data() {
        return {
          isActive: false
        };
      },
      computed: {
        imageUrl: function imageUrl() {
          return "url('".concat(this.image, "')");
        }
      },
      watch: {
        selectedImage: function selectedImage() {
          this.isActive = this.selectedImage == this.id ? true : false;
        }
      },
      template: "\n            <li class=\"hero-products__thumbnail-item\" v-bind:style=\"{backgroundImage: imageUrl}\" v-on:click=\"selectImage\" :class=\"{active: isActive}\"></li>\n            ",
      methods: {
        selectImage: function selectImage() {
          // emit id of clicked element to parent
          _eventBus["default"].$emit('selectedImage', this.id);
        }
      },
      mounted: function mounted() {
        this.isActive = this.selectedImage == this.id ? true : false;
      }
    });

    new _vueMin["default"]({
      el: ".hero-products-".concat(id),
      store: _store["default"]
    }).$mount(".hero-products-".concat(id), true);
  };

  (0, _specTable.specsTableTemplate)();

  if (heros.length > 0) {
    heros.forEach(function (item, index) {
      item.classList.add("hero-products-".concat(index));
      heroProductConstructor(index);
    });
  }
};

var _default = HeroProduct;
exports["default"] = _default;

},{"./event-bus":9,"./spec-table":48,"./store":51,"vue/dist/vue.min.js":234}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var homeHero = function homeHero() {
  var component = document.querySelector('.home-hero');

  var heroConstructor = function heroConstructor() {
    _vueMin["default"].component('home-hero', {
      data: function data() {
        return {
          selectedId: null
        };
      },
      mounted: function mounted() {
        var _this = this;

        this.$on('select-section', function (id) {
          _this.selectedId = id;
        });
      }
    });

    _vueMin["default"].component('hero-section', {
      props: ['selectedId'],
      data: function data() {
        return {
          isActive: false,
          isHovered: false,
          id: null
        };
      },
      watch: {
        selectedId: function selectedId() {
          this.isActive = this.selectedId == this.id ? true : false;
        },
        isHovered: function isHovered() {
          if (this.isHovered || this.isActive) {
            this.playVideo();
          } else {
            this.pauseVideo();
          }
        },
        isActive: function isActive() {
          if (this.isActive) {
            this.playVideo();
          } else {
            this.pauseVideo();
          }
        }
      },
      methods: {
        toggleExpand: function toggleExpand() {
          this.$parent.$emit('select-section', this.isActive ? null : this.id); // this.isActive = !this.isActive;
        },
        mouseover: function mouseover() {
          // console.log("moused over");
          this.isHovered = true;
        },
        mouseleave: function mouseleave() {
          // console.log("mouse leave");
          this.isHovered = false;
        },
        playVideo: function playVideo() {
          this.$refs.video.play();
        },
        pauseVideo: function pauseVideo() {
          this.$refs.video.pause();
        },
        init: function init() {
          this.id = Array.from(document.querySelectorAll('.home-hero__area')).indexOf(this.$el);
        }
      },
      mounted: function mounted() {
        this.init();
      }
    });

    new _vueMin["default"]({
      el: ".home-hero"
    }).$mount(".home-hero", true);
  };

  if (component) {
    heroConstructor();
  }
};

var _default = homeHero;
exports["default"] = _default;

},{"./store":51,"vue/dist/vue.min.js":234}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.contentTemplate = exports.tabLabel = exports.template = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _store = _interopRequireDefault(require("./store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var template = {
  data: function data() {
    return {
      activeTab: '',
      isMobile: null
    };
  },
  methods: {
    setActiveTab: function setActiveTab(e) {
      this.activeTab = e;
    },
    handleTab: function handleTab(e) {
      var tabTarget = e.currentTarget.dataset.target;

      if (tabTarget !== this.activeTab) {
        // console.log("derp");
        this.setActiveTab(tabTarget);
        this.$el.querySelector('.hiw__tab-item.active').classList.remove('active');
        this.$el.querySelector("[data-target=".concat(tabTarget, "]")).classList.add('active');
      }
    },
    setResponsive: function setResponsive(mql) {
      this.isMobile = mql.matches ? true : false;

      if (!this.isMobile) {
        // remove inline styles from accordions
        var accordionContainers = this.$el.querySelectorAll('.hiw__hiw-content-container');
        accordionContainers.forEach(function (item) {
          item.style = null;
        });
      }
    },
    // set the first tab to active
    initDesktop: function initDesktop() {
      var _this = this;

      // this is checking for a breakpoint *smaller* than
      // var isMobile in store.js
      var mql = window.matchMedia('(max-width: 650px)');
      this.isMobile = mql.matches ? true : false;
      mql.addEventListener('change', function () {
        _this.setResponsive(mql);
      });

      if (this.isMobile) {
        //under 650px
        var initial = this.$el.querySelector('[data-target]') ? this.$el.querySelector('[data-target]').dataset.target : null;
        this.activeTab = initial;
      } else {
        //over 650px
        // if desktop, check for desktop buttons and set initial tab
        var _initial = this.$el.querySelector('[data-target]') ? this.$el.querySelector('[data-target]').dataset.target : null;

        this.activeTab = _initial;

        if (this.$el.querySelector('[data-target]')) {
          this.$el.querySelector('[data-target]').classList.add('active');
        }
      }
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    this.initDesktop(); //set the first tab to active on init
    //listen for child click events on the labels and pass targets to parent

    _eventBus["default"].$on('handle-mobile', function (e) {
      _this2.setActiveTab(e);
    });

    _eventBus["default"].$on('handle-desktop', function (e) {
      _this2.setActiveTab(e);
    });
  }
};
exports.template = template;
var tabLabel = {
  props: ['activeTab', 'isMobile'],
  data: function data() {
    return {
      tabTarget: '',
      isActive: false,
      index: null,
      label: null
    };
  },
  computed: {
    taggingMeta: function taggingMeta() {
      return JSON.stringify({
        "type": "layer",
        "category": "Drawer",
        "action": "Open",
        "label": this.label,
        "no": this.index < 10 ? "0".concat(this.index) : "".concat(this.index)
      });
    }
  },
  watch: {
    activeTab: function activeTab() {
      this.isActive = this.activeTab == this.tabTarget ? true : false;
    }
  },
  methods: {
    handleTab: function handleTab(e) {
      _eventBus["default"].$emit('handle-desktop', this.tabTarget);
    },
    init: function init() {
      this.label = this.$el.innerText; // console.log()

      this.index = Array.prototype.slice.call(document.querySelectorAll('.hiw__tab-labels li')).indexOf(this.$el) + 1;
    }
  },
  mounted: function mounted() {
    this.tabTarget = this.$el.dataset.target;
    this.init();
  }
};
exports.tabLabel = tabLabel;
var contentTemplate = {
  props: ['activeTab', 'isMobile'],
  //active tab
  data: function data() {
    return {
      tabName: '',
      isActive: false,
      //is current tab the selected tab 'activeTab'
      isOpen: false,
      //is tab openm
      label: null,
      index: null
    };
  },
  computed: {
    taggingMeta: function taggingMeta() {
      return JSON.stringify({
        "type": "layer",
        "category": "Drawer",
        "action": "Open",
        "label": this.label,
        "no": this.index < 10 ? "0".concat(this.index) : "".concat(this.index)
      });
    }
  },
  watch: {
    activeTab: function activeTab(tab) {
      this.isActive = this.tabName == tab ? true : false;
    },
    isActive: function isActive() {
      if (!this.isActive) {
        this.isOpen = false; //set accodion to close when not the active item
        // close the accordion

        if (this.isMobile) {
          var contentArea = this.$el.querySelector('.hiw__hiw-content-container');
          var contentHeight = this.$el.querySelector('.hiw__hiw-content-inner').getBoundingClientRect().height;
          requestAnimationFrame(function () {
            //set content area height to content height to prevent transitioning from auto
            contentArea.style.maxHeight = contentHeight + 'px'; // have the element transition to height: 0

            requestAnimationFrame(function () {
              contentArea.style.maxHeight = '0px';
            });
          });
          contentArea.addEventListener('transitionend', function () {
            contentArea.style.maxHeight = '0';
          });
          this.scrollToTop();
        }
      } else {
        // if this is the active tab, set isOpen to true when isActive is true to pre open the tab on mobile
        this.isOpen = true;
      }
    }
  },
  methods: {
    handleMobile: function handleMobile(e) {
      var mobileTarget = e.currentTarget.parentNode.dataset.tabId;

      _eventBus["default"].$emit('handle-mobile', mobileTarget);

      if (this.isMobile) {
        // toggle the accordion
        this.handleAccordion(e);
      }
    },
    scrollToTop: function scrollToTop() {
      var elmOffset = this.$el.offsetTop;
      var scrollOffset = window.scrollY;

      if (elmOffset < scrollOffset) {
        var elmPos = this.$el.getBoundingClientRect().top + window.scrollY;
        setTimeout(function () {
          window.scrollTo({
            top: elmPos - 70,
            behavior: 'smooth'
          });
        }, 500);
      }
    },
    // toggle accordions
    handleAccordion: function handleAccordion(e) {
      var contentArea = this.$el.querySelector('.hiw__hiw-content-container');
      var contentHeight = this.$el.querySelector('.hiw__hiw-content-inner').getBoundingClientRect().height;

      if (this.isOpen == true) {
        this.isOpen = false;
        requestAnimationFrame(function () {
          //set content area height to content height to prevent transitioning from auto
          contentArea.style.maxHeight = contentHeight + 'px'; // have the element transition to height: 0

          requestAnimationFrame(function () {
            contentArea.style.maxHeight = '0px';
          });
        });
        contentArea.addEventListener('transitionend', function () {
          contentArea.style.maxHeight = '0';
        });
      } else {
        this.isOpen = true;
        contentArea.style.maxHeight = contentHeight + "px";
        contentArea.addEventListener('transitionend', function () {
          contentArea.style.maxHeight = 'none';
        });
      }
    },
    initMobile: function initMobile() {
      if (this.isMobile) {// console.log("is mobile");
      } else {
        // console.log("not mobile");
        // remove all inline styles for accordions on desktop
        var contentContainers = this.$el.querySelectorAll('.hiw__hiw-content-container');
        contentContainers.forEach(function (item) {
          item.style = '';
        });
      }
    },
    init: function init() {
      this.index = Array.prototype.slice.call(document.querySelectorAll('.hiw__area-content .hiw__hiw-container')).indexOf(this.$el) + 1;
      this.label = Array.prototype.slice.call(document.querySelectorAll('.hiw__tab-labels li'))[this.index - 1].innerText;
    }
  },
  mounted: function mounted() {
    var initialTab = this.$el.dataset.tabId;
    this.tabName = initialTab;
    this.initMobile();
    this.init();
  }
};
exports.contentTemplate = contentTemplate;

var HowItWorks = function HowItWorks() {
  var instances = document.querySelectorAll('.hiw__wrapper');

  var hiwConstructor = function hiwConstructor(id) {
    // main component wrapper
    _vueMin["default"].component('hiw-template', template); // desktop labels


    _vueMin["default"].component('hiw-tab-label', tabLabel); // mobile accordion containers & labels


    _vueMin["default"].component('hiw-content-template', contentTemplate);

    new _vueMin["default"]({
      el: ".hiw-".concat(id),
      store: _store["default"]
    }).$mount(".hiw-".concat(id), true);
  };

  if (instances.length > 0) {
    instances.forEach(function (item, index) {
      item.classList.add("hiw-".concat(index));
      hiwConstructor(index);
    });
  }
};

var _default = HowItWorks;
exports["default"] = _default;

},{"./event-bus":9,"./store":51,"vue/dist/vue.min.js":234}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var internalSearch = function internalSearch() {
  var searchBar = document.querySelectorAll('.hero-center__search');

  var internalSearchConstructor = function internalSearchConstructor(id) {
    _vueMin["default"].component('internal-search', {
      data: function data() {
        return {
          value: null,
          type: null
        };
      },
      watch: {
        "value": function value() {
          if (this.value == "") {
            console.log("no value");

            _eventBus["default"].$emit('internal-search', null, this.type);
          }
        }
      },
      methods: {
        handleSubmit: function handleSubmit(e, type) {
          var value = this.value; // console.log(value);
          // emit search query to documentation and software modules

          _eventBus["default"].$emit('internal-search', value, type);
        }
      },
      mounted: function mounted() {
        this.type = this.$refs.form.dataset.type;
      }
    });

    new _vueMin["default"]({
      el: ".internal-search-".concat(id)
    }).$mount(".internal-search-".concat(id), true);
  };

  if (searchBar.length > 0) {
    searchBar.forEach(function (item, index) {
      item.classList.add("internal-search-".concat(index));
      internalSearchConstructor(index);
    });
  }
};

var _default = internalSearch;
exports["default"] = _default;

},{"./event-bus":9,"vue/dist/vue.min.js":234}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _axios = _interopRequireDefault(require("axios"));

var _db = _interopRequireDefault(require("../../../db.json"));

var _filterComponents = require("./filter-components");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var safeString = function safeString(str) {
  return encodeURIComponent(str);
};

var Legal = function Legal() {
  var legal = document.querySelectorAll('.legal');

  var legalConstructor = function legalConstructor(id) {
    _vueMin["default"].component('legal-template', {
      data: function data() {
        return {
          data: {
            currentPage: 1,
            //current page #
            totalPages: null,
            //total returns pages
            totalResults: null,
            //total results
            shownResults: null,
            //total shown items
            filtersVisible: null,
            //are filters visible
            filterAreaVisible: true,
            filters: [],
            products: [],
            results: [],
            emailDocs: [],
            //for emailing
            savedDocs: [],
            //bookmarked items
            savedDocsLabel: null,
            //label for saved docs,
            savedDocsOnly: null,
            //is saved docs only checked?
            isMobile: null,
            nextActive: null,
            prevActive: null,
            // apiUrl: null, //for api call
            urlParams: null,
            //for deeplinking in-browser
            shareAll: false,
            "class": 'legal',
            trackingType: 'document' // store: store

          }
        };
      },
      components: {
        'filter-accordion-template': _filterComponents.Accordion,
        'selectedFilters': _filterComponents.SelectedFiltersComponent,
        'checkbox-item': _filterComponents.Checkbox,
        'pagination': _filterComponents.Pagination
      },
      computed: {
        computedIsMobile: function computedIsMobile() {
          return _store["default"].state.isMobile;
        },
        saved: function saved() {
          return _store["default"].state.favorites.legalDocumentId;
        },
        pageRange: function pageRange() {
          if (this.data.totalResults > 10) {
            if (this.data.currentPage == 1) {
              return "1-".concat(this.data.shownResults);
            } else if (this.data.currentPage == this.data.totalPages) {
              return "".concat(this.data.totalResults - this.data.shownResults + 1, "-").concat(this.data.totalResults);
            } else {
              return "".concat(this.data.shownResults * (this.data.currentPage - 1) + 1, "-").concat(this.data.shownResults * this.data.currentPage);
            }
          } else {
            return this.data.shownResults;
          }
        },
        page: function page() {
          return this.data.currentPage;
        }
      },
      watch: {
        saved: function saved() {
          this.data.savedDocs = this.saved; // remove saved only filter if no saved items

          if (this.saved.length == 0) {
            var index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf('savedDocuments');

            if (index > -1) {
              this.data.filters.splice(index, 1);
            }
          }
        },
        computedIsMobile: function computedIsMobile() {
          this.data.isMobile = this.computedIsMobile;
          this.data.filtersVisible = !this.computedIsMobile ? true : this.data.filtersVisible;
        },
        "data.filters": function dataFilters() {
          this.getResults(); // handle api call
          // this.updateHistory(); // handle history record
          // this.data.currentPage = 1; //reset page to 1

          this.data.emailDocs = []; // check for if brand is selected

          var brands = this.data.filters.filter(function (el) {
            return el.type == "brand";
          }).map(function (el) {
            return el.value;
          }); // set savedDocsOnly value

          var savedOnly = this.data.filters.find(function (item) {
            return item.type == "savedDocuments";
          });
          this.data.savedDocsOnly = savedOnly ? savedOnly.value : null;
        },
        page: function page() {
          if (this.data.currentPage == 1) {
            this.data.nextActive = true;
            this.data.prevActive = false;
          } else if (this.data.currentPage == this.data.totalPages) {
            this.data.nextActive = false;
            this.data.prevActive = true;
          } else {
            this.data.nextActive = true;
            this.data.prevActive = true;
          } // this.getResults();
          // this.updateHistory();

        },
        "data.totalResults": function dataTotalResults() {
          this.initPages();
        }
      },
      methods: {
        toggleFilters: function toggleFilters() {
          // console.log("clicked");
          if (this.data.isMobile) {
            // console.log("is mobile");
            this.data.filtersVisible = !this.data.filtersVisible;
          }
        },
        updateFilters: function updateFilters(el, e, type) {
          if (el !== this.data["class"]) {
            return;
          }

          var type = type;
          var value = safeString(e.currentTarget.value);
          var label = e.currentTarget.parentNode.innerText;
          var checked = e.currentTarget.checked;
          this.data.currentPage = 1; // console.log("type", type)
          // console.log(e);
          // console.log("value", safeString(e.target.value));
          // console.log("checked",e.target.checked);

          if (checked) {
            if (type !== "savedDocuments") {
              this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                "value": value,
                "type": type,
                "name": label
              }]);
            } else {
              this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                "value": checked,
                "type": type,
                "name": label
              }]);
            }
          } else {
            var index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf(value); // console.log("INDEX", index);

            this.data.filters.splice(index, 1);
          }
        },
        // removes specific filter
        removeFilter: function removeFilter(el, value, type) {
          if (el !== this.data["class"]) {
            return;
          }

          var index = this.data.filters.map(function (e) {
            return e.value;
          }).indexOf(value);
          this.data.filters.splice(index, 1);
        },
        // clears filters
        removeAll: function removeAll() {
          this.data.filters = [];
          this.data.currentPage = 1; //reset page to 1
        },
        getUrl: function getUrl() {
          var _this = this;

          var savedParams = this.data.savedDocs.toString();
          var certTypeParams = this.data.filters.filter(function (item) {
            return item.type == "certType";
          }).map(function (item) {
            return item.value;
          }).toString();
          var langParams = this.data.filters.filter(function (item) {
            return item.type == "lang";
          }).map(function (item) {
            return item.value;
          }).toString();
          var docTypeParams = this.data.filters.filter(function (item) {
            return item.type == "docType";
          }).map(function (item) {
            return item.value;
          }).toString();
          var regionParams = this.data.filters.filter(function (item) {
            return item.type == "region";
          }).map(function (item) {
            return item.value;
          }).toString();

          var savedDocumentsTrueParams = function savedDocumentsTrueParams() {
            var savedOnly = _this.data.filters.find(function (item) {
              return item.type == "savedDocuments";
            });

            if (savedOnly) {
              return savedOnly.value;
            } else {
              return false;
            }
          };

          var pageParams = this.data.currentPage;
          this.data.urlParams = "?".concat(certTypeParams !== "" ? "&certificationType=" + certTypeParams : "").concat(langParams !== "" ? "&lang=" + langParams : "").concat(regionParams !== "" ? "&region=" + regionParams : "").concat(docTypeParams !== "" ? "&docType=" + docTypeParams : "", "&savedDocuments=").concat(savedDocumentsTrueParams(), "&page=").concat(pageParams);
        },
        getResults: function getResults(query) {
          var _this2 = this;

          // let apiUrl = "api/documents?";
          this.data.currentPage = query ? 1 : this.data.currentPage;
          this.getUrl();
          var baseUrl = window.legalAPIUrl;
          var apiUrl = "".concat(baseUrl).concat(baseUrl.indexOf('?') > -1 ? '' : '?'); // let apiUrl = "http://localhost:3003/legal"; //from json-server

          var self = this;

          var savedDocumentsTrueParams = function savedDocumentsTrueParams() {
            var savedOnly = _this2.data.filters.find(function (item) {
              return item.type == "savedDocuments";
            });

            if (savedOnly) {
              return true;
            } else {
              return false;
            }
          };

          var certType = [];
          var lang = [];
          var region = [];
          var docType = [];
          this.data.filters.map(function (item) {
            switch (item.type) {
              case "certType":
                certType.push(item.value);
                break;

              case "lang":
                lang.push(item.value);
                break;

              case "region":
                region.push(item.value);
                break;

              case "docType":
                docType.push(item.value);
                break;

              default:
                return;
            }
          });
          var certTypeStr = decodeURIComponent(certType.join('|'));
          var langStr = decodeURIComponent(lang.join('|'));
          var regionStr = decodeURIComponent(region.join('|'));
          var docTypeStr = decodeURIComponent(docType.join('|'));
          var axiosParams = {
            q: query ? query : null,
            saved: this.data.savedDocs.join('|') == "" ? null : this.data.savedDocs.join('|').charAt(0) == "," ? this.data.savedDocs.join('|').slice(1) : this.data.savedDocs.join('|'),
            //@TODO make this less insane. Send NULL if empty string. Remove leading comma if present.
            certificationType: certTypeStr == "" ? null : certTypeStr,
            language: langStr == "" ? null : langStr,
            region: regionStr == "" ? null : regionStr,
            docType: docTypeStr == "" ? null : docTypeStr,
            savedDocuments: savedDocumentsTrueParams(),
            page: this.data.currentPage
          }; // console.log(axiosParams);

          _axios["default"].get(apiUrl, {
            params: _objectSpread({}, axiosParams)
          }).then(function (response) {
            // console.log(response);
            self.data.results = response.data.results;
            self.data.totalResults = response.data.totalResults;
            self.data.shownResults = response.data.results.length;
            console.log(response.data);
          })["catch"](function (error) {
            console.log(error);
          });
        },
        changePage: function changePage(dir) {
          if (dir == "prev" && this.data.currentPage !== 1) {
            this.data.currentPage--;
          } else if (dir == "next" && this.data.currentPage !== this.data.totalPages) {
            this.data.currentPage++;
          } else {
            return;
          }

          _eventBus["default"].$emit('scroll-to-top', this.data["class"]);

          this.getResults();
        },
        updateEmailDocs: function updateEmailDocs(data) {
          var item = this.data.emailDocs.find(function (item) {
            return item.id == data.id;
          });

          if (!item) {
            this.data.emailDocs = [].concat(_toConsumableArray(this.data.emailDocs), [data]);
          } else {
            this.data.emailDocs.splice(this.data.emailDocs.indexOf(item), 1);
          }
        },
        //update history record when filters change
        updateHistory: function updateHistory() {
          var url = "".concat(window.location.pathname).concat(this.data.urlParams);
          history.pushState("", "", url);
        },
        // handle deep linking on history change
        deeplink: function deeplink() {
          var _this3 = this;

          var params = window.location.search.substr(1).split("&").filter(function (item) {
            return item != "";
          }); // console.log(params);
          // this.data.filters = []; //clear filters array first

          var initFilters = [];
          var page;
          params.forEach(function (param) {
            var type = param.slice(0, param.indexOf('='));
            var content = param.slice(param.indexOf('=') + 1); // console.log("TYPE",type);
            // console.log("CONTENT", content);

            var entry = {};

            if (type == "page") {
              // console.log("PAGE", parseInt(content));
              // this.data.currentPage = parseInt(content);
              page = parseInt(content);
            } else if (type == "savedDocuments") {
              if (content == "false" || content == false) {
                return;
              } else {
                entry = {
                  "type": type,
                  "value": true,
                  "name": _this3.data.savedDocsLabel
                };
                initFilters = [].concat(_toConsumableArray(initFilters), [entry]);
              }
            } else if (content.indexOf(',') > -1) {
              var contentArray = content.split(',');
              contentArray.forEach(function (item) {
                entry = {
                  "type": type,
                  "value": item,
                  "name": decodeURIComponent(item)
                };
                initFilters = [].concat(_toConsumableArray(initFilters), [entry]);
              });
            } else {
              entry = {
                "type": type,
                "value": content,
                "name": decodeURIComponent(content)
              };
              initFilters = [].concat(_toConsumableArray(initFilters), [entry]);
            }

            _this3.data.filters = initFilters; // console.log(this.initFilters);
          });
          this.data.currentPage = page;
        },
        scrollToTop: function scrollToTop(el) {
          if (el !== this.data["class"]) {
            return;
          }

          var top = this.$el.querySelector('.legal__area-cards').getBoundingClientRect().top + window.scrollY - 100; // console.log(top);

          setTimeout(function () {
            window.scrollTo({
              top: top,
              behavior: 'smooth'
            });
          }, 500);
        },
        initPages: function initPages() {
          // based on total result count, divide by 10 to get total pages needed
          // math ceil to round up
          // set active for prev/next based on current page
          this.data.totalPages = Math.ceil(this.data.totalResults / 10);
          this.data.prevActive = this.data.currentPage !== 1 ? true : false;
          this.data.nextActive = this.data.currentPage !== this.data.totalPages ? true : false;
        },
        init: function init() {
          var _this4 = this;

          this.data.isMobile = _store["default"].state.isMobile;
          this.data.savedDocs = _store["default"].state.favorites.legalDocumentId[0] == "" ? _store["default"].state.favorites.legalDocumentId.slice(1) : _store["default"].state.favorites.legalDocumentId;
          this.data.filtersVisible = this.data.isMobile ? false : true; //init show/hide filters if/is mobile
          // listen for filter updates in children

          _eventBus["default"].$on('updateFilters', function (el, e, type) {
            _this4.updateFilters(el, e, type);
          });

          _eventBus["default"].$on('remove-filter', function (el, value, type) {
            _this4.removeFilter(el, value, type);
          });

          _eventBus["default"].$on('change-page-to', function (el, num) {
            if (el !== _this4.data["class"]) {
              return;
            }

            ;
            _this4.data.currentPage = num;

            _this4.getResults();
          });

          _eventBus["default"].$on('email-docs', function (data) {
            _this4.updateEmailDocs(data);
          });

          _eventBus["default"].$on('internal-search', function (value, type) {
            if (type == "documentation") {
              _this4.getResults(value);
            }
          });

          _eventBus["default"].$on('scroll-to-top', function (el) {
            _this4.scrollToTop(el);
          }); // init results


          this.data.results = window.initialLegalApiResults.results;
          this.data.totalResults = window.initialLegalApiResults.totalResults;
          this.data.shownResults = window.initialLegalApiResults.results.length; // this.data.results = fpodb.legal.results;
          // this.data.totalResults = fpodb.legal.totalResults;
          // this.data.shownResults = fpodb.legal.results.length;
          // hide filters if less then 10 initial results

          this.data.filterAreaVisible = parseInt(this.data.totalResults) <= 10 ? false : true; // enable "share all" if 5 of less results

          this.data.shareAll = parseInt(this.data.totalResults) <= 5 ? true : false; // window.onpopstate = () => {
          //     this.deeplink();
          // }
        }
      },
      mounted: function mounted() {
        var _this5 = this;

        this.init();
        this.initPages(); // for deeplinking

        if (window.location.search) {
          this.$nextTick(function () {
            _this5.deeplink();
          });
        }
      }
    }); // results list


    _vueMin["default"].component('legal-results-list', {
      props: ['data'],
      data: function data() {
        return {
          type: "product"
        };
      },
      template: "\n            <div class=\"legal__cards-content\" :data=\"data\">\n                <legal-results-item v-for=\"(result, index) in data.results\" :content=\"result\" :isSelected=\"isSelected(result)\" :key=\"result.id\" :data=\"data\"/>\n            </div>\n            ",
      methods: {
        isSelected: function isSelected(result) {
          return this.data.emailDocs.find(function (i) {
            return i.id == result.id;
          }) !== undefined;
        }
      },
      mounted: function mounted() {}
    }); // single results item


    _vueMin["default"].component('legal-results-item', {
      props: ['data', 'content', 'isSelected'],
      data: function data() {
        return {
          isChecked: this.isSelected,
          isBookmarked: false,
          id: null,
          seeAll: null,
          //is "see all" feature enabled,
          seeAllOpen: null,
          seeAllLabel: null,
          //label
          moreContent: null
        };
      },
      computed: {
        saved: function saved() {
          return _store["default"].state.favorites.legalDocumentId;
        },
        encodedUrl: function encodedUrl() {
          return encodeURIComponent(this.content.url);
        },
        newTabLink: function newTabLink() {
          return this.content.url.replace('download=true', 'download=false');
        },
        tagMetaBody: function tagMetaBody() {
          return JSON.stringify({
            "type": "legalDocument",
            "category": this.content.eyebrow,
            "label": this.content.name,
            "language": this.content.language
          });
        }
      },
      watch: {
        saved: function saved() {
          this.isBookmarked = this.saved.includes(this.id) ? true : false;
        },
        "data.emailDocs": function dataEmailDocs() {
          if (this.data.emailDocs.length === 0) {
            this.isChecked = false;
          }
        },
        "content": function content() {
          var _this6 = this;

          // update id when content changes
          this.$nextTick(function () {
            // console.log(this.$refs.bookmark.dataset.documentId);
            _this6.id = _this6.$refs.bookmark.dataset.legalDocumentId;
            _this6.isBookmarked = _this6.saved.includes("".concat(_this6.id)) ? true : false;
          });
        },
        "seeAll": function seeAll() {
          if (this.seeAll) {
            this.seeAllLabel = this.seeAllOpen ? window.seeLessLabel : window.seeAllLabel;
          }
        },
        "seeAllOpen": function seeAllOpen() {
          if (this.seeAll) {
            this.seeAllLabel = this.seeAllOpen ? window.seeLessLabel : window.seeAllLabel;
          }
        }
      },
      template: "\n            <div class=\"doc-card doc-card--checkbox\" :data=\"data\" :class=\"{'hide-bookmark': (data.savedDocsOnly === true) && (isBookmarked === false)}\" data-tag-trigger=\"click\" :data-tag-meta='tagMetaBody'>\n                <div class=\"doc-card__wrapper\">\n                    <div class=\"doc-card__row\">\n                        <div class=\"doc-card__area doc-card__area-checkbox\">\n                        <div class=\"checkbox\">\n                                <label class=\"checkbox__label\">\n                                    <input type=\"checkbox\" class=\"checkbox__input\" :value=\"content.id\" v-on:change=\"emailDoc\" v-model=\"isChecked\" :checked=\"isChecked\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"legalDocument\", \"action\": \"Select\"}'>\n                                    <span class=\"checkbox__checkmark\"></span>\n                                </label>\n                            </div>\n                        </div>\n                        \n                        <div class=\"doc-card__area doc-card__area-info\">\n                            <div class=\"doc-card__area doc-card__area-left\">\n                                <span class=\"doc-card__eyebrow\">\n                                    {{content.eyebrow}}\n                                </span>\n                                <a :href=\"newTabLink\" class=\"doc-card__title\" target=\"_blank\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"legalDocument\", \"action\": \"Preview\"}'>\n                                    {{content.name}}\n                                </a>\n                                <span class=\"doc-card__subtitle\">\n                                    <span class=\"doc-card__subtitle-content\" ref=\"seeAllContent\">{{content.details}}</span> <span class=\"doc-card__subtitle-more\" v-if=\"seeAll && seeAllOpen\">{{moreContent}}</span> <a href=\"#\" v-on:click.prevent=\"toggleSeeAll\" v-if=\"seeAll\">{{seeAllLabel}}</a> | {{content.language}}\n                                </span> \n                            </div>\n                            <div class=\"doc-card__area doc-card__area-right\">\n                                <a class=\"doc-card__icon doc-card__icon-download\" :href=\"content.url\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"legalDocument\", \"action\": \"Download\"}'></a>\n                                <a class=\"doc-card__icon doc-card__icon-email\" :href=\"'mailto:?subject=Badger%20Meter%20Document%20Links&body=' + content.name + ': ' + this.encodedUrl\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"legalDocument\", \"action\": \"Email\"}'></a>\n                                <a class=\"doc-card__icon doc-card__icon-bookmark\" :data-legal-document-id=\"content.id\" ref=\"bookmark\" v-on:click=\"handleBookmark\" :class=\"{active: isBookmarked}\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"legalDocument\", \"action\": \"Favorite\"}'></a>\n                            </div>\n                        </div>\n                        \n                    </div>\n                </div>\n            </div>\n            ",
      methods: {
        emailDoc: function emailDoc() {
          _eventBus["default"].$emit('email-docs', {
            "name": this.content.name,
            "url": this.content.url,
            "id": this.content.id
          });
        },
        handleBookmark: function handleBookmark() {
          _store["default"].commit('updateFavorites', {
            id: this.id,
            type: "legalDocumentId",
            action: this.isBookmarked ? "remove" : "add"
          });

          _store["default"].dispatch('checkFavorites');
        },
        toggleSeeAll: function toggleSeeAll() {
          this.seeAllOpen = !this.seeAllOpen;
        },
        initSeeAll: function initSeeAll() {
          if (this.$refs.seeAllContent) {
            var details = this.$refs.seeAllContent.innerHTML.split(',');
            this.seeAll = details.length > 3 ? true : false;
            var truncatedDetails = details.slice(0, 3).join();
            var moreDetails = details.slice(3).join();
            this.moreContent = moreDetails;
            this.$refs.seeAllContent.innerHTML = "".concat(truncatedDetails).concat(moreDetails == "" ? '' : ',');
          }
        }
      },
      mounted: function mounted() {
        this.id = this.$refs.bookmark.dataset.legalDocumentId;
        this.isBookmarked = this.saved.includes("".concat(this.id)) ? true : false; // console.log("saved",this.saved);

        this.initSeeAll();
      }
    });

    _vueMin["default"].component('email-docs', {
      props: ['data'],
      data: function data() {
        return {
          mailto: null // mailtoAll: null

        };
      },
      watch: {
        "data.emailDocs": function dataEmailDocs() {
          var mailto = "mailto:?subject=Badger%20Meter%20Document%20Links&body=";
          this.data.emailDocs.forEach(function (item) {
            mailto = "".concat(mailto).concat(encodeURIComponent(item.name), ": ").concat(encodeURIComponent(item.url), "%0D%0A");
          });
          this.mailto = mailto;
        }
      },
      methods: {// shareAll() {
        //     let mailto = "mailto:?subject=Badger%20Meter%20Document%20Links&body=";
        //     this.data.results.forEach(item => {
        //         mailto = `${mailto}${item.name}: ${item.url}%0D%0A`;
        //     });
        //     this.mailtoAll = mailto;
        // }
      },
      mounted: function mounted() {// if (parseInt(this.data.totalResults) <= 5) {
        //     this.shareAll();
        // }
      }
    });

    new _vueMin["default"]({
      el: ".legal-".concat(id),
      store: _store["default"]
    }).$mount(".legal-".concat(id), true);
  };

  if (legal.length > 0) {
    legal.forEach(function (item, index) {
      item.classList.add("legal-".concat(index));
      legalConstructor(index);
    });
  }

  window.seeLessLabel = "see less";
  window.seeAllLabel = "see more";
};

var _default = Legal;
exports["default"] = _default;

},{"../../../db.json":64,"./event-bus":9,"./filter-components":11,"./store":51,"axios":66,"vue/dist/vue.min.js":234}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _axios = _interopRequireDefault(require("axios"));

var _db = _interopRequireDefault(require("../../../db.json"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _modalTrigger = require("./modal-trigger");

var _filterComponents = require("./filter-components");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

_vueMin["default"].use(_vueJsModal["default"]);

var safeString = function safeString(str) {
  return encodeURIComponent(str);
};

var LitOrder = function LitOrder() {
  var litOrder = document.querySelectorAll('.lit-order');

  var litOrderConstructor = function litOrderConstructor(id) {
    _vueMin["default"].component('lit-order-template', {
      data: function data() {
        return {
          data: {
            currentPage: 1,
            //current page #
            totalPages: null,
            //total returns pages
            totalResults: null,
            //total results
            shownResults: null,
            //total shown items
            filtersVisible: null,
            //are filters visible
            filterAreaVisible: true,
            filters: [],
            products: [],
            results: [],
            emailDocs: [],
            //for emailing
            savedDocs: [],
            //bookmarked items
            savedDocsLabel: null,
            //label for saved docs,
            savedDocsOnly: null,
            //is saved docs only checked?
            isMobile: null,
            nextActive: null,
            prevActive: null,
            // apiUrl: null, //for api call
            urlParams: null,
            //for deeplinking in-browser
            shareAll: false,
            query: null,
            //search query,
            store: _store["default"],
            selectedItems: null,
            cartContents: null,
            isSubmitted: false,
            modalTarget: null,
            //modal hash for lit order form
            "class": 'lit-order',
            trackingType: 'document'
          }
        };
      },
      components: {
        'filter-accordion-template': _filterComponents.Accordion,
        'selectedFilters': _filterComponents.SelectedFiltersComponent,
        'checkbox-item': _filterComponents.Checkbox,
        'pagination': _filterComponents.Pagination
      },
      computed: {
        computedIsMobile: function computedIsMobile() {
          return _store["default"].state.isMobile;
        },
        saved: function saved() {
          return _store["default"].state.favorites.documentId;
        },
        pageRange: function pageRange() {
          if (this.data.totalResults > 10) {
            if (this.data.currentPage == 1) {
              return "1-".concat(this.data.shownResults);
            } else if (this.data.currentPage == this.data.totalPages) {
              return "".concat(this.data.totalResults - this.data.shownResults + 1, "-").concat(this.data.totalResults);
            } else {
              return "".concat(this.data.shownResults * (this.data.currentPage - 1) + 1, "-").concat(this.data.shownResults * this.data.currentPage);
            }
          } else {
            return this.data.shownResults;
          }
        },
        page: function page() {
          return this.data.currentPage;
        },
        lang: function lang() {
          return _store["default"].state.currentLang;
        }
      },
      watch: {
        saved: function saved() {
          this.data.savedDocs = this.saved; // remove saved only filter if no saved items

          if (this.saved.length == 0) {
            var index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf('savedDocuments');

            if (index > -1) {
              this.data.filters.splice(index, 1);
            }
          }
        },
        computedIsMobile: function computedIsMobile() {
          this.data.isMobile = this.computedIsMobile;
          this.data.filtersVisible = !this.computedIsMobile ? true : this.data.filtersVisible;
        },
        "data.filters": function dataFilters() {
          var _this = this;

          this.getResults(); // handle api call
          // this.updateHistory(); // handle history record
          // this.data.currentPage = 1; //reset page to 1

          this.data.emailDocs = []; // check for if brand is selected

          var brands = this.data.filters.filter(function (el) {
            return el.type == "brand";
          }).map(function (el) {
            return el.value;
          });

          if (brands.length > 0) {
            this.populateProducts(brands);
          } else {
            //if not brand selected, empty the products array
            this.data.products = []; // remove selected product filters

            this.data.filters.filter(function (el) {
              return el.type == "product";
            }).forEach(function (item) {
              _this.removeFilter(_this.data["class"], item.value);
            });
          } // set savedDocsOnly value


          var savedOnly = this.data.filters.find(function (item) {
            return item.type == "savedDocuments";
          });
          this.data.savedDocsOnly = savedOnly ? savedOnly.value : null;
        },
        page: function page() {
          if (this.data.currentPage == 1) {
            this.data.nextActive = true;
            this.data.prevActive = false;
          } else if (this.data.currentPage == this.data.totalPages) {
            this.data.nextActive = false;
            this.data.prevActive = true;
          } else {
            this.data.nextActive = true;
            this.data.prevActive = true;
          } // this.getResults();
          // this.updateHistory();

        },
        "data.totalResults": function dataTotalResults() {
          this.initPages();
        },
        "data.emailDocs": function dataEmailDocs() {
          _store["default"].commit('updateLitOrderCart', this.data.emailDocs); //store cart in store
          // construct data string for passing selected docs to pardot


          var itemsStr;
          this.data.emailDocs.forEach(function (item) {
            var str = "DOCUMENT ID: ".concat(item.partNumber, " | DOCUMENT NAME: ").concat(item.name, " | QUANTITY: ").concat(item.qty, " | PRE-PUNCHED: ").concat(item.prePunched == true ? "yes" : "no");

            if (itemsStr) {
              itemsStr = str ? "".concat(itemsStr, " || ").concat(str) : "".concat(itemsStr);
            } else {
              itemsStr = str ? str : null;
            }
          });
          this.data.selectedItems = itemsStr; // get cart 
          // this.$nextTick(() => {
          //     // console.log(this.$refs.cart.$el);
          //     // console.log(this.$refs.cart.$el.outerHTML);
          //     let cart = this.$refs.cart.$el.outerHTML;
          //     this.data.cartContents = cart;
          // })
        }
      },
      methods: {
        openCart: function openCart(e) {
          // prevent opening cart if its empty
          if (this.data.emailDocs.length == 0) {
            e.stopPropagation();
          }
        },
        toggleFilters: function toggleFilters() {
          // console.log("clicked");
          if (this.data.isMobile) {
            // console.log("is mobile");
            this.data.filtersVisible = !this.data.filtersVisible;
          }
        },
        updateFilters: function updateFilters(el, e, type) {
          if (el !== this.data["class"]) {
            return;
          }

          var type = type;
          var value = safeString(e.currentTarget.value);
          var label = e.currentTarget.parentNode.innerText;
          var checked = e.currentTarget.checked;
          this.data.currentPage = 1; // console.log("type", type)
          // console.log(e);
          // console.log("value", safeString(e.target.value));
          // console.log("checked",e.target.checked);

          if (checked) {
            if (type !== "savedDocuments") {
              this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                "value": value,
                "type": type,
                "name": label
              }]);
            } else {
              this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                "value": checked,
                "type": type,
                "name": label
              }]);
            }
          } else {
            var index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf(value); // console.log("INDEX", index);

            this.data.filters.splice(index, 1);
          }
        },
        // removes specific filter
        removeFilter: function removeFilter(el, value, type) {
          if (el !== this.data["class"]) {
            return;
          }

          var index = this.data.filters.map(function (e) {
            return e.value;
          }).indexOf(value);
          this.data.filters.splice(index, 1);
        },
        // clears filters
        removeAll: function removeAll() {
          this.data.filters = [];
          this.data.currentPage = 1; //reset page to 1
        },
        populateProducts: function populateProducts(brands) {
          // need to concat options from all selected brands and remove options when brands are unselected 
          var brandStr = decodeURIComponent(brands.join('|')); // // console.log(brandStr);

          var apiUrl = "/api/GetDocumentProductsByBrand"; // let apiUrl = "http://localhost:3003/productsByBrand"; //from json-server

          var self = this;

          _axios["default"].get(apiUrl, {
            params: {
              brand: brandStr,
              lang: this.lang
            }
          }).then(function (response) {
            // console.log(response);
            self.data.products = response.data.results;
          })["catch"](function (error) {
            console.log(error);
          });
        },
        getResults: function getResults(query) {
          var _this2 = this;

          // let apiUrl = "api/documents?";
          // console.log("QUERY", query);
          this.data.query = query === null ? null : query ? query : this.data.query;
          this.data.currentPage = query ? 1 : this.data.currentPage; // this.getUrl();

          var baseUrl = window.documentAPIUrl;
          var apiUrl = "".concat(baseUrl).concat(baseUrl.indexOf('?') > -1 ? '' : '?'); // let apiUrl = "http://localhost:3003/documentation"; //from json-server
          // let apiUrlTest = "http://localhost:3003/documentationTest"; //from json-server

          var self = this;

          var savedDocumentsTrueParams = function savedDocumentsTrueParams() {
            var savedOnly = _this2.data.filters.find(function (item) {
              return item.type == "savedDocuments";
            });

            if (savedOnly) {
              return true;
            } else {
              return false;
            }
          };

          var product = [];
          var lang = [];
          var brand = [];
          var docType = [];
          this.data.filters.map(function (item) {
            switch (item.type) {
              case "product":
                product.push(item.value);
                break;

              case "lang":
                lang.push(item.value);
                break;

              case "brand":
                brand.push(item.value);
                break;

              case "docType":
                docType.push(item.value);
                break;

              default:
                return;
            }
          });
          var productStr = decodeURIComponent(product.join('|'));
          var langStr = decodeURIComponent(lang.join('|'));
          var brandStr = decodeURIComponent(brand.join('|'));
          var docTypeStr = decodeURIComponent(docType.join('|'));
          var axiosParams = {
            q: this.data.query ? this.data.query : null,
            saved: this.data.savedDocs.join('|') == "" ? null : this.data.savedDocs.join('|').charAt(0) == "," ? this.data.savedDocs.join('|').slice(1) : this.data.savedDocs.join('|'),
            //@TODO make this less insane. Send NULL if empty string. Remove leading comma if present.
            product: productStr == "" ? null : productStr,
            language: langStr == "" ? null : langStr,
            brand: brandStr == "" ? null : brandStr,
            docType: docTypeStr == "" ? null : docTypeStr,
            savedDocuments: savedDocumentsTrueParams(),
            page: this.data.currentPage
          }; // console.log(axiosParams);

          _axios["default"].get(apiUrl, {
            params: _objectSpread({}, axiosParams)
          }).then(function (response) {
            // console.log(response);
            self.data.results = response.data.results;
            self.data.totalResults = response.data.totalResults;
            self.data.shownResults = response.data.results.length;
            console.log(response.data);
          })["catch"](function (error) {
            console.log(error);
          });
        },
        changePage: function changePage(dir) {
          if (dir == "prev" && this.data.currentPage !== 1) {
            this.data.currentPage--;
          } else if (dir == "next" && this.data.currentPage !== this.data.totalPages) {
            this.data.currentPage++;
          } else {
            return;
          }

          _eventBus["default"].$emit('scroll-to-top', this.data["class"]);

          this.getResults();
        },
        // updateEmailDocs(data) {
        //     // add or remove items to email
        //     let item = this.data.emailDocs.find(item => {
        //         return item.id == data.id;
        //     });
        //     if (!item) {
        //         this.data.emailDocs = [...this.data.emailDocs, data];
        //     } else {
        //         this.data.emailDocs.splice(this.data.emailDocs.indexOf(item),1);
        //     }
        // },
        updateEmailDocData: function updateEmailDocData(data) {
          var existing = this.data.emailDocs.filter(function (item) {
            return item.id == data.id;
          });
          var updatedData;

          if (existing.length > 0) {
            updatedData = this.data.emailDocs.map(function (item) {
              if (data.id == item.id) {
                return item = data;
              } else {
                return item;
              }
            });
          } else {
            updatedData = [].concat(_toConsumableArray(this.data.emailDocs), [data]);
          }

          this.data.emailDocs = updatedData;
        },
        removeCartItem: function removeCartItem(id) {
          // let index = this.data.emailDocs.map((e) => {
          //     return e.id
          // }).indexOf(id);
          // if (index > -1) {
          //     this.data.emailDocs.splice(index,1);
          // }
          this.data.emailDocs = this.data.emailDocs.filter(function (item) {
            return item.id !== id;
          });
        },
        scrollToTop: function scrollToTop(el) {
          if (el !== this.data["class"]) {
            return;
          }

          var top = this.$el.querySelector('.lit-order__area-cards').getBoundingClientRect().top + window.scrollY - 100; // console.log(top);

          setTimeout(function () {
            window.scrollTo({
              top: top,
              behavior: 'smooth'
            });
          }, 500);
        },
        initPages: function initPages() {
          // based on total result count, divide by 10 to get total pages needed
          // math ceil to round up
          // set active for prev/next based on current page
          this.data.totalPages = Math.ceil(this.data.totalResults / 10);
          this.data.prevActive = this.data.currentPage !== 1 ? true : false;
          this.data.nextActive = this.data.currentPage !== this.data.totalPages ? true : false;
        },
        handleSubmit: function handleSubmit(data) {
          if (data.modalName == this.data.modalTarget) {
            // set isSubmitted to true when form is submitted
            this.data.isSubmitted = true;
          }
        },
        handleClose: function handleClose(data) {
          if (data.modalName == this.data.modalTarget && this.data.isSubmitted) {
            this.data.emailDocs = []; //empty cart contents array on modal close (only if form is submitted)

            this.data.isSubmitted = false; //set is submitted back to false
          }
        },
        init: function init() {
          var _this3 = this;

          this.data.isMobile = _store["default"].state.isMobile;
          this.data.savedDocs = _store["default"].state.favorites.documentId[0] == "" ? _store["default"].state.favorites.documentId.slice(1) : _store["default"].state.favorites.documentId;
          this.data.filtersVisible = this.data.isMobile ? false : true; //init show/hide filters if/is mobile
          // listen for filter updates in children

          _eventBus["default"].$on('updateFilters', function (el, e, type) {
            _this3.updateFilters(el, e, type);
          });

          _eventBus["default"].$on('remove-filter', function (el, value, type) {
            _this3.removeFilter(el, value, type);
          });

          _eventBus["default"].$on('change-page-to', function (el, num) {
            if (el !== _this3.data["class"]) {
              return;
            }

            ;
            _this3.data.currentPage = num;

            _this3.getResults();
          }); // EventBus.$on('email-docs', (data) => {
          //     this.updateEmailDocs(data);
          // });


          _eventBus["default"].$on('update-email-doc-data', function (data) {
            _this3.updateEmailDocData(data);
          });

          _eventBus["default"].$on('internal-search', function (value, type) {
            if (type == "documentation") {
              _this3.getResults(value);
            }
          });

          _eventBus["default"].$on('scroll-to-top', function (el) {
            _this3.scrollToTop(el);
          });

          _eventBus["default"].$on('remove-cart-item', function (id) {
            _this3.removeCartItem(id);
          });

          _eventBus["default"].$on('form-submitted', function (data) {
            _this3.handleSubmit(data);
          });

          _eventBus["default"].$on('form-closed', function (data) {
            _this3.handleClose(data);
          }); // init results


          this.data.results = window.initialDocumentationApiResults.results;
          this.data.totalResults = window.initialDocumentationApiResults.totalResults;
          this.data.shownResults = window.initialDocumentationApiResults.results.length; // this.data.results = fpodb.documentation.results;
          // this.data.totalResults = fpodb.documentation.totalResults;
          // this.data.shownResults = fpodb.documentation.results.length;
          // hide filters if less then 10 initial results

          this.data.filterAreaVisible = parseInt(this.data.totalResults) <= 10 ? false : true; // enable "share all" if 5 of less results

          this.data.shareAll = parseInt(this.data.totalResults) <= 5 ? true : false; // window.onpopstate = () => {
          //     this.deeplink();
          // }

          this.$nextTick(function () {
            _this3.data.modalTarget = _this3.$refs.cartButton.getAttribute('href').substring(1); // dynamic cart component container for passing to generic form modal 

            _this3.data.cartContents = "<div class=\"lit-order__cards-content lit-order__cards-content-cart\" is=\"cart\" ref=\"cart\" modal-target=\"".concat(_this3.data.modalTarget, "\"></div>");
          });
        }
      },
      mounted: function mounted() {
        this.init();
        this.initPages(); // for deeplinking
        // if (window.location.search) {
        //     this.$nextTick(() => {
        //         this.deeplink();
        //     });
        // }
      }
    });

    _vueMin["default"].component('lit-products', {
      props: ['data'],
      data: function data() {
        return {
          type: "product"
        };
      },
      components: {
        'checkbox-item': _filterComponents.Checkbox
      },
      template: "\n            <div class=\"lit-order__products-content\">\n                <checkbox-item v-for=\"(productItem, i) in data.products\" :key=i :type=\"type\" :label=\"productItem.value\" :value=\"productItem.key\" :data=\"data\"/>\n            </div>\n            ",
      methods: {},
      mounted: function mounted() {}
    }); // results list


    _vueMin["default"].component('lit-results-list', {
      props: ['data'],
      data: function data() {
        return {
          type: "document"
        };
      },
      template: "\n            <div class=\"lit-order__cards-content\">\n                <lit-results-item v-for=\"(result, index) in data.results\" :content=\"result\" :isSelected=\"isSelected(result)\" :qtyData=\"qtyData(result)\" :key=\"result.id\" :data=\"data\" :cartVersion=\"false\"/>\n            </div>\n            ",
      methods: {
        isSelected: function isSelected(result) {
          return this.data.emailDocs.find(function (i) {
            return i.id == result.id;
          }) !== undefined;
        },
        qtyData: function qtyData(result) {
          var saved = this.data.emailDocs.find(function (i) {
            return i.id == result.id;
          });

          if (saved) {
            return {
              qty: saved.qty,
              prePunched: saved.prePunched
            };
          } else {
            return null;
          }
        }
      },
      mounted: function mounted() {}
    }); // single results item


    _vueMin["default"].component('lit-results-item', {
      props: ['data', 'content', 'isSelected', 'qtyData', 'cartVersion'],
      data: function data() {
        return {
          isChecked: this.isSelected,
          isBookmarked: false,
          id: null,
          seeAll: null,
          //is "see all" feature enabled,
          seeAllOpen: null,
          seeAllLabel: null,
          //label
          moreContent: null,
          prePunched: this.qtyData ? this.qtyData.prePunched : null,
          qty: this.qtyData ? this.qtyData.qty : null,
          valid: true,
          isInCart: this.cartVersion ? true : null
        };
      },
      computed: _defineProperty({
        saved: function saved() {
          return _store["default"].state.favorites.documentId;
        },
        encodedUrl: function encodedUrl() {
          return encodeURIComponent(this.content.url);
        },
        newTabLink: function newTabLink() {
          return this.content.url.replace('download=true', 'download=false');
        },
        errorMsg: function errorMsg() {
          return window.enterValidQuantityLabel;
        }
      }, "newTabLink", function newTabLink() {
        return this.content.url ? this.content.url.replace('download=true', 'download=false') : null;
      }),
      watch: {
        saved: function saved() {
          this.isBookmarked = this.saved.includes(this.id) ? true : false;
        },
        "cartVersion": function cartVersion() {
          if (this.cartVersion) {
            this.isInCart = true;
          }
        },
        "data.emailDocs": function dataEmailDocs() {
          var _this4 = this;

          var match = this.data.emailDocs.filter(function (item) {
            return item.id == _this4.id;
          });
          this.isInCart = match.length > 0 ? true : false;

          if (match.length > 0) {
            this.qty = match[0].qty;
            this.prePunched = match[0].prePunched;
          } // else {
          //     this.qty = "";
          //     this.prePunched = null;
          // }

        },
        "content": function content() {
          var _this5 = this;

          // update id when content changes
          this.$nextTick(function () {
            _this5.id = _this5.$refs.bookmark.dataset.documentId;
            _this5.isBookmarked = _this5.saved.includes("".concat(_this5.id)) ? true : false;
          });
        },
        "seeAll": function seeAll() {
          if (this.seeAll) {
            this.seeAllLabel = this.seeAllOpen ? window.seeLessLabel : window.seeAllLabel;
          }
        },
        "seeAllOpen": function seeAllOpen() {
          if (this.seeAll) {
            this.seeAllLabel = this.seeAllOpen ? window.seeLessLabel : window.seeAllLabel;
          }
        },
        "qty": function qty() {
          var _this6 = this;

          if (!this.cartVersion) {
            // allow empty qty value if not in cart
            this.valid = this.qty.match(/^\d+$/) && parseInt(this.qty) >= 5 ? true : this.qty == "" ? true : false;
          } else {
            // if is in cart, empty values are invalid
            this.valid = this.qty.match(/^\d+$/) && parseInt(this.qty) >= 5 ? true : false;
          } // if qty is valid, update the value


          this.$nextTick(function () {
            if (_this6.valid && _this6.qty !== "" && _this6.isInCart) {
              _eventBus["default"].$emit('update-email-doc-data', {
                id: _this6.content.id,
                partNumber: _this6.content.documentId,
                eyebrow: _this6.content.eyebrow,
                details: _this6.content.details,
                name: _this6.content.name,
                qty: _this6.qty,
                prePunched: _this6.prePunched,
                url: _this6.content.url
              });
            }
          }); // validate values if qty is updated in cart

          if (this.isInCart && this.cartVersion) {
            _eventBus["default"].$emit('check-errors');
          }
        },
        "prePunched": function prePunched() {
          if (this.valid && this.qty !== "" && this.isInCart) {
            _eventBus["default"].$emit('update-email-doc-data', {
              id: this.content.id,
              partNumber: this.content.documentId,
              eyebrow: this.content.eyebrow,
              details: this.content.details,
              name: this.content.name,
              qty: this.qty,
              prePunched: this.prePunched,
              url: this.content.url
            });
          }
        },
        "qtyData": function qtyData() {
          // clear qty and prepunched data if null
          if (!this.qtyData) {
            this.qty = "";
            this.prePunched = null;
          }
        }
      },
      template: "\n            <div class=\"lit-card lit-card--checkbox\">\n                <div class=\"lit-card__wrapper\">\n                    <div class=\"lit-card__row\">\n                        <div class=\"lit-card__area lit-card__area-checkbox\" :class=\"{hidden: cartVersion}\">\n                            <a class=\"lit-card__icon lit-card__icon-bookmark\" ref=\"bookmark\" :data-document-id=\"content.id\" v-on:click.prevent=\"handleBookmark\" :class=\"{active: isBookmarked}\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"app\", \"action\": \"Favorite\"}'></a>\n                        </div>\n                        \n                        <div class=\"lit-card__area lit-card__area-info\">\n                            <div class=\"lit-card__area lit-card__area-left\">\n                                <span class=\"lit-card__eyebrow\">\n                                    {{content.eyebrow}}\n                                </span>\n                                <a :href=\"newTabLink\" class=\"lit-card__title\" ref=\"name\" target=\"_blank\">\n                                    {{content.name}}\n                                </a>\n                                <span class=\"lit-card__subtitle\">\n                                    <span class=\"lit-card__subtitle-content\" ref=\"seeAllContent\">{{content.details}}</span> <span class=\"lit-card__subtitle-more\" v-if=\"seeAll && seeAllOpen\">{{moreContent}}</span> <a href=\"#\" v-on:click.prevent=\"toggleSeeAll\" v-if=\"seeAll\">{{seeAllLabel}}</a> | {{content.language}}\n                                </span> \n                            </div>\n                            <div class=\"lit-card__area lit-card__area-right\">\n                                <div class=\"lit-card__qty-container\">\n                                    <input class=\"lit-card__qty-input\" v-model=\"qty\" :class=\"{invalid: !valid && valid !== null}\" placeholder=\"QTY\">\n                                    <a href=\"#\" class=\"lit-card__button\" v-on:click.prevent=\"addToCart\" v-if=\"!cartVersion\">Add</a>\n                                    <a href=\"#\" class=\"lit-card__button lit-card__button-remove\" v-on:click.prevent=\"removeFromCart\" v-if=\"cartVersion\"><span class=\"lit-card__remove\"></span></a>\n                                </div>\n                                <div class=\"lit-card__error\" v-if=\"!valid\">\n                                    <p>{{errorMsg}}</p>\n                                </div>\n                                <div class=\"lit-card__checkbox-container checkbox\">\n                                    <label class=\"lit-card__checkbox-label checkbox__label\">\n                                        <input type=\"checkbox\" class=\"lit-card__checkbox checkbox__input\" v-model=\"prePunched\">\n                                        <span class=\"lit-card__checkbox-checkmark checkbox__checkmark\"></span>\n                                        <span class=\"lit-card__checkbox-text checkbox__text\">Pre-punched</span>\n                                    </label>\n                                </div>\n                            </div>\n                        </div>\n                        \n                    </div>\n                </div>\n            </div>\n\n            ",
      methods: {
        // emailDoc() {
        //     EventBus.$emit('email-docs', {
        //         "name": this.content.name, 
        //         "url": this.content.url, 
        //         "id": this.content.id, 
        //         "qty": this.qty,
        //         "prePunched": this.prePunched,
        //         "eyebrow": this.content.eyebrow,
        //         "details": this.content.details
        //     });
        // },
        handleBookmark: function handleBookmark() {
          _store["default"].commit('updateFavorites', {
            id: this.id,
            type: "documentId",
            action: this.isBookmarked ? "remove" : "add"
          });

          _store["default"].dispatch('checkFavorites');
        },
        toggleSeeAll: function toggleSeeAll() {
          this.seeAllOpen = !this.seeAllOpen;
        },
        initSeeAll: function initSeeAll() {
          if (this.$refs.seeAllContent) {
            var details = this.$refs.seeAllContent.innerHTML.split(',');
            this.seeAll = details.length > 3 ? true : false;
            var truncatedDetails = details.slice(0, 3).join();
            var moreDetails = details.slice(3).join();
            this.moreContent = moreDetails;
            this.$refs.seeAllContent.innerHTML = "".concat(truncatedDetails).concat(moreDetails == "" ? '' : ',');
          }
        },
        addToCart: function addToCart() {
          if (!this.qty) {
            this.valid = false;
          } else if (parseInt(this.qty) < 5) {
            this.valid = false;
          } else {
            var data = {
              id: this.content.id,
              partNumber: this.content.documentId,
              eyebrow: this.content.eyebrow,
              details: this.content.details,
              name: this.content.name,
              qty: this.qty,
              prePunched: this.prePunched,
              url: this.content.url
            };

            _eventBus["default"].$emit('update-email-doc-data', data);
          }
        },
        removeFromCart: function removeFromCart() {
          _eventBus["default"].$emit('remove-cart-item', this.id);
        }
      },
      mounted: function mounted() {
        var _this7 = this;

        this.id = this.$refs.bookmark.dataset.documentId; // console.log("saved",this.saved);

        this.isBookmarked = this.saved.includes("".concat(this.id)) ? true : false;
        this.initSeeAll(); // if item is explicitly removed from cart, clear its input values

        _eventBus["default"].$on('remove-cart-item', function (id) {
          if (id == _this7.id) {
            _this7.qty = "";
            _this7.prePunched = null;
          }
        });
      }
    }); // cart


    _vueMin["default"].component('cart', {
      props: ['modalTarget'],
      data: function data() {
        return {
          hasErrors: null,
          cartHash: null,
          isSubmitted: false
        };
      },
      computed: {
        cartContent: function cartContent() {
          return _store["default"].state.litOrderCart;
        },
        errorMsg: function errorMsg() {
          return window.enterValidQuantityLabel;
        }
      },
      watch: {
        hasErrors: function hasErrors() {
          if (this.hasErrors) {
            this.$el.parentNode.classList.add('hasErrors');
          } else {
            this.$el.parentNode.classList.remove('hasErrors');
          }
        },
        cartContent: function cartContent() {
          if (this.cartContent.length == 0) {
            _modalTrigger.instance.closeModal(this.cartHash);
          }
        },
        // for showing/hiding cart module. hide if submitted.
        isSubmitted: function isSubmitted() {
          this.$el.style.display = this.isSubmitted ? 'none' : 'block';
        }
      },
      template: "\n            <div>\n                <div>\n                    <lit-results-item v-for=\"(result, index) in cartContent\" :content=\"result\" :key=\"result.id\" :cartVersion=\"true\" :qtyData=\"qtyData(result)\" />\n                </div>\n                <p class=\"lit-card__error\" v-if=\"hasErrors\">{{errorMsg}}<p/>\n            </div>",
      methods: {
        qtyData: function qtyData(result) {
          var saved = this.cartContent.find(function (i) {
            return i.id == result.id;
          });

          if (saved) {
            return {
              qty: saved.qty,
              prePunched: saved.prePunched
            };
          } else {
            return null;
          }
        },
        checkErrors: function checkErrors() {
          var _this8 = this;

          // console.log("checking");
          this.$nextTick(function () {
            var invalidEntry = _this8.$el.querySelector('.lit-card__qty-input.invalid');

            _this8.hasErrors = invalidEntry ? true : false;
            console.log(invalidEntry);
          });
        },
        getHash: function getHash() {
          this.cartHash = this.$el.closest('.bmi-modal__wrapper') ? this.$el.closest('.bmi-modal__wrapper').getAttribute('name') : null;
        },
        handleSubmit: function handleSubmit(data) {
          if (data.modalName == this.modalTarget) {
            this.isSubmitted = true;
          }
        },
        handleClose: function handleClose(data) {
          if (data.modalName == this.modalTarget && this.isSubmitted) {
            this.isSubmitted = false; //set is submitted back to false
          }
        },
        init: function init() {
          var _this9 = this;

          _eventBus["default"].$on('form-submitted', function (data) {
            _this9.handleSubmit(data);
          });

          _eventBus["default"].$on('form-closed', function (data) {
            _this9.handleClose(data);
          });
        }
      },
      mounted: function mounted() {
        var _this10 = this;

        _eventBus["default"].$on('check-errors', function () {
          _this10.checkErrors();
        });

        this.getHash();
        this.init();
      }
    });

    new _vueMin["default"]({
      el: ".lit-order-".concat(id),
      store: _store["default"]
    }).$mount(".lit-order-".concat(id), true);
  };

  if (litOrder.length > 0) {
    litOrder.forEach(function (item, index) {
      item.classList.add("lit-order-".concat(index));
      litOrderConstructor(index);
    });
  } // window.enterValidQuantityLabel = "error test";

};

var _default = LitOrder;
exports["default"] = _default;

},{"../../../db.json":64,"./event-bus":9,"./filter-components":11,"./modal-trigger":29,"./store":51,"axios":66,"vue-js-modal":233,"vue/dist/vue.min.js":234}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _lory = require("lory.js");

var _eventBus = _interopRequireDefault(require("./event-bus"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// **NOTE**
// 1 index
var MarketApps = function MarketApps() {
  var apps = document.querySelectorAll('.market-apps');

  var marketAppsConstructor = function marketAppsConstructor(id) {
    _vueMin["default"].component('market-apps-template', {
      data: function data() {
        return {
          sliderEl: null,
          options: {
            classNameFrame: 'market-apps__frame',
            enableMouseEvents: true
          },
          lory: null,
          length: null,
          currentSlide: 1
        };
      },
      methods: {
        initLory: function initLory() {
          this.lory = (0, _lory.lory)(this.sliderEl, this.options);
        },
        initListener: function initListener() {
          var _this = this;

          this.sliderEl.addEventListener('after.lory.slide', function () {
            _this.currentSlide = _this.lory.returnIndex() + 1;
          });

          _eventBus["default"].$on('select-slide', function (target) {
            _this.currentSlide = target;

            _this.lory.slideTo(target - 1);
          });
        },
        initTags: function initTags() {
          var _this2 = this;

          var tags = {
            "type": "layer",
            "category": "Preview Card",
            "action": "Open",
            "label": null,
            "no": null
          };
          this.sliderEl.querySelectorAll('li').forEach(function (slide, i) {
            slide.dataset.tagMeta = JSON.stringify(_objectSpread(_objectSpread({}, tags), {}, {
              "label": _this2.$el.querySelectorAll('.market-apps__nav-item a')[i].innerText,
              "no": i + 1 < 10 ? "0".concat(i + 1) : "".concat(i + 1)
            }));
          });
        }
      },
      mounted: function mounted() {
        this.sliderEl = this.$el.querySelector('.market-apps__slider');
        this.length = this.$el.querySelectorAll('.market-apps__slide').length;
        this.initLory();
        this.initListener();
        this.initTags();
      }
    });

    _vueMin["default"].component('market-apps-nav-item', {
      props: ['currentSlide'],
      data: function data() {
        return {
          target: null,
          isActive: null,
          label: null
        };
      },
      computed: {
        taggingMeta: function taggingMeta() {
          return JSON.stringify({
            "type": "layer",
            "category": "Preview Card",
            "action": "Open",
            "label": this.label,
            "no": this.target < 10 ? "0".concat(this.target) : this.target.toString()
          });
        }
      },
      watch: {
        currentSlide: function currentSlide() {
          this.isActive = this.target == this.currentSlide ? true : false;
        }
      },
      methods: {
        init: function init() {
          // set target id based on node position
          this.target = [].indexOf.call(this.$el.parentNode.children, this.$el) + 1;
          this.isActive = this.target == this.currentSlide ? true : false;
          this.label = this.$el.querySelector('a').innerText;
        },
        selectSlide: function selectSlide() {
          _eventBus["default"].$emit('select-slide', this.target);
        }
      },
      mounted: function mounted() {
        this.init();
      }
    });

    new _vueMin["default"]({
      el: ".market-apps-".concat(id)
    }).$mount(".market-apps-".concat(id), true);
  };

  if (apps.length > 0) {
    apps.forEach(function (item, index) {
      item.classList.add("market-apps-".concat(index));
      marketAppsConstructor(index);
    });
  }
};

var _default = MarketApps;
exports["default"] = _default;

},{"./event-bus":9,"lory.js":223,"vue/dist/vue.min.js":234}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _misc = require("lib/misc");

var _axios = _interopRequireDefault(require("axios"));

var _db = _interopRequireDefault(require("../../../db.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// NOTES:
// menu is broken down into primary, 2nd level, and 3rd level "panels" 
// primary: top level menu category (e.g. municipal water solutions, industrial measurement solutions)
// 2nd lvl: categories under the primary category (e.g. products, product lines)
// 3rd lvl: content inside the 2nd level category (e.g. meters, meter components, endpoints)
// "primary" and "secondary" menu panels/items are based on the 
// megamenu DOM order in megamenu.hbs. 
// on mobile, primary-menu-item ID is determined by DOM order. (e.g. the first item in the dom is primary-1, the second is primary-2, etc.)
// selectedSecondaryId is constructed from the secondary level ID and its parent, the selected primary Id (e.g. secondary-1-primary-2 refers to the 1st secondary category in the 2nd primary category)
var Megamenu = function Megamenu() {
  var menu = document.querySelector('.megamenu');

  var megamenuConstructor = function megamenuConstructor() {
    _vueMin["default"].component('megamenu-template', {
      data: function data() {
        return {
          data: {
            isMobile: _store["default"].state.isMobile,
            selectedPrimaryId: null,
            selectedSecondaryId: null,
            selectedTopbarId: null,
            mobileMenuOpen: false,
            topbarMenuOpen: false,
            //topbar menu INSIDE the megamenu, not the one outside
            primaryMenuOpen: false,
            secondaryMenuOpen: false,
            menuData: _store["default"].state.menuKeys,
            searchOpen: false,
            store: _store["default"],
            scrollDir: null
          }
        };
      },
      computed: {
        computedIsMobile: function computedIsMobile() {
          return _store["default"].state.isMobile;
        },
        computedMenuData: function computedMenuData() {
          return _store["default"].state.menuKeys;
        }
      },
      watch: {
        computedIsMobile: function computedIsMobile() {
          this.data.isMobile = this.computedIsMobile;

          if (!this.data.isMobile) {
            // close mobile menu if desktop
            this.data.mobileMenuOpen = false;
          }

          this.positionMenu();
        },
        computedMenuData: function computedMenuData() {
          this.data.menuData = this.computedMenuData;
        },
        // handle closing megamenu on outside click
        "data.selectedPrimaryId": function dataSelectedPrimaryId() {
          if (!this.data.isMobile) {
            if (this.data.selectedPrimaryId !== null) {
              document.addEventListener('click', this.outsideClick);
            } else {
              document.removeEventListener('click', this.outsideClick);
            }
          } else {
            document.removeEventListener('click', this.outsideClick);
          }
        },
        "data.scrollDir": function dataScrollDir() {
          var menuContainer = this.$el.parentNode; // console.log(menuContainer);

          switch (this.data.scrollDir) {
            case "top":
              menuContainer.classList.remove("hidden");
              break;

            case "up":
              menuContainer.classList.remove("hidden");
              break;

            case "down":
              menuContainer.classList.add("hidden");
              break;

            default:
              return;
          }
        }
      },
      methods: {
        toggleMobileMenu: function toggleMobileMenu() {
          this.data.mobileMenuOpen = !this.data.mobileMenuOpen;
        },
        outsideClick: function outsideClick(e) {
          var target = e.target;
          var megamenu = this.$el;

          if (!megamenu.contains(target)) {
            this.data.selectedPrimaryId = null;
          }
        },
        positionMenu: function positionMenu() {
          var _this = this;

          var scrollPos = 0;

          var handleScroll = function handleScroll() {
            if (document.body.getBoundingClientRect().top == 0) {
              _this.data.scrollDir = "top";
            } else if (document.body.getBoundingClientRect().top > scrollPos) {
              _this.data.scrollDir = "up";
            } else {
              _this.data.scrollDir = "down";
            }

            scrollPos = document.body.getBoundingClientRect().top;
          };

          if (this.data.isMobile) {
            window.addEventListener("scroll", handleScroll);
          } else {
            window.removeEventListener('scroll', handleScroll);
          }
        },
        init: function init() {
          var _this2 = this;

          _eventBus["default"].$on('setTopbarSelection', function (id) {
            _this2.data.selectedTopbarId = id;
            _this2.data.topbarMenuOpen = true;
            _this2.data.primaryMenuOpen = false;
          });

          _eventBus["default"].$on('back', function (obj) {
            var keys = Object.keys(obj);
            keys.forEach(function (item, i) {
              _this2.data[item] = obj[item];
            });
          });

          _eventBus["default"].$on('setPrimarySelection', function (id) {
            _this2.data.selectedPrimaryId = id;
            _this2.data.primaryMenuOpen = true;
            _this2.data.topbarMenuOpen = false;
          });

          _eventBus["default"].$on('setSecondarySelection', function (id) {
            _this2.data.selectedSecondaryId = id;
          });
        }
      },
      mounted: function mounted() {
        this.init();
        this.positionMenu();
      }
    }); // wrapper for top level submenus
    // e.g. Municipal water solutions, Industrial measurement solutions


    _vueMin["default"].component('megamenu-submenu', {
      props: ['data'],
      data: function data() {
        return {
          id: null,
          isOpen: false
        };
      },
      watch: {
        'data.selectedPrimaryId': function dataSelectedPrimaryId() {
          this.isOpen = this.id == this.data.selectedPrimaryId ? true : false;
        }
      },
      methods: {},
      mounted: function mounted() {
        // set current submenu ID based on 1 index
        this.id = "submenu-" + [].indexOf.call(this.$el.parentNode.children, this.$el);
      }
    });

    _vueMin["default"].component('mobile-panel', {
      props: ['data'],
      data: function data() {
        return {};
      },
      methods: {},
      mounted: function mounted() {}
    });

    _vueMin["default"].component('primary-menu-item', {
      props: ['isMobile'],
      data: function data() {
        return {
          id: null,
          title: '',
          suffix: null
        };
      },
      methods: {
        init: function init() {
          //  set =id
          var menuItems = Array.from(document.querySelectorAll('.megamenu__mobile-item--main'));
          this.id = "primary-" + (menuItems.indexOf(this.$el) + 1);
          this.suffix = menuItems.indexOf(this.$el) + 1; // set title

          this.title = this.$el.innerText;

          _store["default"].commit('updateMenu', {
            'id': this.id,
            'title': this.title
          });

          this.initEvents();
        },
        initEvents: function initEvents() {
          var _this3 = this;

          this.$el.addEventListener('click', function (e) {
            e.preventDefault();

            if (_this3.isMobile) {
              _this3.handleMobileEvents(e);
            } else {// this.handleDesktopEvents(e);
            }
          });
        },
        // handleDesktopEvents(e) {
        //     EventBus.$emit('setSecondarySelection', `secondary-1-primary-${this.suffix}`);
        // },
        handleMobileEvents: function handleMobileEvents(e) {
          // console.log("clicked");
          _eventBus["default"].$emit('setPrimarySelection', this.id);
        }
      },
      mounted: function mounted() {
        this.init();
      }
    });

    _vueMin["default"].component('primary-menu-item-desktop', {
      props: ['parent-id', 'data'],
      data: function data() {
        return {
          id: null,
          isActive: false
        };
      },
      watch: {
        parentId: function parentId() {
          this.id = "primary-" + this.parentId.slice(8);
          this.initSubmenu();
        },
        'data.selectedPrimaryId': function dataSelectedPrimaryId() {
          this.isActive = this.parentId == this.data.selectedPrimaryId ? true : false;
        }
      },
      methods: {
        initSubmenu: function initSubmenu(e) {
          if (e) {
            e.preventDefault();
          }

          if (!this.data.isMobile) {
            _eventBus["default"].$emit('setSecondarySelection', "secondary-1-".concat(this.id));
          }
        },
        selectMenu: function selectMenu() {
          if (this.parentId == this.data.selectedPrimaryId) {
            _eventBus["default"].$emit('setPrimarySelection', null);
          } else {
            _eventBus["default"].$emit('setPrimarySelection', "".concat(this.parentId));

            if (!this.data.isMobile) {
              _eventBus["default"].$emit('setSecondarySelection', "secondary-1-".concat(this.id));
            }
          }
        }
      },
      mounted: function mounted() {}
    });

    _vueMin["default"].component('primary-panel', {
      props: ['parent-id', 'data'],
      data: function data() {
        return {
          id: null,
          title: '',
          isActive: false
        };
      },
      computed: {
        selectedId: function selectedId() {
          return this.data.selectedPrimaryId;
        }
      },
      watch: {
        selectedId: function selectedId() {
          this.isActive = this.selectedId == this.id ? true : false;
        }
      },
      methods: {
        init: function init() {
          var primaryPanels = Array.from(document.querySelectorAll('.megamenu__submenu-area-left'));
          this.id = "primary-" + (primaryPanels.indexOf(this.$el) + 1);
          this.getTitle();
        },
        back: function back(e) {
          // console.log('back');
          e.preventDefault();

          _eventBus["default"].$emit('back', {
            "primaryMenuOpen": false
          });
        },
        getTitle: function getTitle() {
          var _this4 = this;

          var match = this.data.menuData.find(function (item) {
            // console.log("item", item.id);
            // console.log("id", this.id);
            return item.id === _this4.id;
          });

          if (match) {
            this.title = match.title;
          }
        }
      },
      mounted: function mounted() {
        this.init();
      }
    });

    _vueMin["default"].component('secondary-panel', {
      props: ['parent-id', 'data'],
      data: function data() {
        return {};
      },
      methods: {},
      mounted: function mounted() {}
    });

    _vueMin["default"].component('secondary-content', {
      props: ['parentId', 'data'],
      data: function data() {
        return {
          id: null,
          suffix: '',
          isActive: false
        };
      },
      computed: {
        selectedId: function selectedId() {
          return this.data.selectedSecondaryId;
        }
      },
      watch: {
        parentId: function parentId() {
          this.suffix = this.parentId.substring(8);
          this.init();
        },
        selectedId: function selectedId() {
          this.isActive = this.selectedId == this.id ? true : false;
        } // 'data.menuData': function() {
        //     this.getElements();
        // }

      },
      methods: {
        init: function init() {
          // set id
          var items = Array.from(this.$el.parentNode.querySelectorAll('.megamenu__submenu-content'));
          this.id = "secondary-" + (items.indexOf(this.$el) + 1) + "-primary-" + this.suffix;
          this.$el.dataset.id = this.id;
        } // getElements() {
        //     let innerContent = this.$el.querySelector('.megamenu__inner-area');
        // }

      },
      mounted: function mounted() {}
    });

    _vueMin["default"].component('secondary-menu-item', {
      props: ['parentId', 'data'],
      data: function data() {
        return {
          id: null,
          title: '',
          isActive: false
        };
      },
      computed: {
        selectedId: function selectedId() {
          return this.data.selectedSecondaryId;
        }
      },
      // wait until parent has and ID to assign child id
      watch: {
        parentId: function parentId() {
          this.init();
        },
        selectedId: function selectedId() {
          this.isActive = this.selectedId == this.id ? true : false;
        }
      },
      methods: {
        init: function init() {
          var _this5 = this;

          // set id
          var items = Array.from(this.$el.parentNode.querySelectorAll('.megamenu__submenu-item'));
          this.id = "secondary-" + (items.indexOf(this.$el) + 1) + "-" + this.parentId;
          this.$nextTick(function () {
            var innerContent = document.querySelector("div[data-id=\"".concat(_this5.id, "\"]")).cloneNode(true);
            _this5.title = _this5.$el.innerText;

            _store["default"].commit('updateMenu', {
              "id": _this5.id,
              "title": _this5.title,
              "el": innerContent
            });
          }); // set title
        },
        handleDesktop: function handleDesktop(e) {
          e.preventDefault(); // console.log("clicked desktop");

          _eventBus["default"].$emit('setSecondarySelection', this.id);
        },
        handleMobile: function handleMobile(e) {
          e.preventDefault(); // console.log("clicked mobile");

          this.isActive = !this.isActive;

          _eventBus["default"].$emit('setSecondarySelection', this.id);
        },
        initEvents: function initEvents() {
          var _this6 = this;

          this.$el.querySelector('.megamenu__submenu-item-link').addEventListener('click', function (e) {
            if (_this6.data.isMobile) {
              _this6.handleMobile(e);
            } else {
              _this6.handleDesktop(e);
            }
          });
        }
      },
      mounted: function mounted() {
        this.initEvents();
      }
    });

    _vueMin["default"].component('secondary-inner-content', {
      props: ['data', 'id'],
      data: function data() {
        return {};
      },
      watch: {
        'data.menuData': function dataMenuData() {
          this.initContent();
        }
      },
      methods: {
        initContent: function initContent() {
          var _this7 = this;

          var obj = this.data.menuData.find(function (item) {
            return item.id == _this7.id;
          });

          if (obj) {
            var el = obj.el;
            this.$refs.inner.appendChild(el);
          }
        }
      },
      mounted: function mounted() {// this.initContent();
      }
    });

    _vueMin["default"].component('topbar-panel', {
      props: ['data'],
      data: function data() {
        return {};
      },
      methods: {},
      mounted: function mounted() {}
    });

    _vueMin["default"].component('topbar-content', {
      props: ['data'],
      data: function data() {
        return {
          menuData: _store["default"].state.menuKeys,
          id: null,
          isActive: false,
          title: ''
        };
      },
      computed: {
        selectedId: function selectedId() {
          return this.data.selectedTopbarId;
        },
        updatedMenuData: function updatedMenuData() {
          return _store["default"].state.menuKeys;
        }
      },
      watch: {
        // only watch the selected topbar content id
        selectedId: function selectedId() {
          this.isActive = this.id == this.selectedId ? true : false;
        },
        updatedMenuData: function updatedMenuData() {
          this.menuData = _store["default"].state.menuKeys;
          this.init();
        }
      },
      methods: {
        back: function back(e) {
          // console.log('back');
          e.preventDefault();

          _eventBus["default"].$emit('back', {
            "topbarMenuOpen": false
          });
        },
        init: function init() {
          var _this8 = this;

          var match = this.menuData.find(function (item) {
            // console.log("item", item.id);
            // console.log("id", this.id);
            return item.id === _this8.id;
          });

          if (match) {
            this.title = match.title;
          }
        }
      },
      mounted: function mounted() {
        var menuItems = Array.from(document.querySelectorAll('.megamenu__mobile-topbar'));
        this.id = "topbar-" + (menuItems.indexOf(this.$el) + 1); // console.log(this.menuData);
        // console.log("test",test);
      }
    });

    _vueMin["default"].component('topbar-menu-item', {
      data: function data() {
        return {
          isMobile: _store["default"].state.isMobile,
          id: null,
          title: ''
        };
      },
      computed: {
        computedIsMobile: function computedIsMobile() {
          return _store["default"].state.isMobile;
        }
      },
      watch: {
        computedIsMobile: function computedIsMobile() {
          this.isMobile = this.computedIsMobile;
          this.init();
        }
      },
      methods: {
        init: function init() {
          var _this9 = this;

          if (this.isMobile) {
            // add event listeners
            this.$el.addEventListener('click', function (e) {
              e.preventDefault();

              _this9.handleEvents(e);
            });
            this.setTitle();
          } else {
            // remove event listeners
            this.$el.removeEventListener('click', function (e) {
              _this9.handleEvents(e);
            });
          }
        },
        handleEvents: function handleEvents(e) {
          console.log("clicked");

          _eventBus["default"].$emit('setTopbarSelection', this.id);
        },
        // set section title to pass to section menu
        setTitle: function setTitle() {
          this.title = this.$el.innerText;

          _store["default"].commit('updateMenu', {
            "id": this.id,
            "title": this.title
          });
        }
      },
      mounted: function mounted() {
        var menuItems = Array.from(document.querySelectorAll('.megamenu__mobile-item--topbar'));
        this.id = "topbar-" + (menuItems.indexOf(this.$el) + 1);
        this.init();
      }
    });

    _vueMin["default"].component('lang-selector', {
      data: function data() {
        return {
          activeLang: null,
          allLangs: [],
          store: _store["default"]
        };
      },
      methods: {},
      mounted: function mounted() {}
    });

    _vueMin["default"].component('lang-selector-item', {
      props: ['allLangs', 'activeLang'],
      data: function data() {
        return {
          lang: null,
          isActive: false
        };
      },
      watch: {
        activeLang: function activeLang() {
          this.isActive = this.activeLang === this.lang ? true : false;
        }
      },
      methods: {
        // changeLang(e) {
        //     // this.activeLang = this.lang;
        //     EventBus.$emit('set-lang', this.lang);
        // },
        selectLang: function selectLang(e) {
          // this.activeLang = this.lang;
          // EventBus.$emit('set-lang', this.lang);
          var lang = e.currentTarget.dataset.lang;

          if (lang) {
            document.cookie = "selectedLanguage=".concat(lang, "; path=/; max-age=31536000;");
          }
        }
      },
      mounted: function mounted() {
        this.lang = this.$el.getAttribute('href').slice(1).toLowerCase();
        this.isActive = this.activeLang == this.lang ? true : false;
      }
    });

    _vueMin["default"].component('search', {
      props: ['data'],
      data: function data() {
        return {
          isOpen: false,
          predictiveSearchOpen: false,
          searchTerm: null,
          //from input for v-model
          searchTermVis: null,
          //displayed search term
          isLoading: null,
          results: null
        };
      },
      watch: {
        searchTerm: function searchTerm() {
          // init search if search term is longer than 1 character and not spaces
          var self = this;

          if (this.searchTerm && this.searchTerm.replace(/\s+/g, '') !== "" && this.searchTerm.length > 1) {
            this.predictiveSearchOpen = true;
            this.isLoading = true;
            this.getResults(); // console.log(debounce);
          } else {
            this.predictiveSearchOpen = false;
          }
        },
        isOpen: function isOpen() {
          var _this10 = this;

          if (this.isOpen) {
            this.$nextTick(function () {
              _this10.$refs.globalSearch.focus();
            });
          }
        }
      },
      computed: {
        // includes url params for auto filtering on search results page
        // filters params are by filter ID
        searchUrl: function searchUrl() {
          return "".concat(window.baseSearchUrl, "?q=").concat(this.searchTermVis);
        },
        productUrl: function productUrl() {
          return "".concat(window.baseProductUrl, "&q=").concat(this.searchTermVis);
        },
        documentationUrl: function documentationUrl() {
          return "".concat(window.baseDocumentationUrl, "&q=").concat(this.searchTermVis);
        },
        TechnologyUrl: function TechnologyUrl() {
          return "".concat(window.baseTechnologyUrl, "&q=").concat(this.searchTermVis);
        },
        language: function language() {
          return _store["default"].state.currentLang;
        },
        taggingMeta: function taggingMeta() {
          return JSON.stringify({
            "type": "search",
            "category": "Search",
            "action": "Keywords",
            "label": this.searchTermVis ? this.searchTermVis : "",
            "filterName": "filtername"
          });
        }
      },
      methods: {
        addLoading: function addLoading() {
          document.querySelector('.megamenu__search-input').classList.add('loading');
        },
        removeLoading: function removeLoading() {
          document.querySelector('.megamenu__search-input').classList.remove('loading');
        },
        toggleSearch: function toggleSearch() {
          this.isOpen = !this.isOpen;
        },
        getResults: (0, _misc.debounce)(function () {
          this.addLoading();
          this.searchTermVis = this.searchTerm;
          var apiUrl = "/api/products"; // let apiUrl = "http://localhost:3003/products";

          var self = this;

          _axios["default"].get(apiUrl, {
            params: {
              q: this.searchTerm,
              lang: this.language
            }
          }).then(function (res) {
            // console.log(res.data.results);
            self.isLoading = false;
            self.results = res.data.results.slice(0, 3);
            self.removeLoading();
          })["catch"](function (error) {
            console.log(error);
          });
        }, 1000)
      },
      mounted: function mounted() {}
    });

    _vueMin["default"].component('predictive-results', {
      props: ['results', 'isLoading'],
      data: function data() {
        return {};
      },
      template: "\n            <div>\n                <result-item v-for=\"(result, index) in results\" :key=\"index\" :content=\"result\" :isLoading=\"isLoading\"></result-item>\n            </div>\n            ",
      watch: {},
      methods: {},
      mounted: function mounted() {}
    });

    _vueMin["default"].component('result-item', {
      props: ['content', 'isLoading'],
      data: function data() {
        return {};
      },
      template: "\n            <div class=\"megamenu__presearch-item\">\n                <div class=\"megamenu__presearch-item-image\" v-if=\"content.productImageUrl\">\n                    <a :href=\"content.url\"><img :src=\"content.productImageUrl\" :alt=\"content.productImageUrlAltText\"></a>\n                </div>\n                <div class=\"megamenu__presearch-item-content\">\n                    <a :href=\"content.url\" class=\"megamenu__presearch-item-link\"><span class=\"megamenu__presearch-item-eyebrow\">\n                    {{content.brand}}\n                    </span>\n                    <div class=\"megamenu__presearch-item-title\" v-html=\"content.productName\">\n                    </div></a>\n                </div>\n            </div>\n            ",
      watch: {},
      methods: {},
      mounted: function mounted() {}
    });

    new _vueMin["default"]({
      el: ".megamenu",
      store: _store["default"]
    }).$mount(".megamenu", true);
  };

  if (menu) {
    megamenuConstructor();
  } // window.baseDocumentationUrl = '/search-results?filters=111';
  // window.baseProductUrl = '/search-results?filters=222';
  // window.baseTechnologyUrl = '/search-results?filters=333';
  // window.baseSearchUrl = '/search-results'; 

};

var _default = Megamenu;
exports["default"] = _default;

},{"../../../db.json":64,"./event-bus":9,"./store":51,"axios":66,"lib/misc":28,"vue/dist/vue.min.js":234}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _store = _interopRequireDefault(require("./store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var MenuTopBar = function MenuTopBar() {
  var topBar = document.querySelector('.top-bar');

  var MenuTopBarConstructor = function MenuTopBarConstructor() {
    _vueMin["default"].component('top-bar', {
      data: function data() {
        return {
          activeNav: null,
          isOpen: null
        };
      },
      watch: {
        isOpen: function isOpen() {
          // handle closing subnav on outside click
          if (this.isOpen) {
            document.addEventListener("click", this.outsideClick);
          } else {
            document.removeEventListener("click", this.outsideClick);
          }
        }
      },
      methods: {
        setNav: function setNav(id) {
          this.activeNav = id;
        },
        outsideClick: function outsideClick(e) {
          var target = e.target;
          var topnav = document.querySelector('.top-bar');

          if (!topnav.contains(target)) {
            this.isOpen = false;
            this.activeNav = null;
          }
        }
      },
      mounted: function mounted() {
        var _this = this;

        //give each nav item an id if it has a subnav
        this.$el.querySelectorAll('.top-bar__item').forEach(function (item, index) {
          if (item.querySelector('.top-bar__subnav')) {
            item.dataset.id = index;
          }
        }); // listen for click events from nav items

        _eventBus["default"].$on('setNav', function (id) {
          _this.setNav(id);
        }); // recieve open state from children to handle closing on outside click


        _eventBus["default"].$on('openState', function (state) {
          _this.isOpen = state;
        });
      }
    });

    _vueMin["default"].component('top-bar-item', {
      props: ['activeNav'],
      data: function data() {
        return {
          navId: null,
          isActive: false,
          hasSubNav: false
        };
      },
      watch: {
        activeNav: function activeNav() {
          this.isActive = this.activeNav == this.navId && this.navId !== null ? true : false;
        },
        isActive: function isActive() {
          // send open state to parent to handle closing on outside click
          _eventBus["default"].$emit('openState', this.isActive ? true : false);
        }
      },
      methods: {
        // emit click event to parent
        handleClick: function handleClick(e) {
          //set active state only if item has subnav
          this.isActive = this.hasSubNav ? !this.isActive : false;

          _eventBus["default"].$emit('setNav', this.navId);
        }
      },
      mounted: function mounted() {
        var _this2 = this;

        // wait till next render to get id that's added by parent
        this.$nextTick(function () {
          _this2.navId = _this2.$el.dataset.id || null;
          _this2.hasSubNav = _this2.$el.dataset.id ? true : false;
        });
      }
    });

    _vueMin["default"].component('lang-selector', {
      data: function data() {
        return {
          activeLang: null,
          allLangs: [],
          store: _store["default"]
        };
      },
      methods: {},
      mounted: function mounted() {}
    });

    _vueMin["default"].component('lang-selector-item', {
      props: ['allLangs', 'activeLang'],
      data: function data() {
        return {
          lang: null,
          isActive: false
        };
      },
      // watch: {
      //     activeLang: function() {
      //         this.isActive = this.activeLang === this.lang ? true : false;
      //     }
      // },
      methods: {
        selectLang: function selectLang(e) {
          // this.activeLang = this.lang;
          // EventBus.$emit('set-lang', this.lang);
          var lang = e.currentTarget.dataset.lang;

          if (lang) {
            document.cookie = "selectedLanguage=".concat(lang, "; path=/; max-age=31536000;");
          }
        }
      },
      mounted: function mounted() {// this.lang = this.$el.getAttribute('href').slice(1).toLowerCase();
        // this.isActive = this.activeLang == this.lang ? true : false;
      }
    });

    new _vueMin["default"]({
      el: ".top-bar",
      store: _store["default"]
    }).$mount(".top-bar", true);
  };

  if (topBar) {
    MenuTopBarConstructor();
  }
};

var _default = MenuTopBar;
exports["default"] = _default;

},{"./event-bus":9,"./store":51,"vue/dist/vue.min.js":234}],24:[function(require,module,exports){
"use strict";

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _meterSelectorButtonSet = _interopRequireDefault(require("shared/meter-selector-button-set.hbs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

_vueMin["default"].component("ms-button-set", {
  props: {
    buttons: Array,
    multiple: {
      type: Boolean,
      "default": false
    },
    ovalButton: {
      type: Boolean,
      "default": false
    },
    onChange: Function,
    disabledMessage: String,
    defaultValue: {
      type: Array,
      "default": []
    },
    onTriggerEvent: Function
  },
  data: function data() {
    var _this = this;

    return {
      values: this.buttons && this.buttons.map(function (v) {
        return !v.disabled && v.value;
      }).map(function (v) {
        return _this.defaultValue.indexOf(v) >= 0;
      })
    };
  },
  watch: {
    values: {
      immediate: true,
      handler: function handler(v) {
        var ctx = this;
        var value = v.reduce(function (o, e, i) {
          if (!e) {
            return o;
          }

          return [].concat(_toConsumableArray(o), [ctx.buttons[i]]);
        }, []);
        this.onChange && this.onChange(value);
      }
    }
  },
  computed: {},
  mounted: function mounted() {},
  beforeUnmount: function beforeUnmount() {},
  methods: {
    change: function change(i) {
      if (!this.multiple) {
        var values = [];
        values[i] = this.values[i];
        this.values = values;
      }

      this.onTriggerEvent({
        value: this.buttons[i]
      });
    }
  },
  template: _meterSelectorButtonSet["default"]
});

},{"shared/meter-selector-button-set.hbs":236,"vue/dist/vue.min.js":234}],25:[function(require,module,exports){
"use strict";

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _meterSelectorFrame = _interopRequireDefault(require("shared/meter-selector-frame.hbs"));

var _meterSelectorFrameSeparator = _interopRequireDefault(require("shared/meter-selector-frame-separator.hbs"));

var _meterSelectorFrameQuestion = _interopRequireDefault(require("shared/meter-selector-frame-question.hbs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

_vueMin["default"].component("ms-frame", {
  props: {
    isLateralBar: {
      type: Boolean,
      "default": false
    },
    transparent: {
      type: Boolean,
      "default": true
    },
    closeButtonLabel: String,
    buttonLabel: String,
    cancelButtonLabel: String,
    disableButton: {
      type: Boolean,
      "default": false
    },
    title: String,
    onCancel: Function,
    onClickButton: Function,
    hasParametersButton: {
      type: Boolean,
      "default": false
    },
    contactButton: Object,
    message: String,
    notice: String
  },
  data: function data() {
    return {
      isOpen: false
    };
  },
  watch: {
    isOpen: function isOpen(v) {
      var nameClass = 'ms-frame_opened-lateral-bar';
      var layerNameClass = 'ms-frame_mobile-layer';
      var body = document.querySelector('body');

      if (v) {
        body.classList.add(nameClass);
        var layer = document.createElement('div');
        layer.classList.add(layerNameClass);
        body.appendChild(layer);
      } else {
        var _layer = document.querySelector(".".concat(layerNameClass));

        _layer && body.removeChild(_layer);
        body.classList.remove(nameClass);
      }
    }
  },
  computed: {
    hasButton: function hasButton() {
      return Boolean(this.buttonLabel) && !Boolean(this.notice);
    },
    mobileButtonLabel: function mobileButtonLabel() {
      return this.closeButtonLabel;
    },
    hasContactButton: function hasContactButton() {
      return Boolean(this.contactButton);
    },
    hasButtons: function hasButtons() {
      return this.hasButton || this.hasContactButton;
    }
  },
  mounted: function mounted() {},
  beforeUnmount: function beforeUnmount() {},
  methods: {
    clickButton: function clickButton() {
      this.onClickButton && this.onClickButton();
    },
    open: function open() {
      this.isOpen = !this.isOpen;
    },
    cancel: function cancel() {
      this.onCancel && this.onCancel();
    }
  },
  template: _meterSelectorFrame["default"]
});

_vueMin["default"].component("ms-frame-separator", {
  props: {
    title: String
  },
  template: _meterSelectorFrameSeparator["default"]
});

_vueMin["default"].component("ms-frame-question", {
  props: {
    index: Number,
    options: {
      type: Object,
      "default": {}
    },
    value: Object,
    selectedUnit: String,
    onTriggerEvent: Function
  },
  data: function data() {
    return {
      defaultValue: this.value
    };
  },
  computed: {
    showTitle: function showTitle() {
      return this.options.button && this.index > 0 && this.options.question;
    },
    dropdownOptions: function dropdownOptions() {
      return this.options.dropdown;
    },
    input: function input() {
      var inputs = this.options.input;

      if (!inputs) {
        return null;
      }

      var input = inputs[0];
      return {
        title: input.label,
        placeholder: input.placeholder
      };
    },
    defaultValues: function defaultValues() {
      if (this.options.button) {
        if (!this.defaultValue || !this.defaultValue.value) {
          return [];
        }

        return _typeof(this.defaultValue.value) === 'object' ? this.defaultValue.value : [this.defaultValue.value];
      } else {
        if (!this.defaultValue || !this.defaultValue.inputValue) {
          var def = {};

          if (this.selectedUnit && this.options.options) {
            def.switcher = {
              value: this.selectedUnit
            };
          }

          return def;
        }

        return this.defaultValue.inputValue;
      }
    },
    key: function key() {
      return this.options.apiQuery.join();
    }
  },
  methods: {
    onChange: function onChange(v) {
      var _this$options = this.options,
          index = _this$options.index,
          id = _this$options.stepId,
          apiQuery = _this$options.apiQuery,
          _this$options$filterN = _this$options.filterName,
          label = _this$options$filterN === void 0 ? '' : _this$options$filterN;
      var input = null;

      if (this.options.button) {
        var value = v.map(function (o) {
          return o.value;
        });
        var notice = (v.find(function (o) {
          return Boolean(o.selectedLabel);
        }) || {}).selectedLabel || '';
        var queryName = apiQuery && apiQuery[0];

        var query = _defineProperty({}, queryName, value.length === 1 ? value[0] : value);

        input = value.length === 0 ? null : {
          index: index,
          id: id,
          value: value,
          query: query,
          notice: notice,
          label: label
        };
      } else {
        var inputValue = v.input,
            dropdown = v.dropdown,
            switcher = v.switcher;
        var hasInput = Boolean(this.options.input);
        input = {
          value: inputValue,
          inputValue: v,
          option: switcher,
          label: label
        };

        var _queryName = apiQuery && apiQuery[0];

        var _query2 = _defineProperty({}, _queryName, input.value);

        if (apiQuery && apiQuery.length > 1 && (switcher || dropdown)) {
          var unitName = apiQuery[apiQuery.length - 1];
          _query2[unitName] = dropdown ? dropdown.value : switcher.value;
        }

        var isEmpty = input.value === '' || input.value === undefined || input.value === null;
        input = !isEmpty ? _objectSpread(_objectSpread({}, input), {}, {
          index: index,
          id: id,
          query: _query2
        }) : null;
      }

      this.$emit('input', input);
    },
    onTriggerAnswerEvent: function onTriggerAnswerEvent(data) {
      this.onTriggerEvent(_objectSpread(_objectSpread({}, data), {}, {
        questionIndex: this.index
      }));
    }
  },
  template: _meterSelectorFrameQuestion["default"]
});

},{"shared/meter-selector-frame-question.hbs":238,"shared/meter-selector-frame-separator.hbs":239,"shared/meter-selector-frame.hbs":240,"vue/dist/vue.min.js":234}],26:[function(require,module,exports){
"use strict";

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _meterSelectorInputBox = _interopRequireDefault(require("shared/meter-selector-input-box.hbs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

_vueMin["default"].component("ms-input-box", {
  props: {
    title: String,
    description: String,
    switcher: Object,
    input: Object,
    dropdown: Object,
    dropdownOptions: Array,
    onChange: Function,
    defaultValue: {
      type: Object,
      "default": {}
    },
    onTriggerEvent: Function
  },
  data: function data() {
    var data = {
      switcherValue: false,
      dropdownValue: '',
      inputValue: '',
      switcherField: this.switcher,
      inputField: this.input,
      changingMemo: this.defaultValue,
      inputErrorMessage: null,
      taggingInputValue: ''
    };

    if (this.defaultValue.switcher) {
      data.switcherValue = this.switcher.right.value === this.defaultValue.switcher.value;
    }

    if (this.defaultValue.dropdown) {
      data.dropdownValue = this.defaultValue.dropdown.value;
    }

    if (this.defaultValue.input) {
      data.inputValue = this.defaultValue.input.toString();
    }

    data.taggingInputValue = data.inputValue;
    return data;
  },
  watch: {
    switcherValue: {
      handler: function handler(v, a) {
        if (!this.switcherField) {
          return;
        }

        var option = v ? this.switcher.right : this.switcher.left;
        this.changingMemo = _objectSpread(_objectSpread({}, this.changingMemo), {}, {
          switcher: option
        });

        if ((a !== undefined || this.dropdownValue === '') && option && this.dropdownOptions) {
          if (this.dropdownOptions[option.value]) {
            var dropdownOption = this.dropdownOptions[option.value][0] || {};
            this.dropdownValue = dropdownOption.value || '';
          }
        }
      },
      immediate: true
    },
    dropdownValue: {
      handler: function handler(v) {
        if (!this.dropdownField) {
          return;
        }

        this.changingMemo = _objectSpread(_objectSpread({}, this.changingMemo), {}, {
          dropdown: this.dropdownField.options.find(function (o) {
            return o.value === v;
          })
        });
      },
      immediate: true
    },
    inputValue: {
      handler: function handler(v) {
        if (!this.inputField) {
          return;
        }

        var _this$input = this.input,
            noNegative = _this$input.noNegative,
            _this$input$decimals = _this$input.decimals,
            decimals = _this$input$decimals === void 0 ? 2 : _this$input$decimals;
        var dashes = 0;
        var points = 0;
        var value = v.replace(/[^0-9.]|\./g, function ($0) {
          if (!noNegative && $0 === '-' && v.indexOf('-') === 0 && !dashes++ || decimals > 0 && $0 === '.' && !points++) {
            return $0;
          }

          return '';
        });
        var dp = value.indexOf('.');

        if (dp > -1) {
          var diff = value.length - dp - 1 - decimals;

          if (diff > 0) {
            value = value.substring(0, value.length - diff);
          }
        }

        var numericValue = parseFloat(value);
        this.inputErrorMessage = null;

        if (this.input.validation) {
          var _this$input$validatio = this.input.validation,
              error = _this$input$validatio.error,
              _this$input$validatio2 = _this$input$validatio.min,
              min = _this$input$validatio2 === void 0 ? null : _this$input$validatio2,
              max = _this$input$validatio.max;

          if (min !== null && min > value || max && max < value) {
            this.inputErrorMessage = error;
          }
        }

        this.inputValue = value;
        this.changingMemo = _objectSpread(_objectSpread({}, this.changingMemo), {}, {
          input: value === '' ? '' : parseFloat(value)
        });
      },
      immediate: true
    },
    changingMemo: function changingMemo(v) {
      this.hasChange();
    },
    taggingValue: function taggingValue() {
      this.onTriggerEvent({
        value: this.taggingValue
      });
    }
  },
  computed: {
    taggingValue: function taggingValue() {
      return this.taggingInputValue + (this.option ? ' ' + (this.option.label || this.option.value) : '');
    },
    dropdownField: function dropdownField() {
      if (!this.dropdownOptions) {
        return null;
      }

      var option = (this.switcherValue ? this.switcher.right : this.switcher.left) || {};
      return {
        options: this.dropdownOptions[option.value] || []
      };
    },
    inputTitle: function inputTitle() {
      var ctx = this;
      return {
        props: {
          option: Object
        },
        template: "<span>".concat(ctx.inputField.title, "</span>")
      };
    },
    option: function option() {
      return this.dropdownField ? this.changingMemo.dropdown : this.changingMemo.switcher;
    }
  },
  mounted: function mounted() {
    this.hasChange();
  },
  beforeUnmount: function beforeUnmount() {},
  methods: {
    hasChange: function hasChange() {
      this.onChange && this.onChange(this.changingMemo);
    },
    onBlurInput: function onBlurInput() {
      this.taggingInputValue = this.inputValue;
    }
  },
  template: _meterSelectorInputBox["default"]
});

},{"shared/meter-selector-input-box.hbs":241,"vue/dist/vue.min.js":234}],27:[function(require,module,exports){
"use strict";

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _meterSelectorStepBar = _interopRequireDefault(require("shared/meter-selector-step-bar.hbs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

_vueMin["default"].component("ms-step-bar", {
  props: {
    steps: Array,
    onChange: Function,
    current: Number,
    selectedValues: {
      type: Array,
      "default": []
    },
    offset: {
      type: Number,
      "default": 50
    }
  },
  data: function data() {
    return {
      rootClasses: {
        'noCenterAlign': true
      },
      onResizeFlag: false,
      isMouseDown: false
    };
  },
  watch: {
    current: {
      handler: function handler() {
        this.onResize();
      },
      immediate: true
    },
    steps: {
      handler: function handler() {
        this.onResizeFlag = true;
      },
      immediate: true
    }
  },
  computed: {
    getSteps: function getSteps() {
      var ctx = this;
      return this.steps.map(function (s, i) {
        var classes = {
          'ms-step-bar_item': true,
          'ms-step-bar_item--selected': i === ctx.current,
          'ms-step-bar_item--checked': i <= ctx.maxStep
        };
        return _objectSpread(_objectSpread({}, s), {}, {
          selectedValue: ctx.selectedValues[i],
          classes: classes
        });
      });
    },
    maxStep: function maxStep() {
      return this.selectedValues && this.selectedValues.length || 0;
    }
  },
  mounted: function mounted() {
    window.addEventListener('resize', this.onResize);
    this.$refs.list.addEventListener('touchstart', this.startDrag);
    this.$refs.list.addEventListener('mousedown', this.startDrag);
    document.addEventListener('mouseup', this.endDrag);
    document.addEventListener('touchend', this.endDrag);
    document.addEventListener('mousemove', this.moveDrag);
    document.addEventListener('touchmove', this.moveDrag);
  },
  beforeUnmount: function beforeUnmount() {
    window.removeEventListener('resize', this.onResize);
    this.$refs.list.removeEventListener('touchstart', this.startDrag);
    this.$refs.list.removeEventListener('mousedown', this.startDrag);
    document.removeEventListener('mouseup', this.endDrag);
    document.removeEventListener('touchend', this.endDrag);
    document.removeEventListener('mousemove', this.moveDrag);
    document.removeEventListener('touchmove', this.moveDrag);
  },
  updated: function updated() {
    if (this.onResizeFlag) {
      this.onResize();
      this.onResizeFlag = false;
    }
  },
  methods: {
    onResize: function onResize() {
      var diff = 0;
      var w = window.innerWidth;
      var list = this.$refs.list;
      var children = list && list.childNodes || [];
      var last = children[children.length - 1];
      var end = last ? last.offsetWidth + last.offsetLeft + this.offset : 0;

      if (w < end) {
        var ldiff = (end - w) * -1;
        var mw = w / 2;
        var selected = children[this.current];
        var selectedEnd = selected && selected.offsetWidth + selected.offsetLeft;

        if (selected && mw < selectedEnd) {
          diff = (selectedEnd - mw) * -1;
        }

        if (ldiff > diff) {
          diff = ldiff;
        }
      }

      if (list) {
        list.style.transform = "translateX(".concat(diff, "px)");
      }

      this.rootClasses = _objectSpread(_objectSpread({}, this.rootClasses), {}, {
        'noCenterAlign': end === 0 ? true : w < end
      });
    },
    hasSelectedValue: function hasSelectedValue(i) {
      return this.selectedValues && this.selectedValues[i];
    },
    reset: function reset() {
      var defaultCurrent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.onChange && this.onChange(defaultCurrent);
    },
    onClickStep: function onClickStep(i) {
      if (i > this.maxStep) {
        return;
      }

      this.onChange && this.onChange(i);
    },
    startDrag: function startDrag() {
      this.isMouseDown = true;
    },
    endDrag: function endDrag() {
      this.isMouseDown = false;
    },
    moveDrag: function moveDrag(e) {
      var elm = this.$refs.list;

      if (!elm || !this.isMouseDown) {
        return;
      }

      var clientX = e.clientX || (e.touches[0] || e.changedTouches[0] || {}).pageX;

      if (elm.previousClientX !== undefined) {
        var diff = clientX - elm.previousClientX;
        var styleFound = elm.style.transform.match(/translateX\((.*)px\)/i) || [];
        var x = styleFound[1] ? parseInt(styleFound[1]) : 0;
        var children = elm.childNodes || [];
        var last = children[children.length - 1];
        var w = window.innerWidth;
        var end = last ? last.offsetWidth + last.offsetLeft + this.offset : 0;
        var maxX = (end - w) * -1;
        var add = 10;
        var nx = x;

        if (diff > 0) {
          nx = x + add;

          if (nx > 0) {
            nx = 0;
          }
        } else if (diff < 0 && maxX < 0) {
          nx = x - add;

          if (nx < maxX) {
            nx = maxX;
          }
        }

        var transformStyle = "translateX(".concat(nx, "px)");

        if (styleFound[0]) {
          elm.style.transform = elm.style.transform.replace(styleFound[0], transformStyle);
        } else {
          elm.style.transform += transformStyle + ';';
        }
      }

      elm.previousClientX = clientX;
    }
  },
  template: _meterSelectorStepBar["default"]
});

},{"shared/meter-selector-step-bar.hbs":245,"vue/dist/vue.min.js":234}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debounce = debounce;
exports.getCookieValue = getCookieValue;
exports.getUrlParameter = void 0;

/*
    Debounce is a decorator function that returns a function, that,
    as long as it continues be invoked, will not be triggered.
    The function will be called after it stops being called for N milliseconds (set in the 'wait' parameter). 
*/
function debounce(func, wait) {
  var timeout;
  return function () {
    var context = this;
    var args = arguments;

    var later = function later() {
      timeout = null;
      func.apply(context, args);
    };

    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

; // get value of url param by name

var getUrlParameter = function getUrlParameter(sParam) {
  var sPageURL = window.location.search.substring(1),
      sURLVariables = sPageURL.split('&'),
      sParameterName,
      i;

  for (i = 0; i < sURLVariables.length; i++) {
    sParameterName = sURLVariables[i].split('=');

    if (sParameterName[0] === sParam) {
      return sParameterName[1] === undefined ? true : decodeURIComponent(sParameterName[1]);
    }
  }
}; // get cookie value by name


exports.getUrlParameter = getUrlParameter;

function getCookieValue(a) {
  var b = document.cookie.match('(^|;)\\s*' + a + '\\s*=\\s*([^;]+)');
  return b ? b.pop() : '';
}

},{}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trigger = exports.instance = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _modals = require("./modals");

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _store = _interopRequireDefault(require("./store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

_vueMin["default"].use(_vueJsModal["default"]);

var instance = new _vueMin["default"]({
  methods: {
    triggerContactTooltip: function triggerContactTooltip() {
      _eventBus["default"].$emit('toggle-contact');
    },
    triggerForm: function triggerForm(data) {
      this.$modal.show(_modals.formModal.template(data.content), _modals.formModal.name(data.name), _modals.formModal.options(data.options), _modals.formModal.events(data.data));
    },
    triggerExit: function triggerExit(data) {
      this.$modal.show(_modals.exitModal.template(data), _modals.exitModal.name, _modals.exitModal.options, _modals.exitModal.events);
    },
    closeModal: function closeModal(name) {
      // this.$modal.hide(name);
      this.$modal.hideAll();
    }
  }
});
exports.instance = instance;

var trigger = function trigger() {
  document.addEventListener('click', function (e) {
    if (e.target.getAttribute('href')) {
      var hrefHash = e.target.getAttribute('href').split("#")[1];

      if (hrefHash === "contactustip") {
        e.preventDefault();
        instance.triggerContactTooltip();
      }

      if (window.modalHashtags) {
        window.modalHashtags.forEach(function (item) {
          if (hrefHash === item.hashtagname) {
            e.preventDefault();
            var downloadUrl = e.target.dataset.downloadUrl || null;
            var downloadName = e.target.dataset.downloadName || null;
            var selectedProducts = e.target.dataset.quoteProducts || null;
            var literatureOrdered = e.target.dataset.literatureOrdered || null;
            var content = e.target.dataset.content || null;
            var comments = e.target.dataset.comments || null;

            if (comments || selectedProducts || literatureOrdered || downloadUrl || downloadName) {
              instance.triggerForm({
                content: {
                  url: downloadUrl && downloadUrl !== "" ? "".concat(item.url, "?redirect_url=").concat(downloadUrl) : item.url,
                  copy: "".concat(content ? content : "")
                },
                name: item.hashtagname,
                options: {
                  "classes": "bmi-modal bmi-modal--form bmi-modal--".concat(item.hashtagname)
                },
                data: {
                  product_selections: selectedProducts,
                  modalName: item.hashtagname,
                  downloadName: downloadName,
                  literatureOrdered: literatureOrdered,
                  comments: comments
                }
              });
            } else {
              instance.triggerForm({
                content: {
                  url: item.url,
                  copy: "".concat(content ? content : "")
                },
                name: item.hashtagname,
                options: {
                  "classes": "bmi-modal bmi-modal--form bmi-modal--".concat(item.hashtagname)
                }
              });
            }
          }
        });
      }

      if (window.leavingSite) {
        var data = {
          "copy": window.leavingSite.modalContent,
          "ok": window.leavingSite.okLabel,
          "close": window.leavingSite.closeLabel
        };
        var link = e.target.getAttribute('href');
        var target = e.target;
        var modal = document.querySelector('.bmi-modal--exit');
        window.leavingSite.sites.forEach(function (site) {
          if (modal && modal.contains(target)) {
            return;
          } else if (link.includes("".concat(site))) {
            e.preventDefault();
            data = _objectSpread(_objectSpread({}, data), {}, {
              "link": link
            });
            instance.triggerExit(data);
          } else {
            return;
          }
        });
      }
    } else {
      return;
    }
  }); // window.modalHashtags = [
  //     {
  //         "hashtagname": "requestaquote",
  //         "url": "https://info.badgermeter.com/l/665843/2020-07-06/zg4q"
  //     },
  //     {
  //         "hashtagname": "generictest",
  //         "url": "https://info.badgermeter.com/l/665843/2020-07-06/zg4q"
  //     },
  //     {
  //         "hashtagname": "test",
  //         "url": "https://info.badgermeter.com/l/665843/2020-07-06/zgbs"
  //     },
  //     {
  //         "hashtagname": "redirecttest",
  //         "url": "https://info.badgermeter.com/l/665843/2020-07-06/zg68"
  //     },
  //     {
  //         "hashtagname": "literatureorder",
  //         "url": "https://info.badgermeter.com/l/665843/2020-09-08/24bst"
  //     }, 
  //     { 
  //         "hashtagname": "requestdownloadfirmware",
  //         "url": "https://info.badgermeter.com/l/665843/2020-09-08/24bst"
  //     },
  //     { 
  //         "hashtagname": "requestdownload",
  //         "url": "https://info.badgermeter.com/l/665843/2020-07-06/zg4q"
  //     },
  //     { 
  //         "hashtagname": "downloadhref",
  //         "url": "https://info.badgermeter.com/l/665843/2020-11-10/28nsn"
  //     },
  //     { 
  //         "hashtagname": "testsizing",
  //         "url": "https://info.badgermeter.com/l/665843/2020-07-06/zg68"
  //     }
  // ];
  // window.leavingSite = {"modalContent":"This is a dialog for <strong>leaving</strong> the site.  <br />Byee!!!!","okLabel":"OK","closeLabel":"Close","sites":["www.google.com","www.payday.com", "secure.directbiller.com"]};
}; // export default trigger;


exports.trigger = trigger;

},{"./event-bus":9,"./modals":30,"./store":51,"vue-js-modal":233,"vue/dist/vue.min.js":234}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exitModal = exports.genericModal = exports.formModal = exports.tooltipModal = exports.patentsModal = exports.infoModal = exports.quickLinksModal = exports.applicationsModal = exports.releaseNotesModal = exports.videoModal = void 0;

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var defaultOptions = {
  height: "auto",
  scrollable: false,
  adaptive: true,
  focusTrap: true,
  classes: "bmi-modal",
  width: "786px"
};

var defaultTemplate = function defaultTemplate(content, tagName) {
  return {
    template: "\n    <div class=\"bmi-modal__wrapper\" data-tag-trigger=\"visible\" data-tag-meta='{\"type\": \"overlay\", \"title\": \"".concat(tagName ? tagName : "Contextual Overlay", "\", \"name\": \"Contextual Overlay\", \"no\": \"01\"}'>\n        <button class=\"bmi-modal__close\" @click=\"$emit('close')\"></button>\n\n        <div class=\"bmi-modal__row\">\n            <div class=\"bmi-modal__area bmi-modal__area-body\">\n                ").concat(content, "\n            </div>\n        </div>\n    </div>\n    ")
  };
};

var videoTemplate = function videoTemplate(id, title) {
  return {
    template: "\n        <div class=\"bmi-modal__wrapper\" data-tag-trigger=\"visible\" data-tag-meta='{\"type\": \"overlay\", \"title\": \"Video Overlay\", \"name\": \"Contextual Overlay\", \"no\": \"01\"}'>\n        <button class=\"bmi-modal__close\" @click=\"$emit('close')\"></button>\n            <div class=\"bmi-modal__content\">\n                ".concat(title ? "<p class=\"bmi-modal__video-title\">".concat(title, "</p>") : "", "\n                <div class=\"bmi-modal__video-container\">\n                    <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/").concat(id, "\" frameborder=\"0\"\n                    allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\"\n                    allowfullscreen></iframe>\n                </div>\n            </div>\n        </div>\n    ")
  };
};

var modalConstructor = function modalConstructor(Template, Name, Options, Events) {
  return {
    template: Template,
    name: {
      name: Name
    },
    options: _objectSpread(_objectSpread({
      name: Name
    }, defaultOptions), Options),
    events: Events
  };
};

var videoModal = modalConstructor(function (id, title) {
  return videoTemplate(id, title);
}, "video", {
  classes: 'bmi-modal bmi-modal--video'
});
exports.videoModal = videoModal;
var releaseNotesModal = modalConstructor(function (content) {
  return defaultTemplate("".concat(content), 'Release Notes Overlay');
}, "releaseNotes", {
  classes: 'bmi-modal bmi-modal--release-notes'
});
exports.releaseNotesModal = releaseNotesModal;
var applicationsModal = modalConstructor(defaultTemplate('', 'Market Applications Overlay'), "applications", {
  classes: 'bmi-modal bmi-modal--applications'
}, function (apps) {
  return {
    'opened': function opened() {
      // console.log("before open");
      var container = document.querySelector('.bmi-modal--applications .bmi-modal__area-body');
      container.appendChild(apps);
    }
  };
});
exports.applicationsModal = applicationsModal;
var quickLinksModal = modalConstructor(defaultTemplate('', 'Quick Links Overlay'), "quickLinks", {
  classes: 'bmi-modal bmi-modal--quick-links'
}, function (links) {
  return {
    'opened': function opened() {
      // console.log("before open");
      var container = document.querySelector('.bmi-modal--quick-links .bmi-modal__area-body');
      container.appendChild(links);
    }
  };
});
exports.quickLinksModal = quickLinksModal;
var patentsModal = modalConstructor(defaultTemplate('', 'Patents Overlay'), "patents", {
  classes: 'bmi-modal bmi-modal--patents'
}, function (content) {
  return {
    'opened': function opened() {
      // console.log("before open");
      // console.log(content);
      var container = document.querySelector('.bmi-modal--patents .bmi-modal__area-body');
      container.appendChild(content);
    }
  };
});
exports.patentsModal = patentsModal;
var tooltipModal = modalConstructor(function (content) {
  return defaultTemplate("".concat(content), 'Tooltip Overlay');
}, "tooltip", {
  classes: 'bmi-modal bmi-modal--tooltip'
});
exports.tooltipModal = tooltipModal;
var formModal = {
  template: function template(content) {
    return defaultTemplate("".concat(content.copy ? "\n            <div class=\"bmi-modal__copy\">\n                ".concat(content.copy, "\n            </div>\n            ") : "", "\n            <div class=\"bmi-modal__form\">\n            <iframe src=\"").concat(content.url, "\" width=\"100%\" height=\"500\" type=\"text/html\" frameborder=\"0\" allowTransparency=\"true\" style=\"border: 0\"></iframe>\n            </div>"), 'Form Overlay');
  },
  name: function name(value) {
    return {
      "name": value
    };
  },
  options: function options(data) {
    return _objectSpread(_objectSpread({}, defaultOptions), {}, {
      classes: 'bmi-modal bmi-modal--form'
    }, data);
  },
  events: function events(data) {
    return {
      'opened': function opened() {
        var id = _store["default"].state.GAID;
        var iframe = document.querySelector(".bmi-modal__form iframe");
        var src = document.querySelector(".bmi-modal__form iframe").getAttribute('src');

        var paramData = _objectSpread(_objectSpread({}, data), {}, {
          GAID: id
        });

        window.addEventListener("message", function (event) {
          // console.log(event);
          if (event.origin == "https://info.badgermeter.com") {
            sizeIframe(event);
            postData(event);
            receiveData(event);
          }
        });

        var postData = function postData(event) {
          if (iframe.contentWindow) {
            iframe.contentWindow.postMessage(JSON.stringify(paramData), '*');
          } else {
            iframe.onload = function () {
              iframe.contentWindow.postMessage(JSON.stringify(paramData), '*');
            };
          }
        };

        var sizeIframe = function sizeIframe(event) {
          try {
            var _data = _typeof(event.data) === 'object' ? event.data : JSON.parse(event.data); // console.log(data);


            if (_data.form) {
              if (src.includes(_data.form)) {
                iframe.style.height = "".concat(_data.content + 20, "px");
              }
            }
          } catch (e) {
            console.log("Unexpected message", e);
          }
        };

        var receiveData = function receiveData(event) {
          try {
            var eventData = _typeof(event.data) === 'object' ? event.data : JSON.parse(event.data);
            eventData = _objectSpread({
              eventData: eventData
            }, data);

            if (eventData.eventData.submit) {
              // emit submitted event whenever a form is submitted
              _eventBus["default"].$emit('form-submitted', eventData);
            }
          } catch (e) {
            console.log("Unexpected message", e);
          }
        };
      },
      'closed': function closed() {
        // emit form closed event whenever form is closed
        _eventBus["default"].$emit('form-closed', data);
      }
    };
  }
};
exports.formModal = formModal;
var infoModal = modalConstructor(function (title, content) {
  return defaultTemplate("\n        <h2 class=\"bmi-modal__title\">\n            ".concat(title, "\n        </h2>\n        <div class=\"bmi-modal__copy\">\n            ").concat(content, "\n        </div>\n    "), 'Info Overlay');
}, "contact", {
  width: 'none',
  height: 'none',
  shiftY: 0,
  classes: 'bmi-modal bmi-modal--info'
}, {
  opened: function opened() {
    var body = document.querySelector("body");
    body.classList.add('bmi-modal__body');
  },
  closed: function closed() {
    var body = document.querySelector("body");
    body.classList.remove('bmi-modal__body');
  }
});
exports.infoModal = infoModal;
var genericModal = modalConstructor(function (content) {
  return defaultTemplate(content, "Content Overlay");
}, "generic", {
  classes: 'bmi-modal bmi-modal--generic'
});
exports.genericModal = genericModal;
var exitModal = modalConstructor(function (content) {
  return {
    template: "\n    <div class=\"bmi-modal__wrapper\" data-tag-trigger=\"visible\" data-tag-meta='{\"type\": \"overlay\", \"title\": \"External Link Overlay\", \"name\": \"Contextual Overlay\", \"no\": \"01\"}'>\n        <div class=\"bmi-modal__row\">\n            <div class=\"bmi-modal__area bmi-modal__area-body\">\n                ".concat(content.copy, "\n            </div>\n        </div>\n        <div class=\"bmi-modal__row\">\n            <div class=\"bmi-modal__area bmi-modal__area-buttons\">\n                <a href=\"").concat(content.link, "\" class=\"button primary-button\"><span class=\"button-text\"></span>").concat(content.ok, "<span class=\"button-icon\"></span></a>\n                <a href=\"#\" v-on:click.prevent=\"$emit('close')\" class=\"button secondary-button secondary-button--1\"><span class=\"button-text\"></span>").concat(content.close, "<span class=\"button-icon\"></span></a>\n            </div>\n        </div>\n    </div>\n    ")
  };
}, "exit", {
  classes: 'bmi-modal bmi-modal--exit'
});
exports.exitModal = exitModal;

},{"./event-bus":9,"./store":51}],31:[function(require,module,exports){
"use strict";

var _componentModule = _interopRequireDefault(require("lib/component-module"));

var _lory = require("lory.js");

var _misc = require("../misc");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

_componentModule["default"].AddModule('.affiliates', {
  prefix: 'affiliates-',
  components: [{
    name: 'template',
    data: function data() {
      return {
        lory: null,
        div: [],
        isMobile: null,
        totalSlides: null,
        currentSlide: 0,
        desc: null,
        isLast: false
      };
    },
    watch: {
      isMobile: function isMobile() {
        this.reset();
      }
    },
    methods: {
      initLory: function initLory() {
        var _this = this;

        this.lory = (0, _lory.lory)(this.$el, {
          classNameFrame: 'affiliates__content',
          classNameSlideContainer: 'affiliates__list',
          classNamePrevCtrl: 'affiliates__prev',
          classNameNextCtrl: 'affiliates__next',
          slidesToScroll: 1,
          enableMouseEvents: true
        });
        this.$el.addEventListener('after.lory.slide', function () {
          _this.currentSlide = _this.lory.returnIndex();
        }); // manually check for last slide because lory js
        // index doesn't work with variable width slides

        this.$el.querySelector('.affiliates__list').addEventListener('transitionend', function () {
          _this.checkLastSlide();
        });
        this.checkLastSlide();
      },
      resize: (0, _misc.debounce)(function () {
        this.checkLastSlide();
      }, 500),
      checkLastSlide: function checkLastSlide() {
        var containerOffset = parseInt(window.innerWidth - this.$el.querySelector('.affiliates__list-container').getBoundingClientRect().right);
        var lastSlideOffset = parseInt(window.innerWidth - this.$el.querySelector('.affiliates__list li:last-child').getBoundingClientRect().right); // 

        this.isLast = containerOffset == lastSlideOffset || lastSlideOffset >= containerOffset - 1 && lastSlideOffset <= containerOffset + 1 ? true : false;
      },
      setIsMobile: function setIsMobile() {
        var _this2 = this;

        var mql = window.matchMedia('(max-width: 650px)');
        this.isMobile = mql.matches ? true : false;
        mql.addEventListener('change', function () {
          _this2.isMobile = mql.matches ? true : false;
        });
      },
      reset: function reset() {
        if (this.isMobile) {
          this.$refs.desc.remove();
        } else {
          if (this.$refs.desc) {
            return;
          } else {
            this.$refs.list.prepend(this.desc);
          }
        }

        this.lory.setup();
      }
    },
    mounted: function mounted() {
      this.desc = this.$refs.desc;
      this.initLory();
      this.setIsMobile();
      this.reset();
      window.addEventListener("resize", this.resize);
    },
    unmounted: function unmounted() {
      window.removeEventListener("resize", this.resize);
    }
  }]
});

},{"../misc":28,"lib/component-module":2,"lory.js":223}],32:[function(require,module,exports){
"use strict";

var _componentModule = _interopRequireDefault(require("lib/component-module"));

var _fetcher = _interopRequireDefault(require("lib/fetcher"));

var _store = _interopRequireDefault(require("lib/store"));

var _howItWorks = require("lib/how-it-works");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

_componentModule["default"].AddModule('.find-distributor', {
  prefix: 'find-distributor-',
  components: [(0, _fetcher["default"])({
    name: 'template',
    data: function data() {
      return {
        list: {
          template: '<div><slot></slot></div>'
        },
        listVisible: false
      };
    },
    methods: {
      getDistributors: function getDistributors() {
        var self = this;

        if (this.params.country) {
          this.listVisible = true;
          this.fetch(function (res) {
            // const template = self.data;
            var template = res.data; // console.log("RES", res);

            self.list = {
              template: template,
              components: {
                'hiw-template': _objectSpread(_objectSpread({}, _howItWorks.template), {}, {
                  components: {
                    'hiw-tab-label': _howItWorks.tabLabel,
                    'hiw-content-template': _howItWorks.contentTemplate
                  }
                })
              }
            };
          }, {
            params: _objectSpread({}, this.params)
          });
        } else {
          this.listVisible = false;
        }
      }
    }
  }, {
    fetchOnUpdateParams: false
  })],
  store: _store["default"]
});

},{"lib/component-module":2,"lib/fetcher":10,"lib/how-it-works":17,"lib/store":51}],33:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _componentModule = _interopRequireDefault(require("../component-module"));

var _storageManager = _interopRequireWildcard(require("../storage-manager"));

var _misc = require("../misc");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var storageManager = (0, _storageManager["default"])(_storageManager.LocalStorageManager);
var GLOBAL_MESSAGE_SESSION = 'global-messsage';

var getNameSession = function getNameSession(id) {
  return GLOBAL_MESSAGE_SESSION + '#' + id;
};

var getTimesShowed = function getTimesShowed(id) {
  return parseInt(storageManager.get(getNameSession(id)) || 0);
};

var addTimeShowed = function addTimeShowed(id) {
  storageManager.addTimes(getNameSession(id));
};

_componentModule["default"].AddModule('.global-message', {
  prefix: 'global-message-',
  components: [{
    props: {
      showTimes: Number
    },
    name: 'template',
    data: function data() {
      return {
        isShow: false
      };
    },
    mounted: function mounted() {
      var _this = this;

      var el = this.$parent.$el;

      if (sessionStorage && el.className.includes("__show-times") && el.id) {
        var times = getTimesShowed(el.id);
        var showTimes = this.showTimes || 1;

        if (times >= showTimes) {
          return;
        } else {
          this.isShow = true;
          this.$nextTick(function () {
            _this.checkOneTrust();
          });
        }
      } else {
        this.isShow = true;
        this.$nextTick(function () {
          _this.checkOneTrust();
        });
      }
    },
    methods: {
      close: function close() {
        var el = this.$parent.$el;
        this.isShow = false;

        if (sessionStorage && el.className.includes("__show-times") && el.id) {
          addTimeShowed(el.id);
        }

        var event = new Event('closeGlobalAlert');
        el.dispatchEvent(event);
      },
      checkOneTrust: function checkOneTrust() {
        var _this2 = this;

        var oneTrustCookie = (0, _misc.getCookieValue)('OptanonAlertBoxClosed');
        console.log(this.$el);

        if (oneTrustCookie == '') {
          this.$el.style.display = 'none';
          this.$nextTick(function () {
            setTimeout(function () {
              _this2.init();
            }, 1000);
          });
        } else {
          this.$el.style.display = 'block';
        }
      },
      init: function init() {
        var _this3 = this;

        var close = document.querySelector('#onetrust-close-btn-container');
        var el = this.$parent.$el;
        var openEvent = new Event('openGlobalAlert');

        if (close) {
          close.addEventListener('click', function () {
            el.dispatchEvent(openEvent);
            _this3.$el.style.display = 'block';
          });
        }
      }
    }
  }]
});

},{"../component-module":2,"../misc":28,"../storage-manager":50}],34:[function(require,module,exports){
"use strict";

require("./recent-posts");

require("./my-saved-page");

require("./solution-area");

require("./meter-selector");

require("./global-message");

require("./find-distributor");

require("./affiliates");

require("./locations-map");

},{"./affiliates":31,"./find-distributor":32,"./global-message":33,"./locations-map":35,"./meter-selector":36,"./my-saved-page":37,"./recent-posts":38,"./solution-area":39}],35:[function(require,module,exports){
"use strict";

var _componentModule = _interopRequireDefault(require("lib/component-module"));

var _tippy = _interopRequireDefault(require("tippy.js"));

var _store = _interopRequireDefault(require("../store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

_componentModule["default"].AddModule('.locations-map', {
  prefix: 'locations-map-',
  components: [{
    name: 'template',
    data: function data() {
      return {
        region: 0,
        resizeTimeout: null,
        openedId: null,
        locations: [],
        regions: window.locationsMapData.regions,
        data: window.locationsMapData.locations,
        fullscreenTooltipContainer: null,
        store: _store["default"]
      };
    },
    computed: {
      isMobile: function isMobile() {
        return _store["default"].state.isMobile;
      }
    },
    watch: {
      locations: function locations() {
        var elms = this.$el.getElementsByClassName('locations-map__location-pin');

        for (var i = 0; i < elms.length; i++) {
          var e = elms[i];
          var l = this.locations[i];
        }
      },
      region: function region() {
        this.moveToRegion();
        this.calculatePosition();
      },
      openedId: function openedId() {
        if (this.openedId === null) {
          this.setContentTooltipReference(null);
        }
      },
      isMobile: function isMobile() {
        if (this.isMobile) {
          var map = this.$el.parentNode;
          map.style.removeProperty('height');
        }
      }
    },
    mounted: function mounted() {
      this.calculatePosition();
      window.addEventListener("resize", this.resize);
    },
    destroyed: function destroyed() {
      window.removeEventListener("resize", this.resize);
    },
    methods: {
      setContentTooltipReference: function setContentTooltipReference(content) {
        var body = document.querySelector('body');

        if (this.openedId === null && this.fullscreenTooltipContainer) {
          body.removeChild(this.fullscreenTooltipContainer);
          this.fullscreenTooltipContainer = null;
        }

        if (content === null) {
          return null;
        }

        var div = this.fullscreenTooltipContainer || document.createElement('div');
        body.appendChild(div);
        div.classList.add('locations-map__tooltip-fullscreen');
        div.appendChild(content);
        this.fullscreenTooltipContainer = div;
      },
      getPrefixCss: function getPrefixCss() {
        var styles = window.getComputedStyle(document.documentElement, ''),
            pre = (Array.prototype.slice.call(styles).join('').match(/-(moz|webkit|ms)-/) || styles.OLink === '' && ['', 'o'])[1],
            dom = 'WebKit|Moz|MS|O'.match(new RegExp('(' + pre + ')', 'i'))[1];
        return {
          dom: dom,
          lowercase: pre,
          css: '-' + pre + '-',
          js: pre[0].toUpperCase() + pre.substr(1)
        };
      },
      setStyleWithPrefix: function setStyleWithPrefix(el, style, value) {
        var _this$getPrefixCss = this.getPrefixCss(),
            css = _this$getPrefixCss.css;

        el.style[css + style] = value;
      },
      calculateDiff: function calculateDiff() {
        if (!this.isMobile) {
          this.calculateHeight();
        }

        var realWidth = 0;
        var realHeight = 0;
        var fullWidth = 1610;
        var fullHeight = 770;
        var fullRatio = fullWidth / fullHeight;
        var containerWidth = this.$el.parentElement.offsetWidth;
        var containerHeight = this.$el.parentElement.offsetHeight;
        var containerRation = containerWidth / containerHeight;

        if (containerRation > fullRatio) {
          realWidth = containerWidth;
          realHeight = containerWidth / fullRatio;
        } else {
          realWidth = containerHeight * fullRatio;
          realHeight = containerHeight;
        }

        return {
          w: realWidth,
          h: realHeight,
          x: realWidth / fullWidth,
          y: realHeight / fullHeight
        };
      },
      moveToRegion: function moveToRegion() {
        var l = 0;
        var t = 0;

        if (this.region !== null && window.innerWidth < 835) {
          var _this$calculateDiff = this.calculateDiff(),
              xDiff = _this$calculateDiff.x,
              yDiff = _this$calculateDiff.y,
              w = _this$calculateDiff.w;

          var region = this.regions[this.region];
          l = region.coordinates[0] * xDiff * -1;
          t = region.coordinates[1] * yDiff * -1;
          var offsetWidth = this.$el.parentElement.offsetWidth;
          var offsetHeight = this.$el.parentElement.offsetHeight;
          var minLeft = (w - offsetWidth) * -1;
          var minTop = (w - offsetHeight) * -1;

          if (l < minLeft) {
            l = minLeft;
          }

          if (t < minTop) {
            t = minTop;
          }
        }

        this.$el.parentElement.style['background-position'] = "".concat(l, "px ").concat(t, "px");
        this.$refs.locationsContainer.style.left = "".concat(l, "px");
        this.$refs.locationsContainer.style.top = "".concat(t, "px");
      },
      open: function open(id) {
        this.openedId = id;
      },
      resize: function resize() {
        var context = this;

        if (this.resizeTimeout) {
          clearTimeout(this.resizeTimeout);
        }

        this.resizeTimeout = setTimeout(function () {
          context.resizeTimeout = null;
          context.calculatePosition();
        }, 500);
        this.moveToRegion();
      },
      calculatePosition: function calculatePosition() {
        var _this$calculateDiff2 = this.calculateDiff(),
            xDiff = _this$calculateDiff2.x,
            yDiff = _this$calculateDiff2.y;

        var locations = [];
        this.data.forEach(function (i) {
          var _i$coordinates = _slicedToArray(i.coordinates, 2),
              l = _i$coordinates[0],
              t = _i$coordinates[1];

          var _top = Math.round(t * yDiff);

          var _left = Math.round(l * xDiff);

          locations.push(_objectSpread(_objectSpread({}, i), {}, {
            coordinates: ["".concat(_left, "px"), "".concat(_top, "px")]
          }));
        });
        this.locations = locations;
      },
      calculateHeight: function calculateHeight() {
        var fullWidth = 1610;
        var fullHeight = 770;
        var fullRatio = fullWidth / fullHeight;
        var windowWidth = window.innerWidth;
        var calcHeight = Math.round(windowWidth / fullRatio);
        var map = this.$el.parentNode;
        map.style.height = "".concat(calcHeight, "px");
      }
    },
    components: {
      'content-tooltip': {
        name: 'content-tooltip',
        props: ['id', 'data', 'open', 'isOpen', 'setContentTooltipReference'],
        data: function data() {
          return {
            tippyInstance: null,
            contentChild: null
          };
        },
        computed: {
          taggingMeta: function taggingMeta() {
            return JSON.stringify({
              "type": "layer",
              "category": "Preview Card",
              "action": "Open",
              "label": this.data.name
            });
          }
        },
        watch: {
          data: function data() {
            this.mobileMode();
            this.tippyInstance.setContent('');
          },
          isOpen: function isOpen() {
            this.mobileMode();
            this.tippyInstance.setContent('');

            if (this.isOpen) {
              // increase z-index of currently open tooltip
              var tippyTarget = document.querySelector("#tippy-".concat(this.id + 1));
              tippyTarget.style.zIndex = 100;
            }
          }
        },
        methods: {
          onOpen: function onOpen() {
            this.open(this.id);
          },
          onClose: function onClose() {
            this.open(null);
          },
          mobileMode: function mobileMode() {
            if (this.isOpen && window.innerWidth < 650) {
              this.setContentTooltipReference(this.contentChild);
            } else {
              this.setTooltipContent();
            }
          },
          setTooltipContent: function setTooltipContent() {
            this.tippyInstance.popper.querySelector('.tippy-content').appendChild(this.contentChild);
          }
        },
        mounted: function mounted() {
          var context = this;
          this.contentChild = this.$el.children[0];
          var instance = (0, _tippy["default"])(this.$el, {
            content: '',
            maxWidth: 'none',
            allowHTML: true,
            interactive: true,
            placement: this.data.placement,
            trigger: 'manual',
            zIndex: 99,
            onCreate: function onCreate(instance) {
              context.tippyInstance = instance;
              context.setTooltipContent();
              instance.show();
            },
            onHide: function onHide(instance) {
              return false;
            }
          });
        }
      }
    }
  }]
});

},{"../store":51,"lib/component-module":2,"tippy.js":232}],36:[function(require,module,exports){
"use strict";

var _qs = _interopRequireDefault(require("qs"));

var _componentModule = _interopRequireDefault(require("lib/component-module"));

var _fetcher = _interopRequireDefault(require("lib/fetcher"));

var _store = _interopRequireDefault(require("../store"));

var _modals = require("../modals");

require("lib/meter-selector/step-bar");

require("lib/meter-selector/input-box");

require("lib/meter-selector/button-set");

require("lib/meter-selector/frame");

var _meterSelectorContent = _interopRequireDefault(require("shared/meter-selector-content.hbs"));

var _meterSelectorPaginator = _interopRequireDefault(require("shared/meter-selector-paginator.hbs"));

var _meterSelectorProductItemV = _interopRequireDefault(require("shared/meter-selector-product-item-v.hbs"));

var _meterSelectorProductItemH = _interopRequireDefault(require("shared/meter-selector-product-item-h.hbs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

_componentModule["default"].AddModule('.meter-selector', {
  prefix: 'meter-selector-',
  components: [(0, _fetcher["default"])({
    props: {
      defaultCount: {
        type: Number,
        "default": 0
      },
      pageSize: {
        type: Number,
        "default": 12
      },
      requestQuoteButton: {
        type: String,
        "default": '[href="#meterselector"]'
      }
    },
    data: function data() {
      return {
        // global
        data: {},
        // results
        count: this.defaultCount,
        // questions
        steps: [],
        stepNumber: 0,
        answerMemo: [],
        questions: [],
        answerModel: [],
        disabledContinue: true,
        notice: '',
        debounce: null,
        stepValues: [],
        isResultsPage: false,
        tagStepFlag: false
      };
    },
    computed: {
      selectedUnit: function selectedUnit() {
        return _store["default"].state.units;
      },
      filters: function filters() {
        var _this2 = this;

        var filters = this.answerMemo.filter(function (_, i) {
          return i < _this2.stepNumber;
        }).reduce(function (a, aw) {
          if (!aw) {
            return a;
          }

          var query = aw.reduce(function (ae, e) {
            return _objectSpread(_objectSpread({}, ae), e.query);
          }, {});
          return _objectSpread(_objectSpread({}, a), query);
        }, {});
        return filters;
      },
      hasButtons: function hasButtons() {
        if (this.isResultsPage) {
          return false;
        }

        var questions = this.getQuestions(this.stepNumber);
        return Boolean(questions.find(function (q) {
          return q.button;
        }));
      },
      isTransparent: function isTransparent() {
        return this.isResultsPage || this.questions.length === 0 || this.hasButtons;
      },
      title: function title() {
        if (this.isResultsPage) {
          var _ref = this.data || {},
              title = _ref.title;

          return title;
        }

        var tab = this.getTab(this.stepNumber);
        return tab && tab.tabTitle || null;
      },
      message: function message() {
        if (!this.isResultsPage) {
          return null;
        }

        var _ref2 = this.data || {},
            content = _ref2.content;

        return content;
      },
      closeLabel: function closeLabel() {
        var results = this.data.searchResults || {};
        return results.CloseLabel;
      },
      nextLabel: function nextLabel() {
        var results = this.data.searchResults || {};

        if (this.isResultsPage) {
          return results.AdjustParamsLabel;
        }

        return results.NextLabel;
      },
      skipLabel: function skipLabel() {
        if (this.isResultsPage) {
          return null;
        }

        return this.data.searchResults && this.data.searchResults.SkipForNowLabel;
      },
      loadingMessage: function loadingMessage() {
        var results = this.data.searchResults || {};
        return results.LoadingLabel;
      },
      contactButton: function contactButton() {
        if (!this.isResultsPage) {
          return null;
        }

        return this.data.searchResults && {
          label: this.data.searchResults.ContactProductExpertLabel
        };
      }
    },
    watch: {
      isResultsPage: function isResultsPage() {
        if (!this.isResultsPage) {
          return;
        }

        var _this$data$tabs = this.data.tabs,
            tabs = _this$data$tabs === void 0 ? [] : _this$data$tabs;
        var answerMemo = this.answerMemo;
        var questions = tabs.reduce(function (a, t, it) {
          if (!t.questions) {
            return a;
          }

          var questions = t.questions.map(function (q, i) {
            return _objectSpread(_objectSpread({}, q), {}, {
              questionIndex: i,
              tabIndex: it
            });
          }).filter(function (q) {
            return !q.button;
          });
          return [].concat(_toConsumableArray(a), _toConsumableArray(questions));
        }, []);
        this.answerModel = questions.map(function (q, i) {
          var tabIndex = q.tabIndex,
              questionIndex = q.questionIndex,
              rest = _objectWithoutProperties(q, ["tabIndex", "questionIndex"]);

          return answerMemo[q.tabIndex] && answerMemo[q.tabIndex][q.questionIndex];
        });
        this.questions = questions;
      },
      answerModel: function answerModel(v) {
        if (this.isResultsPage) {
          this.changedAnswerMemoOnResultPage();
          this.disabledContinue = false;
          this.notice = '';
          return;
        }

        var _this$getTab = this.getTab(this.stepNumber),
            enableNextWhen = _this$getTab.enableNextWhen;

        var questions = this.getQuestions(this.stepNumber);

        if (!questions) {
          return [];
        }

        questions = questions.map(function (q, i) {
          return _objectSpread(_objectSpread({}, q), {}, {
            index: i
          });
        });
        var answers = this.answerModel.filter(function (a) {
          return a;
        });
        var answersValues = answers.reduce(function (o, a) {
          return _objectSpread(_objectSpread({}, o), {}, _defineProperty({}, a.id, a.value));
        }, {});
        this.questions = questions.filter(function (q) {
          if (!q.showIfQuestion) {
            return true;
          }

          var a = answersValues[q.showIfQuestion];
          return a && (typeof a === 'string' ? a === q.showIfValue : a.indexOf(q.showIfValue) >= 0);
        });
        var indexes = this.questions.map(function (q) {
          return q.index;
        });
        var filteredAnswers = answers.filter(function (a) {
          return indexes.indexOf(a.index) >= 0;
        });

        var _ref3 = enableNextWhen || {},
            _ref3$comparisonType = _ref3.comparisonType,
            comparisonType = _ref3$comparisonType === void 0 ? 'DEFAULT' : _ref3$comparisonType,
            _ref3$stepIds = _ref3.stepIds,
            stepIds = _ref3$stepIds === void 0 ? [] : _ref3$stepIds;

        if (comparisonType === 'ANY') {
          this.disabledContinue = !((filteredAnswers.find(function (a) {
            return stepIds.indexOf(a.id) >= 0;
          }) || false) && true);
        } else if (comparisonType === 'ALL') {
          this.disabledContinue = filteredAnswers.filter(function (a) {
            return stepIds.indexOf(a.id) >= 0;
          }).length !== stepIds.length;
        } else {
          this.disabledContinue = this.questions.length !== filteredAnswers.length;
        }

        this.notice = (filteredAnswers.find(function (a) {
          return a.notice;
        }) || {}).notice || '';
      },
      filters: {
        handler: function handler() {
          this.data = {
            loadingMessage: this.isResultsPage && this.loadingMessage
          };

          if (this.debounce) {
            clearTimeout(this.debounce);
          }

          if (!this.isResultsPage) {
            this.loadData();
          } else {
            this.debounce = setTimeout(this.loadData, 600);
          }
        },
        deep: true
      },
      data: {
        handler: function handler(d) {
          if (!d || !d.searchResults) {
            return;
          }

          var _ref4 = d.searchResults || {},
              TotalResults = _ref4.TotalResults,
              remaining = _ref4.remaining,
              ShowLastPage = _ref4.ShowLastPage;

          var tabs = d.tabs || []; // set the total number of found results

          if (TotalResults !== undefined) {
            this.count = TotalResults;
          } // for pagination


          !remaining && this.setData(d);
          this.steps = tabs.map(function (t) {
            return {
              label: t.tabTitleShort
            };
          });

          if (ShowLastPage) {
            this.stepNumber = this.steps.length;
          }

          this.isResultsPage = this.steps.length <= this.stepNumber;
          this.loadView();
        },
        deep: true
      },
      stepNumber: function stepNumber(i) {
        this.tagStepFlag = true;
        this.loadView();
      },
      stepAnswers: function stepAnswers(v) {}
    },
    created: function created() {
      var bars = document.querySelectorAll('.persistent-cta');

      for (var i = 0; i < bars.length; i++) {
        var e = bars[i];
        e.classList.add('persistent-cta--ms');
      }
    },
    updated: function updated() {
      if (this.isResultsPage) {
        this.triggerForm();
      }
    },
    methods: {
      // Fetchs the remote data
      loadData: function loadData() {
        var _this = this;

        var filters = _objectSpread({}, this.filters);

        this.fetch(function (response) {
          _this.setData(response.data || {});
        }, {
          params: _objectSpread(_objectSpread({}, this.params), {}, {
            page: this.page
          }, filters),
          paramsSerializer: function paramsSerializer(params) {
            return _qs["default"].stringify(params, {
              arrayFormat: 'repeat'
            });
          }
        });
      },
      // Pagination methods
      loadMore: function loadMore(e) {
        this.setData(this.data);
      },
      setData: function setData(data) {
        var _this3 = this;

        var _data$searchResults = data.searchResults,
            _data$searchResults$R = _data$searchResults.Results,
            Results = _data$searchResults$R === void 0 ? [] : _data$searchResults$R,
            remaining = _data$searchResults.remaining,
            _searchResults = _objectWithoutProperties(_data$searchResults, ["Results", "remaining"]),
            res = _objectWithoutProperties(data, ["searchResults"]);

        var searchResults = {};

        if (!remaining) {
          searchResults = _objectSpread({
            Results: _toConsumableArray(Results.filter(function (_, i) {
              return i < _this3.pageSize;
            })),
            remaining: Results.filter(function (_, i) {
              return i >= _this3.pageSize;
            })
          }, _searchResults);
          this.onTriggerStepEvent(data);
        } else {
          searchResults = _objectSpread({
            Results: [].concat(_toConsumableArray(Results), _toConsumableArray(remaining.filter(function (_, i) {
              return i < _this3.pageSize;
            }))),
            remaining: remaining.filter(function (_, i) {
              return i >= _this3.pageSize;
            })
          }, _searchResults);
        }

        this.data = _objectSpread(_objectSpread({}, res), {}, {
          searchResults: searchResults,
          nextPage: searchResults.remaining.length > 0
        });
      },
      // Step methods
      getTab: function getTab(stepNumber, data) {
        var tabs = data && data.tabs || this.data.tabs || [];
        return tabs[stepNumber] || {};
      },
      getQuestions: function getQuestions(stepNumber, data) {
        var tab = this.getTab(stepNumber, data);
        return tab.questions || [];
      },
      loadView: function loadView() {
        this.setStepValues();

        if (this.isResultsPage) {
          return;
        }

        this.answerModel = this.answerMemo[this.stepNumber] ? _toConsumableArray(this.answerMemo[this.stepNumber]) : [];
      },
      setStepValues: function setStepValues() {
        var _this4 = this;

        var tabs = this.data.tabs || [];

        if (tabs.length === 0) {
          return;
        }

        var answerMemo = this.answerMemo;
        this.stepValues = answerMemo.map(function (a, i) {
          var tab = tabs[i] || {};

          if (tab.tabValue) {
            return tab.tabValue;
          }

          if (i >= _this4.stepNumber) {
            return '';
          }

          if (!a) {
            return '';
          }

          var label = a.map(function (e) {
            if (_typeof(e.value) === 'object') {
              var _ref5 = _this4.data.searchResults || {},
                  _ref5$MoreLabel = _ref5.MoreLabel,
                  MoreLabel = _ref5$MoreLabel === void 0 ? '' : _ref5$MoreLabel;

              if (e.value.length <= 1) {
                return e.value.join();
              }

              var count = e.value.length - 1;
              return e.value[0] + " + ".concat(count, " ") + MoreLabel;
            }

            return e.value;
          }).join(' ');
          return label;
        });
      },
      onClickNextButton: function onClickNextButton() {
        var _this5 = this;

        var skip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (this.isResultsPage) {
          this.$refs.slideBar.open();
          return;
        }

        this.answerMemo = _toConsumableArray(this.answerMemo);
        var indexes = this.questions.map(function (q) {
          return q.index;
        });

        if (skip) {
          this.answerMemo[this.stepNumber] = this.questions.map(function (q) {
            return _this5.questionSkipResult(q);
          });
        } else {
          var anws = this.answerModel.reduce(function (a, e) {
            return !e ? a : _objectSpread(_objectSpread({}, a), {}, _defineProperty({}, e.index, e));
          }, {});
          this.answerMemo[this.stepNumber] = indexes.map(function (i) {
            return anws[i] || {};
          });
        }

        this.answerModel = [];
        this.stepNumber += 1;
      },
      onClickSkipButton: function onClickSkipButton() {
        this.onClickNextButton(true);
      },
      changeStepNumber: function changeStepNumber(stepNumber) {
        this.stepNumber = stepNumber;
      },
      changedAnswerMemoOnResultPage: function changedAnswerMemoOnResultPage() {
        var _this6 = this;

        var answerMemo = _toConsumableArray(this.answerMemo);

        this.questions.forEach(function (q, i) {
          var tabIndex = q.tabIndex,
              questionIndex = q.questionIndex,
              rest = _objectWithoutProperties(q, ["tabIndex", "questionIndex"]);

          if (!answerMemo[tabIndex]) {
            answerMemo[tabIndex] = [];
          }

          if (!_this6.answerModel[i]) {
            answerMemo[tabIndex][questionIndex] = _this6.questionSkipResult(q);
            return;
          }

          answerMemo[tabIndex][questionIndex] = _this6.answerModel[i];
        });
        this.answerMemo = answerMemo;
      },
      questionSkipResult: function questionSkipResult(q) {
        return {
          query: q.apiQuery.reduce(function (a, e) {
            return _objectSpread(_objectSpread({}, a), {}, _defineProperty({}, e, 'skip'));
          }, {})
        };
      },
      triggerTaggingEvent: function triggerTaggingEvent(data, type) {
        if (!data) {
          return;
        }

        var dataObject = _objectSpread({
          event: 'TF-Meter-Selection',
          type: 'tool',
          category: 'Meter Selector'
        }, data);

        try {
          if (type === 'immutable') {
            window.immutableDataLayerPush(dataObject);
          } else {
            window.customMutableDataLayerPush(dataObject);
          }
        } catch (err) {
          console.log('Analytics framework error: ', err);
        }
      },
      onTriggerQuestionEvent: function onTriggerQuestionEvent() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (!Number.isInteger(data.questionIndex)) {
          return;
        }

        if (!data || data.value === undefined) {
          return;
        } // tagging event


        var tab = this.getTab(this.stepNumber);
        var question = this.questions[data.questionIndex];
        var questionTitle = question.question || tab.tabTitle;
        var isButton = Boolean(question.button);
        this.triggerTaggingEvent({
          action: isButton ? questionTitle : question.filterName,
          label: isButton ? data.value.label : data.value,
          elementType: isButton ? 'button' : 'input'
        });
      },
      onTriggerStepEvent: function onTriggerStepEvent() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (!this.tagStepFlag) {
          return;
        }

        this.tagStepFlag = false; // tagging event

        var i = this.stepNumber;
        var stepNo = this.padStart(String(i + 1), 2);
        var matchCount = data.searchResults && this.padStart(String(data.searchResults.TotalResults), 3);

        if (i < this.steps.length) {
          this.triggerTaggingEvent({
            stepNo: stepNo,
            matchCount: matchCount,
            stepName: this.steps[i].label
          }, 'immutable');
        } else if (i >= this.steps.length) {
          this.triggerTaggingEvent({
            stepNo: stepNo,
            matchCount: matchCount,
            stepName: 'COMPLETE'
          }, 'immutable');
        }
      },
      padStart: function padStart(value) {
        var padSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        var n = String(value);

        while (n.length < padSize) {
          n = "0" + n;
        }

        return n;
      },
      triggerForm: function triggerForm() {
        var buttons = document.querySelectorAll(this.requestQuoteButton);
        var comments = this.answerMemo.reduce(function (a, o, i) {
          if (!o) {
            return a;
          }

          var qa = o.filter(function (e) {
            return Boolean(e.label);
          }).map(function (e) {
            return {
              label: e.label + (e.option && e.option.label ? ' in ' + e.option.label : ''),
              value: e.value
            };
          });
          return qa.length > 0 ? [].concat(_toConsumableArray(a), _toConsumableArray(qa)) : a;
        }, []);
        var commentsText = comments.filter(function (o) {
          return Boolean(o.value);
        }).map(function (o) {
          return o.label.toUpperCase() + ': ' + (Array.isArray(o.value) ? o.value.join(', ') : o.value.toString());
        }).join(' | ');

        for (var i = 0; i < buttons.length; i++) {
          var button = buttons[i];
          button.dataset.comments = commentsText;
        }
      }
    },
    components: {
      'meter-selector-paginator': {
        props: ['data', 'isShow'],
        template: _meterSelectorPaginator["default"]
      },
      'meter-selector-content': {
        props: ['data', 'count', 'isMatch', 'selectedUnit'],
        data: function data() {
          return {};
        },
        computed: {
          viewProductLabel: function viewProductLabel() {
            return this.data.searchResults.ViewProductLabel;
          },
          component: function component() {
            return this.isMatch && this.count === 1 ? 'product-item-h' : 'product-item-v';
          }
        },
        components: {
          "product-item-v": {
            props: ['item', 'selectedUnit', 'viewProductLabel'],
            template: _meterSelectorProductItemV["default"],
            components: {
              "bookmark": {
                props: ['item'],
                data: function data() {
                  return {
                    isBookmarked: false,
                    id: null,
                    type: null
                  };
                },
                computed: {
                  saved: function saved() {
                    return _store["default"].state.favorites["".concat(this.type)];
                  }
                },
                watch: {
                  saved: function saved() {
                    this.isBookmarked = this.saved.includes(this.id) ? true : false;
                  }
                },
                methods: {
                  handleBookmark: function handleBookmark() {
                    _store["default"].commit('updateFavorites', {
                      id: this.id,
                      type: this.type,
                      action: this.isBookmarked ? "remove" : "add"
                    });

                    _store["default"].dispatch('checkFavorites');
                  }
                },
                mounted: function mounted() {
                  this.id = this.$refs.bookmark.dataset.productId ? this.$refs.bookmark.dataset.productId : this.$refs.bookmark.dataset.articleId ? this.$refs.bookmark.dataset.articleId : this.$refs.bookmark.dataset.documentId ? this.$refs.bookmark.dataset.documentId : this.$refs.bookmark.dataset.softwareId ? this.$refs.bookmark.dataset.softwareId : null;
                  this.type = this.$refs.bookmark.dataset.productId ? "productId" : this.$refs.bookmark.dataset.articleId ? "articleId" : this.$refs.bookmark.dataset.documentId ? "documentId" : this.$refs.bookmark.dataset.softwareId ? "softwareId" : null;
                  this.isBookmarked = this.saved.includes("".concat(this.id)) ? true : false;
                }
              }
            }
          },
          "product-item-h": {
            props: ['item', 'selectedUnit', 'viewProductLabel'],
            template: _meterSelectorProductItemH["default"],
            components: {
              "bookmark": {
                props: ['item'],
                data: function data() {
                  return {
                    isBookmarked: false,
                    id: null,
                    type: null
                  };
                },
                computed: {
                  saved: function saved() {
                    return _store["default"].state.favorites["".concat(this.type)];
                  }
                },
                watch: {
                  saved: function saved() {
                    this.isBookmarked = this.saved.includes(this.id) ? true : false;
                  }
                },
                methods: {
                  handleBookmark: function handleBookmark() {
                    _store["default"].commit('updateFavorites', {
                      id: this.id,
                      type: this.type,
                      action: this.isBookmarked ? "remove" : "add"
                    });

                    _store["default"].dispatch('checkFavorites');
                  }
                },
                mounted: function mounted() {
                  this.id = this.$refs.bookmark.dataset.productId ? this.$refs.bookmark.dataset.productId : this.$refs.bookmark.dataset.articleId ? this.$refs.bookmark.dataset.articleId : this.$refs.bookmark.dataset.documentId ? this.$refs.bookmark.dataset.documentId : this.$refs.bookmark.dataset.softwareId ? this.$refs.bookmark.dataset.softwareId : null;
                  this.type = this.$refs.bookmark.dataset.productId ? "productId" : this.$refs.bookmark.dataset.articleId ? "articleId" : this.$refs.bookmark.dataset.documentId ? "documentId" : this.$refs.bookmark.dataset.softwareId ? "softwareId" : null;
                  this.isBookmarked = this.saved.includes("".concat(this.id)) ? true : false;
                }
              }
            }
          }
        },
        watch: {},
        template: _meterSelectorContent["default"]
      },
      'meter-selector-total': {
        props: ['count']
      }
    }
  })]
});

},{"../modals":30,"../store":51,"lib/component-module":2,"lib/fetcher":10,"lib/meter-selector/button-set":24,"lib/meter-selector/frame":25,"lib/meter-selector/input-box":26,"lib/meter-selector/step-bar":27,"qs":227,"shared/meter-selector-content.hbs":237,"shared/meter-selector-paginator.hbs":242,"shared/meter-selector-product-item-h.hbs":243,"shared/meter-selector-product-item-v.hbs":244}],37:[function(require,module,exports){
"use strict";

var _componentModule = _interopRequireDefault(require("lib/component-module"));

var _tabs = _interopRequireDefault(require("lib/tabs"));

var _mySavedPage = require("lib/template-strings/my-saved-page");

var _store = _interopRequireDefault(require("../store"));

var _eventBus = _interopRequireDefault(require("../event-bus"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _modals = require("./../modals");

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// import axios from "axios"
// import fpodb from '../../../../db.json';
_vueMin["default"].use(_vueJsModal["default"]);

_componentModule["default"].AddModule('.my-saved-page', {
  prefix: 'my-saved-page-',
  components: [(0, _tabs["default"])({
    data: function data() {
      return {
        savedIds: {
          products: [],
          documents: [],
          software: [],
          articles: [],
          legalDocuments: []
        }
      };
    },
    computed: {
      savedProducts: function savedProducts() {
        return _store["default"].state.favorites.productId;
      },
      savedDocuments: function savedDocuments() {
        return _store["default"].state.favorites.documentId;
      },
      savedSoftware: function savedSoftware() {
        return _store["default"].state.favorites.softwareId;
      },
      savedArticles: function savedArticles() {
        return _store["default"].state.favorites.articleId;
      },
      savedLegalDocuments: function savedLegalDocuments() {
        return _store["default"].state.favorites.legalDocumentId;
      }
    },
    watch: {
      savedProducts: function savedProducts() {
        this.savedIds.products = this.savedProducts[0] == "" ? this.savedProducts.shift() : this.savedProducts;
      },
      savedDocuments: function savedDocuments() {
        this.savedIds.documents = this.savedDocuments[0] == "" ? this.savedDocuments.shift() : this.savedDocuments;
      },
      savedSoftware: function savedSoftware() {
        this.savedIds.software = this.savedSoftware[0] == "" ? this.savedSoftware.shift() : this.savedSoftware;
      },
      savedArticles: function savedArticles() {
        this.savedIds.articles = this.savedArticles[0] == "" ? this.savedArticles.shift() : this.savedArticles;
      },
      savedLegalDocuments: function savedLegalDocuments() {
        this.savedIds.legalDocuments = this.savedLegalDocuments[0] == "" ? this.savedLegalDocuments.shift() : this.savedLegalDocuments;
      }
    },
    methods: {
      initSavedIds: function initSavedIds() {
        this.savedIds.products = this.savedProducts[0] == "" ? this.savedProducts.shift() : this.savedProducts;
        this.savedIds.documents = this.savedDocuments[0] == "" ? this.savedDocuments.shift() : this.savedDocuments;
        this.savedIds.software = this.savedSoftware[0] == "" ? this.savedSoftware.shift() : this.savedSoftware;
        this.savedIds.articles = this.savedArticles[0] == "" ? this.savedArticles.shift() : this.savedArticles;
        this.savedIds.legalDocuments = this.savedLegalDocuments[0] == "" ? this.savedLegalDocuments.shift() : this.savedLegalDocuments;
      }
    },
    created: function created() {
      this.initSavedIds();
    },
    mounted: function mounted() {},
    components: {
      tabSelectMobile: {
        name: 'tab-select-mobile',
        template: _mySavedPage.tabSelectMobile,
        props: {
          currentTab: [String, Number],
          selectClass: {
            type: String,
            "default": 'my-saved-page__tab-select'
          },
          changeTab: Function,
          savedData: Object
        },
        data: function data() {
          var data = {
            options: []
          };
          return data;
        },
        mounted: function mounted() {
          var _this = this;

          var defaultSlots = this.$slots["default"];
          var childSlot = defaultSlots && defaultSlots[0];
          var children = childSlot && childSlot.children;

          if (children) {
            children.forEach(function (c) {
              var options = c.componentOptions;

              if (!options || options.tag !== 'tab') {
                return;
              }

              var props = options.propsData;
              var span = options.children[0];
              var text = span && span.children[0] && span.children[0].text;
              var id = props.idTab;

              _this.options.push({
                id: id,
                text: text
              });
            });
          }
        },
        methods: {
          change: function change(e) {
            this.changeTab(e.target.value);
          }
        }
      },
      savedProducts: {
        name: 'saved-products',
        props: ['savedIds'],
        data: function data() {
          return {
            checked: [],
            checkedStr: null
          };
        },
        watch: {
          "checked": function checked() {
            this.checkedStr = this.checked.map(function (item) {
              return "".concat(item.name);
            }).join("\n");
          }
        },
        components: {
          productItem: {
            name: 'product-item',
            // template: productItemTemplate,
            props: ['checked', 'savedIds'],
            data: function data() {
              var data = {
                id: null,
                isChecked: null,
                isBookmarked: false,
                type: 'productId'
              };
              return data;
            },
            watch: {
              isChecked: function isChecked() {
                var param = this.isChecked ? "add" : "remove";
                var url = this.$refs.url.getAttribute('href');
                var name = this.$refs.url.innerText;
                var obj = {
                  'id': this.id,
                  'url': url,
                  'name': name
                };

                _eventBus["default"].$emit('update-checked', param, obj);
              },
              "savedIds.products": function savedIdsProducts() {
                this.isBookmarked = this.savedIds.products.includes(this.id) ? true : false;
              }
            },
            mounted: function mounted() {
              this.id = this.$refs.checkbox.dataset.productId;
              this.isBookmarked = this.savedIds.products.includes("".concat(this.id)) ? true : false;
            },
            methods: {
              handleBookmark: function handleBookmark() {
                _store["default"].commit('updateFavorites', {
                  id: this.id,
                  type: this.type,
                  action: this.isBookmarked ? "remove" : "add"
                });

                _store["default"].dispatch('checkFavorites');
              }
            }
          }
        },
        methods: {
          requestaquote: function requestaquote() {
            console.log("REQUEST A QUOTE");
          }
        },
        mounted: function mounted() {
          var _this2 = this;

          _eventBus["default"].$on('update-checked', function (param, value) {
            if (param == "add") {
              _this2.checked.push(value);
            } else {
              var match = _this2.checked.find(function (item) {
                return item.id == value.id;
              });

              var index = _this2.checked.map(function (item) {
                return item.id;
              }).indexOf(value.id);

              if (match) {
                _this2.checked.splice(_this2.checked.indexOf(index), 1);
              }
            }
          });
        }
      },
      docItem: {
        name: 'doc-item',
        props: ['savedIds'],
        data: function data() {
          return {
            id: null,
            isBookmarked: false,
            type: 'documentId',
            seeAll: null,
            //is "see all" feature enabled,
            seeAllOpen: null,
            seeAllLabel: null,
            //label
            moreContent: null
          };
        },
        components: {},
        watch: {
          "savedIds.documents": function savedIdsDocuments() {
            this.isBookmarked = this.savedIds.documents.includes(this.id) ? true : false;
          },
          "seeAll": function seeAll() {
            if (this.seeAll) {
              this.seeAllLabel = this.seeAllOpen ? window.seeLessLabel : window.seeAllLabel;
            }
          }
        },
        methods: {
          toggleSeeAll: function toggleSeeAll() {
            this.seeAllOpen = !this.seeAllOpen;
          },
          handleBookmark: function handleBookmark() {
            _store["default"].commit('updateFavorites', {
              id: this.id,
              type: this.type,
              action: this.isBookmarked ? "remove" : "add"
            });

            _store["default"].dispatch('checkFavorites');
          },
          initSeeAll: function initSeeAll() {
            if (this.$refs.seeAllContent) {
              var details = this.$refs.seeAllContent.innerHTML.split(',');
              this.seeAll = details.length > 3 ? true : false;
              var truncatedDetails = details.slice(0, 3).join();
              var moreDetails = details.slice(3).join();
              this.moreContent = moreDetails;
              this.$refs.seeAllContent.innerHTML = "".concat(truncatedDetails).concat(moreDetails == "" ? '' : ',');
            }
          }
        },
        mounted: function mounted() {
          this.id = this.$refs.bookmark.dataset.documentId;
          this.isBookmarked = this.savedIds.documents.includes("".concat(this.id)) ? true : false;
          this.initSeeAll();
        }
      },
      legalDocItem: {
        name: 'legal-doc-item',
        props: ['savedIds'],
        data: function data() {
          return {
            id: null,
            isBookmarked: false,
            type: 'legalDocumentId',
            seeAll: null,
            //is "see all" feature enabled,
            seeAllOpen: null,
            seeAllLabel: null,
            //label
            moreContent: null
          };
        },
        components: {},
        watch: {
          "savedIds.legalDocuments": function savedIdsLegalDocuments() {
            this.isBookmarked = this.savedIds.legalDocuments.includes(this.id) ? true : false;
          },
          "seeAll": function seeAll() {
            if (this.seeAll) {
              this.seeAllLabel = this.seeAllOpen ? window.seeLessLabel : window.seeAllLabel;
            }
          }
        },
        methods: {
          toggleSeeAll: function toggleSeeAll() {
            this.seeAllOpen = !this.seeAllOpen;
          },
          handleBookmark: function handleBookmark() {
            _store["default"].commit('updateFavorites', {
              id: this.id,
              type: this.type,
              action: this.isBookmarked ? "remove" : "add"
            });

            _store["default"].dispatch('checkFavorites');
          },
          initSeeAll: function initSeeAll() {
            if (this.$refs.seeAllContent) {
              var details = this.$refs.seeAllContent.innerHTML.split(',');
              this.seeAll = details.length > 3 ? true : false;
              var truncatedDetails = details.slice(0, 3).join();
              var moreDetails = details.slice(3).join();
              this.moreContent = moreDetails;
              this.$refs.seeAllContent.innerHTML = "".concat(truncatedDetails, ",");
            }
          }
        },
        mounted: function mounted() {
          this.id = this.$refs.bookmark.dataset.legalDocumentId;
          this.isBookmarked = this.savedIds.legalDocuments.includes("".concat(this.id)) ? true : false;
          this.initSeeAll();
        }
      },
      softwareItem: {
        name: 'software-item',
        props: ['savedIds'],
        data: function data() {
          return {
            id: null,
            isBookmarked: false,
            type: 'softwareId'
          };
        },
        components: {},
        watch: {
          "savedIds.software": function savedIdsSoftware() {
            this.isBookmarked = this.savedIds.software.includes(this.id) ? true : false;
          }
        },
        methods: {
          handleBookmark: function handleBookmark() {
            _store["default"].commit('updateFavorites', {
              id: this.id,
              type: this.type,
              action: this.isBookmarked ? "remove" : "add"
            });

            _store["default"].dispatch('checkFavorites');
          },
          toggleModal: function toggleModal() {
            var releaseNotes = this.$refs.releaseNotes.innerHTML;
            this.$modal.show(_modals.releaseNotesModal.template(releaseNotes), _modals.releaseNotesModal.name, _modals.releaseNotesModal.options);
          }
        },
        mounted: function mounted() {
          this.id = this.$refs.bookmark.dataset.softwareId;
          this.isBookmarked = this.savedIds.software.includes("".concat(this.id)) ? true : false;
        }
      },
      articleItem: {
        name: 'article-item',
        props: ['savedIds'],
        data: function data() {
          return {
            id: null,
            isBookmarked: false,
            type: 'articleId'
          };
        },
        components: {},
        watch: {
          "savedIds.articles": function savedIdsArticles() {
            this.isBookmarked = this.savedIds.articles.includes(this.id) ? true : false;
          }
        },
        methods: {
          handleBookmark: function handleBookmark() {
            _store["default"].commit('updateFavorites', {
              id: this.id,
              type: this.type,
              action: this.isBookmarked ? "remove" : "add"
            });

            _store["default"].dispatch('checkFavorites');
          }
        },
        mounted: function mounted() {
          this.id = this.$refs.bookmark.dataset.articleId;
          this.isBookmarked = this.savedIds.articles.includes("".concat(this.id)) ? true : false;
        }
      }
    },
    tabProps: {
      savedIds: Object
    },
    tabOptions: {
      computed: {
        taggingMeta: function taggingMeta() {
          return null;
        }
      }
    },
    tabContentOptions: {
      computed: {
        taggingMeta: function taggingMeta() {
          return null;
        }
      }
    },
    contentProps: {
      savedIds: Object
    }
  })]
}); // window.seeLessLabel = "see less";
// window.seeAllLabel = "see more";

},{"../event-bus":9,"../store":51,"./../modals":30,"lib/component-module":2,"lib/tabs":53,"lib/template-strings/my-saved-page":54,"vue-js-modal":233,"vue/dist/vue.min.js":234}],38:[function(require,module,exports){
"use strict";

var _componentModule = _interopRequireDefault(require("lib/component-module"));

var _fetcher = _interopRequireDefault(require("lib/fetcher"));

var _store = _interopRequireDefault(require("../store"));

var _recentPosts = require("lib/template-strings/recent-posts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

_componentModule["default"].AddModule('.recent-posts', {
  prefix: 'recent-posts-',
  components: [(0, _fetcher["default"])({
    data: function data() {
      var data = {
        data: {
          firstLoad: true,
          keepContent: true,
          results: [],
          store: _store["default"]
        }
      };
      return data;
    },
    computed: {
      language: function language() {
        return _store["default"].state.currentLang;
      },
      taggingMetaMarket: function taggingMetaMarket() {
        return JSON.stringify({
          "type": "dropdown",
          "category": "Dropdown",
          "action": this.params.market,
          "label": "Market"
        });
      },
      taggingMetaTechnology: function taggingMetaTechnology() {
        return JSON.stringify({
          "type": "dropdown",
          "category": "Dropdown",
          "action": this.params.technology,
          "label": "Technology"
        });
      },
      taggingMetaProductLine: function taggingMetaProductLine() {
        return JSON.stringify({
          "type": "dropdown",
          "category": "Dropdown",
          "action": this.params.productLine,
          "label": "Post Type"
        });
      }
    },
    watch: {
      "language": function language() {
        this.params.lang = this.language;
      }
    },
    methods: {
      loadMore: function loadMore(e) {
        var _this = this;

        this.fetch(function (response) {
          var _results = [];
          var keepContent = false;

          var _ref = response.data || {},
              results = _ref.results,
              data = _objectWithoutProperties(_ref, ["results"]);

          if (!results) {
            return false;
          }

          if (_this.data && _this.data.results) {
            _results = _this.data.results;
            keepContent = _this.data.keepContent;
          }

          _this.data = _objectSpread(_objectSpread({}, data), {}, {
            results: [].concat(_toConsumableArray(_results), _toConsumableArray(results)),
            keepContent: keepContent,
            showPaginator: data.currentPage < data.totalPages
          });
        }, {
          params: _objectSpread(_objectSpread({}, this.params), {}, {
            page: this.data && this.data.nextPage || 2,
            pageSize: 8
          })
        });
      }
    },
    components: {
      'recent-posts-paginator': {
        props: ['data', 'isShow'],
        template: _recentPosts.paginator
      },
      'recent-posts-content': {
        props: ['data'],
        template: _recentPosts.content
      }
    }
  })]
});

},{"../store":51,"lib/component-module":2,"lib/fetcher":10,"lib/template-strings/recent-posts":55}],39:[function(require,module,exports){
"use strict";

var _componentModule = _interopRequireDefault(require("lib/component-module"));

var _tabs = _interopRequireDefault(require("lib/tabs"));

var _solutionArea = require("lib/template-strings/solution-area");

var _modals = require("../modals");

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _store = _interopRequireDefault(require("../store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

_vueMin["default"].use(_vueJsModal["default"]);

_componentModule["default"].AddModule('.solution-area', {
  prefix: 'solution-area-',
  components: [(0, _tabs["default"])({
    data: function data() {
      return {
        isMobile: null,
        store: _store["default"]
      };
    },
    watch: {
      isMobile: function isMobile() {
        if (!this.isMobile) {
          this.$modal.hide('applications');
        }
      }
    },
    methods: {
      changeTab: function changeTab(id) {
        var _this = this;

        if (this.currentTab != id) {
          this.currentTab = id;
          this.$nextTick(function () {
            _this.scrollToTop();
          });
        } else {
          // close tab if clicked again
          if (this.isMobile) {
            this.currentTab = null;
          }
        }
      },
      showModal: function showModal() {
        var apps = document.querySelector('.solution-area__applications-item.active').cloneNode(true);
        console.log(_modals.applicationsModal.name);
        this.$modal.show(_modals.applicationsModal.template, _modals.applicationsModal.name, _modals.applicationsModal.options, _modals.applicationsModal.events(apps));
      },
      hideApplications: function hideApplications() {
        this.$modal.hide('applications');
      },
      checkIsMobile: function checkIsMobile() {
        var _this2 = this;

        // this is checking for a breakpoint *smaller* than
        // var isMobile in store.js
        var mql = window.matchMedia('(max-width: 650px)');
        this.isMobile = mql.matches ? true : false;
        mql.addEventListener('change', function () {
          _this2.isMobile = mql.matches ? true : false;
        });
      },
      scrollToTop: function scrollToTop() {
        var el = this.$el.querySelector('.solution-area__content-item.active');
        var elmOffset = el.offsetTop;
        var scrollOffset = window.scrollY; // console.log("el",elmOffset);
        // console.log("window",scrollOffset);

        if (elmOffset < scrollOffset) {
          var elmPos = el.getBoundingClientRect().top + window.scrollY;
          setTimeout(function () {
            window.scrollTo({
              top: elmPos - 70,
              behavior: 'smooth'
            });
          }, 500);
        }
      }
    },
    components: {
      'applications-content': {
        name: 'applications-content',
        template: _solutionArea.contentApplications,
        props: {
          idTab: [String, Number],
          currentTab: [String, Number],
          activeClass: {
            type: String,
            "default": 'active'
          },
          close: Function
        },
        data: function data() {
          return {
            label: null
          };
        },
        computed: {
          taggingMeta: function taggingMeta() {
            return JSON.stringify({
              "type": "layer",
              //static 
              "category": "Drawer",
              //static
              "action": "Open",
              // static
              "label": this.label,
              // Tab label e.g. District system balancing
              "no": this.idTab < 10 ? "0".concat(this.idTab) : "".concat(this.idTab)
            });
          }
        },
        mounted: function mounted() {
          this.label = Array.prototype.slice.call(document.querySelectorAll('.solution-area__tabs li'))[this.idTab - 1].innerText;
        }
      }
    },
    tabData: {
      label: null
    },
    tabOptions: {
      computed: {
        taggingMeta: function taggingMeta() {
          return JSON.stringify({
            "type": "layer",
            //static 
            "category": "Drawer",
            //static
            "action": "Open",
            // static
            "label": this.label,
            // Tab label e.g. District system balancing
            "no": this.idTab < 10 ? "0".concat(this.idTab) : "".concat(this.idTab)
          });
        }
      },
      mounted: function mounted() {
        this.label = this.$el.innerText;
      }
    },
    tabContentData: {
      label: null
    },
    tabContentOptions: {
      computed: {
        taggingMeta: function taggingMeta() {
          return JSON.stringify({
            "type": "layer",
            //static 
            "category": "Drawer",
            //static
            "action": "Open",
            // static
            "label": this.label,
            // Tab label e.g. District system balancing
            "no": this.idTab < 10 ? "0".concat(this.idTab) : "".concat(this.idTab)
          });
        }
      },
      mounted: function mounted() {
        this.label = Array.prototype.slice.call(document.querySelectorAll('.solution-area__tabs li'))[this.idTab - 1].innerText;
      }
    },
    mounted: function mounted() {
      this.checkIsMobile();
    }
  })]
});

},{"../modals":30,"../store":51,"lib/component-module":2,"lib/tabs":53,"lib/template-strings/solution-area":56,"vue-js-modal":233,"vue/dist/vue.min.js":234}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pardotFormInstance = exports.pardotForm = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var pardotFormInstance = _vueMin["default"].component('pardot-form', {
  data: function data() {
    return {};
  },
  computed: {
    paramData: function paramData() {
      return {
        GAID: _store["default"].state.GAID
      };
    }
  },
  methods: {
    handleIframe: function handleIframe() {
      var _this = this;

      var iframe = this.$el;
      var src = this.$el.getAttribute('src');
      window.addEventListener("message", function (event) {
        if (event.origin == "https://info.badgermeter.com") {
          _this.$nextTick(function () {
            sizeIframe(event);
            postData(event);
          });
        }
      });

      var postData = function postData(event) {
        // console.log(this.paramData);
        if (iframe.contentWindow) {
          iframe.contentWindow.postMessage(JSON.stringify(_this.paramData), '*');
        } else {
          iframe.onload = function () {
            iframe.contentWindow.postMessage(JSON.stringify(this.paramData), '*');
          };
        }
      };

      var sizeIframe = function sizeIframe(event) {
        var data = JSON.parse(event.data); // console.log(data);

        if (data.form) {
          if (src.includes(data.form)) {
            iframe.style.height = "".concat(data.content + 20, "px");

            if (data.submit) {
              _this.checkScroll();
            }
          }
        }
      };
    },
    checkScroll: function checkScroll() {
      var iframe = this.$el;
      var iframePos = iframe.offsetTop;
      var scrollOffset = window.scrollY;

      if (iframePos < scrollOffset) {
        var elmPos = iframe.getBoundingClientRect().top + window.scrollY - 100;
        setTimeout(function () {
          window.scrollTo({
            top: elmPos - 70,
            behavior: 'smooth'
          });
        }, 500);
      }
    }
  },
  mounted: function mounted() {
    this.handleIframe();
  }
});

exports.pardotFormInstance = pardotFormInstance;

var pardotForm = function pardotForm() {
  var forms = document.querySelectorAll('.pardot-form');

  var formConstructor = function formConstructor(id) {
    pardotFormInstance;
    new _vueMin["default"]({
      el: ".pardot-form-".concat(id)
    }).$mount(".pardot-form-".concat(id), true);
  };

  if (forms.length > 0) {
    forms.forEach(function (item, index) {
      item.classList.add("pardot-form-".concat(index));
      formConstructor(index);
    });
  }
};

exports.pardotForm = pardotForm;

},{"./store":51,"vue/dist/vue.min.js":234}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _modals = require("./modals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

_vueMin["default"].use(_vueJsModal["default"]);

var patents = function patents() {
  var patentItems = document.querySelectorAll('.patents');

  var patentsConstructor = function patentsConstructor(id) {
    _vueMin["default"].component('patents', {
      data: function data() {
        return {
          allPatents: null
        };
      },
      methods: {
        triggerModal: function triggerModal() {
          this.$modal.show(_modals.patentsModal.template, _modals.patentsModal.name, _modals.patentsModal.options, _modals.patentsModal.events(this.allPatents));
        }
      },
      mounted: function mounted() {
        var _this = this;

        this.$nextTick(function () {
          _this.allPatents = _this.$refs.allPatents;
        });
      }
    });

    new _vueMin["default"]({
      el: ".patents-".concat(id)
    }).$mount(".patents-".concat(id), true);
  };

  if (patentItems.length > 0) {
    patentItems.forEach(function (item, index) {
      item.classList.add("patents-".concat(index));
      patentsConstructor(index);
    });
  }
};

var _default = patents;
exports["default"] = _default;

},{"./modals":30,"vue-js-modal":233,"vue/dist/vue.min.js":234}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _axios = _interopRequireDefault(require("axios"));

var _db = _interopRequireDefault(require("../../../db.json"));

var _misc = require("./misc");

var _filterComponents = require("./filter-components");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var ProductCatalog = function ProductCatalog() {
  var catalog = document.querySelectorAll('.product-catalog');

  var productCatalogConstructor = function productCatalogConstructor(id) {
    _vueMin["default"].component('product-catalog-template', {
      data: function data() {
        return {
          data: {
            currentPage: 1,
            //current page #
            totalPages: null,
            //total returns pages
            totalResults: null,
            //total results
            shownResults: null,
            //total shown items
            filtersVisible: null,
            //are filters visible
            filterAreaVisible: true,
            //is filter area (including unit toggler and btns) visible
            filters: [],
            products: [],
            results: [],
            emailDocs: [],
            //for emailing
            savedDocs: [],
            //bookmarked items
            savedDocsLabel: null,
            //label for saved docs
            savedDocsOnly: null,
            isMobile: null,
            nextActive: null,
            prevActive: null,
            // apiUrl: null, //for api call
            urlParams: null,
            //for deeplinking in-browser
            shareAll: false,
            selectedUnit: null,
            usLabel: '',
            metricLabel: '',
            store: _store["default"],
            viewProductLabel: null,
            "class": 'product-catalog'
          }
        };
      },
      components: {
        'filter-accordion-template': _filterComponents.Accordion,
        'selectedFilters': _filterComponents.SelectedFiltersComponent,
        'checkbox-item': _filterComponents.Checkbox,
        'pagination': _filterComponents.Pagination
      },
      computed: {
        computedIsMobile: function computedIsMobile() {
          return _store["default"].state.isMobile;
        },
        saved: function saved() {
          return _store["default"].state.favorites.productId[0] == "" ? _store["default"].state.favorites.productId.slice(1) : _store["default"].state.favorites.productId;
        },
        computedUnit: function computedUnit() {
          return _store["default"].state.units;
        },
        pageRange: function pageRange() {
          if (this.data.totalResults > 9) {
            if (this.data.currentPage == 1) {
              return "1-".concat(this.data.shownResults);
            } else if (this.data.currentPage == this.data.totalPages) {
              return "".concat(this.data.totalResults - this.data.shownResults + 1, "-").concat(this.data.totalResults);
            } else {
              return "".concat(this.data.shownResults * (this.data.currentPage - 1) + 1, "-").concat(this.data.shownResults * this.data.currentPage);
            }
          } else {
            return this.data.shownResults;
          }
        }
      },
      watch: {
        computedUnit: function computedUnit() {
          this.data.selectedUnit = this.computedUnit; // console.log("unit changed");

          this.getUrl(); // this.updateHistory();
        },
        saved: function saved() {
          this.data.savedDocs = this.saved; // remove saved only filter if no saved items

          if (this.saved.length == 0) {
            var index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf('savedDownloads');

            if (index > -1) {
              this.data.filters.splice(index, 1);
            }
          }
        },
        computedIsMobile: function computedIsMobile() {
          this.data.isMobile = this.computedIsMobile;
          this.data.filtersVisible = !this.computedIsMobile ? true : this.data.filtersVisible;
        },
        "data.filters": function dataFilters() {
          this.getResults(); // handle api call
          // this.updateHistory(); // handle history record
          // set savedDocsOnly value

          var savedOnly = this.data.filters.find(function (item) {
            return item.type == "savedProducts";
          });
          this.data.savedDocsOnly = savedOnly ? savedOnly.value : null;
        },
        "data.currentPage": function dataCurrentPage() {
          if (this.data.currentPage == 1) {
            this.data.nextActive = true;
            this.data.prevActive = false;
          } else if (this.data.currentPage == this.data.totalPages) {
            this.data.nextActive = false;
            this.data.prevActive = true;
          } else {
            this.data.nextActive = true;
            this.data.prevActive = true;
          }

          this.getResults(); // this.updateHistory();
        },
        "data.totalResults": function dataTotalResults() {
          this.initPages();
        }
      },
      methods: {
        toggleFilters: function toggleFilters() {
          // console.log("clicked");
          if (this.data.isMobile) {
            // console.log("is mobile");
            this.data.filtersVisible = !this.data.filtersVisible;
          }
        },
        updateFilters: function updateFilters(el, e, type) {
          if (el !== this.data["class"]) {
            return;
          }

          var type = type;
          var value = encodeURIComponent(e.currentTarget.value);
          var label = e.currentTarget.parentNode.innerText; // console.log(e.currentTarget.parentNode.innerText);

          var checked = e.currentTarget.checked;
          this.data.currentPage = 1; //reset page to 1
          // console.log("type", type)
          // console.log(e);
          // console.log(e.currentTarget.checked);
          // console.log("value", encodeURIComponent(e.target.value));
          // console.log("checked",e.target.checked);

          if (checked) {
            switch (type) {
              case "measuringMedium":
                var measureFilter = this.data.filters.map(function (e) {
                  return e.type;
                }); // console.log(measureFilter);

                if (measureFilter.indexOf('measuringMedium') > -1) {
                  var index = measureFilter.indexOf('measuringMedium');
                  this.data.filters.splice(index, 1);
                  this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                    "value": value,
                    "type": type,
                    "name": label
                  }]);
                } else {
                  this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                    "value": value,
                    "type": type,
                    "name": label
                  }]);
                }

                break;

              case "savedProducts":
                this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                  "value": checked,
                  "type": type,
                  "name": label
                }]);
                break;

              default:
                this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                  "value": value,
                  "type": type,
                  "name": label
                }]);
            }
          } else {
            var _index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf(value); // console.log("INDEX", index);


            this.data.filters.splice(_index, 1);
          }
        },
        updateRangeFilter: function updateRangeFilter(entry) {
          this.data.currentPage = 1; //reset page to 1 when filters changed
          // console.log(entry);
          // allow only once instance of filter type at once for ranges

          var types = this.data.filters.map(function (e) {
            return e.type;
          });

          if (types.indexOf(entry.type) > -1) {
            var index = types.indexOf(entry.type);

            if (this.data.filters[index].value == entry.value && this.data.filters[index].type == entry.type) {
              // if old and new entries are the same, do nothing
              return;
            } else {
              // only update filters if new entry values differ
              this.data.filters.splice(index, 1);
              this.data.filters = [].concat(_toConsumableArray(this.data.filters), [entry]);
            }
          } else {
            this.data.filters = [].concat(_toConsumableArray(this.data.filters), [entry]);
          } // this.data.filters = [...this.data.filters, entry];

        },
        // removes specific filter
        removeFilter: function removeFilter(el, value, type) {
          if (el !== this.data["class"]) {
            return;
          }

          if (value) {
            var index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf(value);

            if (index > -1) {
              this.data.filters.splice(index, 1);
            }
          } else {
            var _index2 = this.data.filters.map(function (e) {
              return e.type;
            }).indexOf(type); // console.log("remove", index);


            if (_index2 > -1) {
              this.data.filters.splice(_index2, 1);
            }
          }
        },
        // clears filters
        removeAll: function removeAll() {
          this.data.filters = [];
          this.data.currentPage = 1; //reset page to 1
        },
        getUrl: function getUrl() {
          var _this = this;

          var savedParams = this.data.savedDocs.toString();
          var unitParams = this.computedUnit;
          var marketParams = this.data.filters.filter(function (item) {
            return item.type == "market";
          }).map(function (item) {
            return item.value;
          }).toString();
          var productCatParams = this.data.filters.filter(function (item) {
            return item.type == "productCategory";
          }).map(function (item) {
            return item.value;
          }).toString();
          var productTypeParams = this.data.filters.filter(function (item) {
            return item.type == "productType";
          }).map(function (item) {
            return item.value;
          }).toString();
          var productLineParams = this.data.filters.filter(function (item) {
            return item.type == "productLine";
          }).map(function (item) {
            return item.value;
          }).toString();
          var measuringParams = this.data.filters.filter(function (item) {
            return item.type == "measuringMedium";
          }).map(function (item) {
            return item.value;
          }).toString();

          var savedDocumentsTrueParams = function savedDocumentsTrueParams() {
            var savedOnly = _this.data.filters.find(function (item) {
              return item.type == "savedProducts";
            });

            if (savedOnly) {
              return savedOnly.value;
            } else {
              return false;
            }
          };

          var pageParams = this.data.currentPage;
          var sizeMinParams = this.data.filters.filter(function (item) {
            return item.type == "sizeMin";
          }).map(function (item) {
            return item.value;
          }).toString();
          var sizeMaxParams = this.data.filters.filter(function (item) {
            return item.type == "sizeMax";
          }).map(function (item) {
            return item.value;
          }).toString();
          var tempMinParams = this.data.filters.filter(function (item) {
            return item.type == "temperatureMin";
          }).map(function (item) {
            return item.value;
          }).toString();
          var tempMaxParams = this.data.filters.filter(function (item) {
            return item.type == "temperatureMax";
          }).map(function (item) {
            return item.value;
          }).toString();
          var pressureMinParams = this.data.filters.filter(function (item) {
            return item.type == "pressureMin";
          }).map(function (item) {
            return item.value;
          }).toString();
          var pressureMaxParams = this.data.filters.filter(function (item) {
            return item.type == "pressureMax";
          }).map(function (item) {
            return item.value;
          }).toString();
          var flowRangeMinParams = this.data.filters.filter(function (item) {
            return item.type == "flowRangeMin";
          }).map(function (item) {
            return item.value;
          }).toString();
          var flowRangeMaxParams = this.data.filters.filter(function (item) {
            return item.type == "flowRangeMax";
          }).map(function (item) {
            return item.value;
          }).toString();
          var flowRangeType = this.data.filters.filter(function (item) {
            return item.type == "flowRangeMax" || item.type == "flowRangeMin";
          }).map(function (item) {
            return item.flowRangeType;
          }).toString();
          this.data.urlParams = "".concat(unitParams !== "" ? "&units=" + unitParams : "").concat(marketParams !== "" ? "&market=" + marketParams : "").concat(productCatParams !== "" ? "&productCategory=" + productCatParams : "").concat(productTypeParams !== "" ? "&productType=" + productTypeParams : "").concat(productLineParams !== "" ? "&productLine=" + productLineParams : "").concat(measuringParams !== "" ? "&measuringMedium=" + measuringParams : "", "&savedProducts=").concat(savedDocumentsTrueParams(), "&page=").concat(pageParams); // console.log(apiUrl);
          // this.data.apiUrl = apiUrl;
        },
        getResults: function getResults() {
          var _this2 = this;

          // let apiUrl = "api/documents?";
          this.getUrl();
          var baseUrl = window.productCatalogAPIUrl;
          var apiUrl = "".concat(baseUrl).concat(baseUrl.indexOf('?') > -1 ? '' : '?'); // let apiUrl = "http://localhost:3003/products"; //from json-server
          // let apiUrl = "http://localhost:3003/productsTest"; //from json-server

          var self = this;

          var savedDocumentsTrueParams = function savedDocumentsTrueParams() {
            var savedOnly = _this2.data.filters.find(function (item) {
              return item.type == "savedProducts";
            });

            if (savedOnly) {
              return true;
            } else {
              return false;
            }
          };

          var market = [];
          var productCategory = [];
          var productType = [];
          var productLine = [];
          this.data.filters.map(function (item) {
            switch (item.type) {
              case "market":
                market.push(item.value);
                break;

              case "productCategory":
                productCategory.push(item.value);
                break;

              case "productLine":
                productLine.push(item.value);
                break;

              case "productType":
                productType.push(item.value);
                break;

              default:
                return;
            }
          });

          var getValue = function getValue(param) {
            var filter = _this2.data.filters.find(function (item) {
              return item.type === param;
            });

            return filter ? filter.value : null;
          };

          var getFlowRangeType = function getFlowRangeType() {
            var filter = _this2.data.filters.find(function (item) {
              return item.type === "flowRangeMin" || item.type === "flowRangeMax";
            });

            return filter ? filter.flowRangeType : null;
          };

          var axiosParams = {
            // language: null,
            units: this.computedUnit,
            market: market.join('|') == "" ? null : decodeURIComponent(market.join('|')),
            productCategory: productCategory.join('|') == "" ? null : decodeURIComponent(productCategory.join('|')),
            productType: productType.join('|') == "" ? null : decodeURIComponent(productType.join('|')),
            productLine: productLine.join('|') == "" ? null : decodeURIComponent(productLine.join('|')),
            sizeMin: getValue('sizeMin'),
            sizeMax: getValue('sizeMax'),
            flowRangeType: getFlowRangeType(),
            flowRangeMin: getValue('flowRangeMin'),
            flowRangeMax: getValue('flowRangeMax'),
            measuringMedium: getValue('measuringMedium') == null ? null : decodeURIComponent(getValue('measuringMedium')),
            temperatureMin: getValue('temperatureMin'),
            temperatureMax: getValue('temperatureMax'),
            pressureMin: getValue('pressureMin'),
            pressureMax: getValue('pressureMax'),
            savedProducts: savedDocumentsTrueParams(),
            saved: this.data.savedDocs.join('|') == "" ? null : this.data.savedDocs.join('|').charAt(0) == "," ? this.data.savedDocs.join('|').slice(1) : this.data.savedDocs.join('|'),
            page: this.data.currentPage,
            pageSize: 9
          }; // console.log(axiosParams);

          _axios["default"].get(apiUrl, {
            params: _objectSpread({}, axiosParams)
          }).then(function (response) {
            // console.log(response);
            self.data.results = response.data.results;
            self.data.totalResults = response.data.totalResults ? response.data.totalResults : 0;
            self.data.shownResults = response.data.results ? response.data.results.length : 0;
            self.data.viewProductLabel = response.data.viewProductLabel;
            console.log(response.data);
          })["catch"](function (error) {
            console.log(error);
          });
        },
        changePage: function changePage(dir) {
          if (dir == "prev" && this.data.currentPage !== 1) {
            this.data.currentPage--;
          } else if (dir == "next" && this.data.currentPage !== this.data.totalPages) {
            this.data.currentPage++;
          } else {
            return;
          }

          _eventBus["default"].$emit('scroll-to-top', this.data["class"]);
        },
        updateEmailDocs: function updateEmailDocs(data) {
          var item = this.data.emailDocs.find(function (item) {
            return item.id == data.id;
          });

          if (!item) {
            this.data.emailDocs = [].concat(_toConsumableArray(this.data.emailDocs), [data]);
          } else {
            this.data.emailDocs.splice(this.data.emailDocs.indexOf(item), 1);
          }
        },
        //update history record when filters change
        updateHistory: function updateHistory() {
          var url = "".concat(window.location.pathname, "?").concat(this.data.urlParams);

          if (history.state == null || history.state !== url) {
            history.pushState(url, "", url);
          }
        },
        // handle deep linking on history change
        deeplink: function deeplink() {
          var _this3 = this;

          var params = window.location.search.substr(1).split("&").filter(function (item) {
            return item != "";
          }); // console.log(params);
          // this.data.filters = []; //clear filters array first

          var initFilters = [];
          params.forEach(function (param) {
            var type = param.slice(0, param.indexOf('='));
            var content = param.slice(param.indexOf('=') + 1); // console.log("TYPE",type);
            // console.log("CONTENT", content);

            var entry = {};

            if (type == "page") {
              _this3.data.currentPage = parseInt(content);
            } else if (type == "units") {
              _this3.data.selectedUnit = content;
            } else if (type == "savedProducts") {
              if (content == "false" || content == false) {
                return;
              } else {
                entry = {
                  "type": type,
                  "value": true,
                  "name": _this3.data.savedDocsLabel
                };
                initFilters = [].concat(_toConsumableArray(initFilters), [entry]);
              }
            } else if (content.indexOf(',') > -1) {
              var contentArray = content.split(',');
              contentArray.forEach(function (item) {
                entry = {
                  "type": type,
                  "value": item,
                  "name": decodeURIComponent(item)
                };
                initFilters = [].concat(_toConsumableArray(initFilters), [entry]);
              });
            } else {
              entry = {
                "type": type,
                "value": content,
                "name": decodeURIComponent(content)
              };
              initFilters = [].concat(_toConsumableArray(initFilters), [entry]);
            }

            _this3.data.filters = initFilters; // console.log(this.initFilters);
          });
        },
        toggleUnits: function toggleUnits() {
          _store["default"].commit('setUnits');
        },
        scrollToTop: function scrollToTop(el) {
          if (el !== this.data["class"]) {
            return;
          }

          var top = this.$el.querySelector('.product-catalog__area-cards').getBoundingClientRect().top + window.scrollY - 100; // console.log(top);

          setTimeout(function () {
            window.scrollTo({
              top: top,
              behavior: 'smooth'
            });
          }, 500);
        },
        initPages: function initPages() {
          // based on total result count, divide by 10 to get total pages needed
          // math ceil to round up
          // set active for prev/next based on current page
          // 9 = page size
          this.data.totalPages = Math.ceil(this.data.totalResults / 9);
          this.data.prevActive = this.data.currentPage !== 1 ? true : false;
          this.data.nextActive = this.data.currentPage !== this.data.totalPages ? true : false;
        },
        init: function init() {
          var _this4 = this;

          // init data variables
          this.data.isMobile = _store["default"].state.isMobile;
          this.data.savedDocs = _store["default"].state.favorites.productId[0] == "" ? _store["default"].state.favorites.productId.slice(1) : _store["default"].state.favorites.productId;
          this.data.selectedUnit = _store["default"].state.units;
          this.data.filtersVisible = this.data.isMobile ? false : true; //init show/hide filters if/is mobile

          this.data.filterAreaVisible = parseInt(this.data.totalResults) <= 10 ? false : true; // hide filters if less then 10 initial results

          this.data.shareAll = parseInt(this.data.totalResults) <= 5 ? true : false; // enable "share all" if 5 of less results

          this.data.usLabel = this.$refs.unitToggler.dataset.usLabel;
          this.data.metricLabel = this.$refs.unitToggler.dataset.metricLabel; // init eventbus listeners

          _eventBus["default"].$on('updateFilters', function (el, e, type) {
            _this4.updateFilters(el, e, type);
          });

          _eventBus["default"].$on('updateRangeFilter', function (entry) {
            _this4.updateRangeFilter(entry);
          });

          _eventBus["default"].$on('remove-filter', function (el, value, type) {
            _this4.removeFilter(el, value, type);
          });

          _eventBus["default"].$on('change-page-to', function (el, num) {
            if (el !== _this4.data["class"]) {
              return;
            }

            ;
            _this4.data.currentPage = num;
          });

          _eventBus["default"].$on('email-docs', function (data) {
            _this4.updateEmailDocs(data);
          });

          _eventBus["default"].$on('scroll-to-top', function (el) {
            _this4.scrollToTop(el);
          }); // init initial results


          this.data.results = window.initialProductApiResults.results;
          this.data.totalResults = window.initialProductApiResults ? window.initialProductApiResults.totalResults : 0;
          this.data.shownResults = window.initialProductApiResults.results ? window.initialProductApiResults.results.length : 0;
          this.data.viewProductLabel = window.initialProductApiResults ? window.initialProductApiResults.viewProductLabel : null; // this.data.results = fpodb.products.results;
          // this.data.totalResults = fpodb.products.totalResults;
          // this.data.shownResults = fpodb.products.results ? fpodb.products.results.length : 0;
          // this.data.viewProductLabel = fpodb.products.viewProductLabel;
          // window.onpopstate = () => {
          //     this.deeplink();
          // }
        }
      },
      mounted: function mounted() {
        this.init();
        this.initPages(); // for deeplinking
        // if (window.location.search) {
        //     this.$nextTick(() => {
        //         this.deeplink();
        //     });
        // }
      }
    }); // results list


    _vueMin["default"].component('product-results-list', {
      props: ['data'],
      data: function data() {
        return {
          type: "product"
        };
      },
      template: "\n            <div class=\"product-catalog__cards-content\" :data=\"data\">\n                <product-results-item v-for=\"(result, index) in data.results\" :content=\"result\" :key=\"index\" :index=\"index\" :data=\"data\"/>\n            </div>\n            ",
      methods: {},
      mounted: function mounted() {}
    }); // single results item


    _vueMin["default"].component('product-results-item', {
      props: ['data', 'content', 'index'],
      data: function data() {
        return {
          isChecked: false,
          isBookmarked: false,
          id: this.content.id || null
        };
      },
      computed: {
        saved: function saved() {
          return _store["default"].state.favorites.productId;
        },
        taggingMeta: function taggingMeta() {
          return JSON.stringify({
            "type": "layer",
            "category": "Preview Card",
            "productLine": this.content.brand,
            "label": this.content.productName ? this.content.productName.replace('<p>', '').replace('</p>', '') : null,
            "no": this.index < 10 ? "0".concat(this.index + 1) : (this.index + 1).toString()
          });
        }
      },
      watch: {
        saved: function saved() {
          this.isBookmarked = this.saved.includes(this.id) ? true : false;
        },
        "content": function content() {
          this.id = this.content.id || null;
          this.isBookmarked = this.saved.includes(this.id) ? true : false;
        }
      },
      template: "\n            <div class=\"catalog-card\" :data=\"data\" :class=\"{'hide-bookmark': (data.savedDocsOnly === true) && (isBookmarked === false)}\" data-tag-trigger=\"click\" :data-tag-meta=\"taggingMeta\">\n                <div class=\"catalog-card__row\">\n                    <div class=\"catalog-card__area catalog-card__area-util\">\n                        <div class=\"catalog-card__util-bookmark\">\n                            <span class=\"catalog-card__bookmark\" :class=\"{active: isBookmarked}\" :data-product-id=\"content.id\" ref=\"bookmark\" v-on:click=\"handleBookmark\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"layer\", \"category\": \"Product\", \"action\": \"Favorite\"}'></span>\n                        </div>\n                    </div>\n                    \n                    <div class=\"catalog-card__area catalog-card__area-header\">\n                        <div class=\"catalog-card__image-container\">\n                            <a :href=\"content.url\" class=\"catalog-card__link\">\n                                <img class=\"catalog-card__image\" :src=\"content.productImageUrl\" :alt=\"content.productImageUrlAltText\">\n                            </a>\n                        </div>\n                        <img :src=\"content.brandImageUrl\" :alt=\"content.brandImageUrlAltText\" class=\"catalog-card__logo\">\n                        <a :href=\"content.url\" v-html=\"content.productName\" class=\"catalog-card__title\"></a>\n                    </div>\n\n                    <div class=\"catalog-card__area catalog-card__area-stats\">\n\n                        <div class=\"catalog-card__stat\" v-for=\"(spec, index) in content.stats\" :key=\"index\" :data=\"data\">\n                            <div class=\"catalog-card__stat-label\" v-html=\"spec.label\">{{spec.label}}</div>\n                            <div class=\"catalog-card__stat-value\">\n                                <div class=\"unit-metric \" v-if=\"data.selectedUnit === 'metric'\" v-html=\"spec.valueMetric\">{{spec.valueMetric}}</div>\n                                <div class=\"unit-us\" v-if=\"data.selectedUnit === 'us'\" v-html=\"spec.valueImperial\">{{spec.valueImperial}}</div>\n                            </div>\n                        </div>\n                        \n                    </div>\n\n                    <div class=\"catalog-card__area catalog-card__area-cta\">\n                        <a :href=\"content.url\" class=\"button tertiary-button\"><span class=\"button-text\">{{data.viewProductLabel}}</span> <span class=\"button-icon\"></span></a>\n                    </div>\n                </div>\n            </div>\n            ",
      methods: {
        handleBookmark: function handleBookmark() {
          _store["default"].commit('updateFavorites', {
            id: this.id,
            type: "productId",
            action: this.isBookmarked ? "remove" : "add"
          });

          _store["default"].dispatch('checkFavorites');
        }
      },
      mounted: function mounted() {
        // this.id = this.$refs.bookmark.dataset.productId;
        // console.log("saved",this.saved);
        this.isBookmarked = this.saved.includes("".concat(this.id)) ? true : false;
      }
    });

    _vueMin["default"].component('email-docs', {
      props: ['data'],
      data: function data() {
        return {
          mailto: null,
          mailtoAll: null
        };
      },
      watch: {
        "data.emailDocs": function dataEmailDocs() {
          var mailto = "mailto:?subject=Badger%20Meter%20Document%20Links&body=";
          this.data.emailDocs.forEach(function (item) {
            mailto = "".concat(mailto).concat(item.name, ": ").concat(item.url, "%0D%0A");
          });
          this.mailto = mailto;
        }
      },
      methods: {
        shareAll: function shareAll() {
          var mailto = "mailto:?subject=Badger%20Meter%20Document%20Links&body=";
          this.data.results.forEach(function (item) {
            mailto = "".concat(mailto).concat(item.name, ": ").concat(item.url, "%0D%0A");
          });
          this.mailtoAll = mailto;
        }
      },
      mounted: function mounted() {
        if (parseInt(this.data.totalResults) <= 5) {
          this.shareAll();
        }
      }
    });

    _vueMin["default"].component('min-max', {
      props: ['data'],
      data: function data() {
        return {
          minValue: null,
          //final values to send to api
          minValueRange: null,
          // model for range slider
          minValueInput: null,
          // model for input field
          maxValue: null,
          //final values to send to api
          maxValueRange: null,
          // model for range slider
          maxValueInput: null,
          // model for input field
          usMin: null,
          usMax: null,
          usStep: null,
          metricMin: null,
          metricMax: null,
          metricStep: null,
          currentMin: null,
          currentMax: null,
          currentStep: null,
          styles: null,
          type: null,
          currentUnit: null,
          label: null
        };
      },
      watch: {
        "data.filters": function dataFilters() {
          var types = this.data.filters.map(function (e) {
            return e.type;
          });

          if (!(types.indexOf("".concat(this.type, "Min")) > -1)) {
            this.minValue = null;
          }

          if (!(types.indexOf("".concat(this.type, "Max")) > -1)) {
            this.maxValue = null;
          }
        },
        "data.selectedUnit": function dataSelectedUnit() {
          this.initCurrentUnits();
          this.initUnitLabel(); // reset selectors when units change

          this.maxValue = null;
          this.minValue = null;
          this.minValueRange = this.currentMin;
          this.maxValueRange = this.currentMax; // clear inputs and input filters when changing units

          _eventBus["default"].$emit('remove-filter', this.data["class"], null, "".concat(this.type, "Min"));

          _eventBus["default"].$emit('remove-filter', this.data["class"], null, "".concat(this.type, "Max"));
        },
        "minValue": function minValue() {
          // if at max value, set to null for 'no min' and remove filter
          // if value exceeds min or max range, set to one step under max value
          if (this.minValue == this.currentMin || this.minValue == "") {
            this.minValue = null;

            _eventBus["default"].$emit('remove-filter', this.data["class"], null, "".concat(this.type, "Min"));
          } else if (parseFloat(this.minValue) < parseFloat(this.currentMin) || parseFloat(this.minValue) > parseFloat(this.currentMax)) {
            // this.minValue = parseFloat(this.currentMin) === 0 ? 0 : (parseFloat(this.currentMin) - parseFloat(this.currentStep)).toString();
            this.minValue = null;

            _eventBus["default"].$emit('remove-filter', this.data["class"], null, "".concat(this.type, "Min"));
          }

          this.updateFilters("Min");
          this.minValueRange = this.minValue == null ? this.currentMin : this.minValue;
          this.minValueInput = this.minValue;
        },
        "maxValue": function maxValue() {
          // if at max value, set to null for 'no max' and remove filter
          // if value exceeds min or max range, set to one step under max value
          if (this.maxValue == this.currentMax || this.maxValue == "") {
            this.maxValue = null;

            _eventBus["default"].$emit('remove-filter', this.data["class"], null, "".concat(this.type, "Max"));
          } else if (parseFloat(this.maxValue) > parseFloat(this.currentMax) || parseFloat(this.maxValue) < parseFloat(this.currentMin)) {
            // this.maxValue = (parseFloat(this.currentMax) - parseFloat(this.currentStep)).toString();
            this.maxValue = null;

            _eventBus["default"].$emit('remove-filter', this.data["class"], null, "".concat(this.type, "Max"));
          }

          this.updateFilters("Max");
          this.maxValueRange = this.maxValue == null ? this.currentMax : this.maxValue;
          this.maxValueInput = this.maxValue;
        },
        "maxValueRange": function maxValueRange() {
          // condition to prevent dragging slider beyond the valid range
          if (parseFloat(this.maxValueRange) <= parseFloat(this.minValueRange)) {
            this.maxValueRange = (parseFloat(this.minValueRange) + parseFloat(this.currentStep)).toString();
          }

          this.maxValueInput = this.maxValueRange == this.currentMax ? null : this.maxValueRange;
          this.initStyles();
        },
        "minValueRange": function minValueRange() {
          // condition to prevent dragging slider beyond the valid range
          if (parseFloat(this.minValueRange) >= parseFloat(this.maxValueRange)) {
            this.minValueRange = (parseFloat(this.maxValueRange) - parseFloat(this.currentStep)).toString();
          }

          this.minValueInput = this.minValueRange == this.currentMin ? null : this.minValueRange;
          this.initStyles();
        }
      },
      methods: {
        updateFilters: (0, _misc.debounce)(function (type) {
          // console.log("type:", type);
          var entry = {
            name: "".concat(type, " ").concat(this.label, ": ").concat(type == "Min" ? this.minValue : this.maxValue, " ").concat(this.currentUnit),
            value: type == "Min" ? this.minValue : this.maxValue,
            type: "".concat(this.type).concat(type)
          }; // console.log(entry);

          if (entry.value !== null) {
            _eventBus["default"].$emit('updateRangeFilter', entry);
          }
        }, 500),
        handleRange: (0, _misc.debounce)(function (e, type) {
          var _t = e.target;
          var min = type == "min" ? _t.value : this.minValue;
          var max = type == "max" ? _t.value : this.maxValue; // console.log("MAX", max);

          if (type == "min") {
            if (parseFloat(min) >= parseFloat(max)) {
              min = (parseFloat(max) - parseFloat(this.currentStep)).toString();
            }
          } else if (type == "max") {
            if (parseFloat(max) <= parseFloat(min)) {
              max = (parseFloat(min) + parseFloat(this.currentStep)).toString();
            }
          }

          this.minValue = min;
          this.maxValue = max;
          this.minValueInput = this.minValueInput !== this.minValue && this.minValue !== null ? this.minValue : this.minValueInput;
          this.maxValueInput = this.maxValueInput !== this.maxValue && this.maxValue !== null ? this.maxValue : this.maxValueInput;
        }, 500),
        initEvents: function initEvents() {
          var _this5 = this;

          this.$refs.rangeMin.addEventListener('input', function (e) {
            _this5.handleRange(e, 'min');
          }, false);
          this.$refs.rangeMax.addEventListener('input', function (e) {
            _this5.handleRange(e, 'max');
          }, false);
        },
        initMinMax: function initMinMax() {
          // US
          this.usMin = this.$refs.rangeMin.dataset.usMin;
          this.usMax = this.$refs.rangeMin.dataset.usMax;
          this.usStep = this.$refs.rangeMin.dataset.usStep; // METRIC

          this.metricMin = this.$refs.rangeMin.dataset.metricMin;
          this.metricMax = this.$refs.rangeMin.dataset.metricMax;
          this.metricStep = this.$refs.rangeMin.dataset.metricStep;
          this.initCurrentUnits();
        },
        initCurrentUnits: function initCurrentUnits() {
          // CURRENT UNITS
          this.currentMin = this.data.selectedUnit == 'us' ? this.usMin : this.metricMin;
          this.currentMax = this.data.selectedUnit == 'us' ? this.usMax : this.metricMax;
          this.currentStep = this.data.selectedUnit == 'us' ? this.usStep : this.metricStep;
          this.initStyles();
        },
        initUnitLabel: function initUnitLabel() {
          var unitLabels = this.$refs.rangeMin.dataset.units ? JSON.parse(this.$refs.rangeMin.dataset.units) : null;
          this.currentUnit = unitLabels[this.data.selectedUnit];
        },
        initStyles: function initStyles() {
          this.styles = "--a: ".concat(this.minValueRange === null ? this.currentMin : this.minValueRange, "; --b: ").concat(this.maxValueRange === null ? this.currentMax : this.maxValueRange, "; --min: ").concat(this.currentMin, "; --max: ").concat(this.currentMax);
        }
      },
      mounted: function mounted() {
        var _this6 = this;

        this.initMinMax();
        this.initEvents(); // this.initUnitLabel();

        this.$nextTick(function () {
          // init slider positions
          _this6.minValueRange = _this6.data.selectedUnit == "us" ? _this6.$refs.rangeMin.dataset.usMin : _this6.$refs.rangeMin.dataset.metricMin;
          _this6.maxValueRange = _this6.data.selectedUnit == "us" ? _this6.$refs.rangeMin.dataset.usMax : _this6.$refs.rangeMin.dataset.metricMax;
          _this6.type = _this6.$refs.rangeMin.dataset.type;
          _this6.label = _this6.$refs.rangeMin.dataset.label;
        });
      }
    });

    _vueMin["default"].component('min-max-flowrange', {
      props: ['data'],
      data: function data() {
        return {
          minValue: null,
          //final values
          minValueRange: null,
          // model for range slider
          minValueInput: null,
          // model for input field
          maxValue: null,
          //final values
          maxValueRange: null,
          maxValueInput: null,
          min: null,
          // gpmMax: null,
          // gpmStep: null,
          // mhMax: null,
          // mhStep: null,
          // lpmMax: null,
          // lpmStep: null,
          currentMin: 0,
          currentMax: null,
          currentStep: null,
          styles: null,
          type: null,
          currentUnit: null,
          medium: null,
          //selected measuring medium
          label: null // display name for filter

        };
      },
      watch: {
        "data.filters": function dataFilters() {
          var types = this.data.filters.map(function (e) {
            return e.type;
          });

          if (!(types.indexOf("".concat(this.type, "Min")) > -1)) {
            this.minValue = null;
          }

          if (!(types.indexOf("".concat(this.type, "Max")) > -1)) {
            this.maxValue = null;
          }

          if (types.indexOf('measuringMedium') > -1) {
            this.medium = this.data.filters.find(function (item) {
              return item.type == 'measuringMedium';
            }).name.toLowerCase();
          } else {
            this.medium = null;
          }
        },
        "medium": function medium() {
          this.currentUnit = null;

          _eventBus["default"].$emit('remove-filter', this.data["class"], null, 'flowRangeMin');

          _eventBus["default"].$emit('remove-filter', this.data["class"], null, 'flowRangeMax');

          this.initOptions();
        },
        "currentUnit": function currentUnit() {
          var _this7 = this;

          if (this.currentUnit !== "null" && this.currentUnit !== null) {
            this.$nextTick(function () {
              // this.initMinMax();
              _this7.initStyles();

              _this7.initEvents();

              _this7.type = _this7.$refs.rangeMin.dataset.type; // clear final values

              _this7.minValue = null;
              _this7.maxValue = null; // set default slide range positions

              _this7.minValueRange = _this7.min;
              _this7.maxValueRange = _this7.currentMax; // console.log('init',this.label);

              _this7.label = _this7.label !== null ? _this7.label : _this7.$refs.rangeMin ? _this7.$refs.rangeMin.dataset.label : null; // console.log('final',this.label);
            });
          } else {
            // if no unit selected, remove flow range filters
            _eventBus["default"].$emit('remove-filter', this.data["class"], null, 'flowRangeMin');

            _eventBus["default"].$emit('remove-filter', this.data["class"], null, 'flowRangeMax');
          }
        },
        "minValue": function minValue() {
          if (this.minValue == this.currentMin || this.minValue == "") {
            this.minValue = null;

            _eventBus["default"].$emit('remove-filter', this.data["class"], null, 'flowRangeMin');
          } else if (parseFloat(this.minValue) < parseFloat(this.currentMin) || parseFloat(this.minValue) > parseFloat(this.currentMax)) {
            // this.minValue = (parseFloat(this.currentMin) - parseFloat(this.currentStep)).toString();
            this.minValue = null;

            _eventBus["default"].$emit('remove-filter', this.data["class"], null, 'flowRangeMin');
          } // this.initStyles();


          this.minValueRange = this.minValue == null ? this.min : this.minValue;
          this.minValueInput = this.minValue;

          if (this.minValue !== null) {
            this.updateFilters("Min");
          }
        },
        "maxValue": function maxValue() {
          if (this.maxValue == this.currentMax || this.maxValue == "") {
            this.maxValue = null;

            _eventBus["default"].$emit('remove-filter', this.data["class"], null, 'flowRangeMax');
          } else if (parseFloat(this.maxValue) > parseFloat(this.currentMax) || parseFloat(this.maxValue) < parseFloat(this.currentMin)) {
            // this.maxValue = (parseFloat(this.currentMax) - parseFloat(this.currentStep)).toString();
            this.maxValue = null;

            _eventBus["default"].$emit('remove-filter', this.data["class"], null, 'flowRangeMax');
          } // this.initStyles();


          this.maxValueRange = this.maxValue == null ? this.currentMax : this.maxValue;
          this.maxValueInput = this.maxValue;

          if (this.maxValue !== null) {
            this.updateFilters("Max");
          }
        },
        // globally selected us/metric unit
        "data.selectedUnit": function dataSelectedUnit() {
          // clear current flow range selection
          this.currentUnit = "null"; // show/hide options for relevant units
          // this.initUnits();

          this.initOptions();
        },
        "maxValueRange": function maxValueRange() {
          // condition to prevent dragging slider beyond the valid range
          if (parseFloat(this.maxValueRange) <= parseFloat(this.minValueRange)) {
            this.maxValueRange = (parseFloat(this.minValueRange) + parseFloat(this.currentStep)).toString();
          }

          this.maxValueInput = this.maxValueRange == this.currentMax ? null : this.maxValueRange;
          this.initStyles();
        },
        "minValueRange": function minValueRange() {
          // condition to prevent dragging slider beyond the valid range
          if (parseFloat(this.minValueRange) >= parseFloat(this.maxValueRange)) {
            this.minValueRange = (parseFloat(this.maxValueRange) - parseFloat(this.currentStep)).toString();
          }

          this.minValueInput = this.minValueRange == this.currentMin ? null : this.minValueRange;
          this.initStyles();
        }
      },
      methods: {
        updateFilters: (0, _misc.debounce)(function (type) {
          console.log("type:", type);
          var entry = {
            name: "".concat(type, " ").concat(this.label, ": ").concat(type == "Min" ? this.minValue : this.maxValue, " ").concat(this.currentUnit),
            value: type == "Min" ? this.minValue : this.maxValue,
            type: "".concat(this.type).concat(type),
            flowRangeType: this.currentUnit
          }; // console.log(entry);

          if (entry.value !== null) {
            _eventBus["default"].$emit('updateRangeFilter', entry);
          }
        }, 500),
        handleRange: (0, _misc.debounce)(function (e, type) {
          var _t = e.target;
          var min = type == "min" ? _t.value : this.minValue;
          var max = type == "max" ? _t.value : this.maxValue;

          if (type == "min") {
            if (parseFloat(min) >= parseFloat(max)) {
              min = (parseFloat(max) - parseFloat(this.currentStep)).toString();
            }
          } else if (type == "max") {
            if (parseFloat(max) <= parseFloat(min)) {
              max = (parseFloat(min) + parseFloat(this.currentStep)).toString();
            }
          }

          this.minValue = min;
          this.maxValue = max;
          this.minValueInput = this.minValueInput !== this.minValue && this.minValue !== null ? this.minValue : this.minValueInput;
          this.maxValueInput = this.maxValueInput !== this.maxValue && this.maxValue !== null ? this.maxValue : this.maxValueInput;
        }, 500),
        initEvents: function initEvents() {
          var _this8 = this;

          this.$refs.rangeMin.addEventListener('input', function (e) {
            _this8.handleRange(e, 'min');
          }, false);
          this.$refs.rangeMax.addEventListener('input', function (e) {
            _this8.handleRange(e, 'max');
          }, false);
        },
        initOptions: function initOptions() {
          var _this9 = this;

          this.$el.querySelectorAll('option').forEach(function (item) {
            var unit = item.dataset.unitType;
            var flow = item.dataset.flowType ? item.dataset.flowType.toLowerCase() : null;

            if (_this9.medium == null) {
              if (item.getAttribute('value') == "null") {
                return;
              } else if (unit == _this9.data.selectedUnit) {
                item.style.display = "block";
              } else {
                item.style.display = "none";
              }
            } else {
              if (item.getAttribute('value') == "null") {
                return;
              } else if (flow.includes(_this9.medium) && unit == _this9.data.selectedUnit) {
                item.style.display = "block";
              } else {
                item.style.display = "none";
              }
            }
          });
        },
        initStyles: function initStyles() {
          this.styles = "--a: ".concat(this.minValueRange === null ? this.currentMin : this.minValueRange, "; --b: ").concat(this.maxValueRange === null ? this.currentMax : this.maxValueRange, "; --min: ").concat(this.currentMin, "; --max: ").concat(this.currentMax);
        },
        selectUnit: function selectUnit(e) {
          this.currentUnit = e.target.value == "null" ? null : e.target.value; //set selected unit

          if (e.target.value !== "null" && e.target.value !== null) {
            var data = JSON.parse(this.$el.querySelector("option[value=\"".concat(e.target.value, "\"]")).dataset.flowData); //get min/max data for selected unit
            // set min/max data for current unit

            this.min = data.min;
            this.currentMax = data.max;
            this.currentMin = data.min;
            this.currentStep = data.step;
          }
        },
        initUnits: function initUnits() {
          var unit = this.data.selectedUnit; // console.log(unit);

          this.$el.querySelectorAll("option").forEach(function (item) {
            // console.log(item);
            if (item.getAttribute('value') == "null") {
              return;
            } else if (item.dataset.unitType !== unit) {
              item.style.display = "none";
            } else {
              item.style.display = "block";
            }
          });
        }
      },
      mounted: function mounted() {
        var _this10 = this;

        this.$nextTick(function () {
          // this.initUnits();
          _this10.initOptions(); // this.label = this.$refs.rangeMin ? this.$refs.rangeMin.dataset.label : null;

        });
      }
    });

    _vueMin["default"].component('radio-item', {
      props: ['data'],
      data: function data() {
        return {
          type: "measuringMedium",
          id: null,
          isChecked: null,
          selectedRadio: null
        };
      },
      watch: {
        "data.filters": function dataFilters() {
          this.checkState();
        }
      },
      methods: {
        updateFilters: function updateFilters(el, e, type) {
          // console.log("e", e);
          // console.log("type", type);
          _eventBus["default"].$emit('updateFilters', el, e, type);
        },
        checkState: function checkState() {
          var _this11 = this;

          var item = this.data.filters.find(function (el) {
            return el.value == _this11.id;
          });
          this.isChecked = item ? true : false;
          this.selectedRadio = item ? decodeURIComponent(item.value) : null;
        }
      },
      mounted: function mounted() {
        this.id = encodeURIComponent(this.$refs.input.value);
      }
    });

    new _vueMin["default"]({
      el: ".product-catalog-".concat(id),
      store: _store["default"]
    }).$mount(".product-catalog-".concat(id), true);
  }; // multiHandleRange();


  if (catalog.length > 0) {
    catalog.forEach(function (item, index) {
      item.classList.add("product-catalog-".concat(index));
      productCatalogConstructor(index);
    });
  }
};

var _default = ProductCatalog;
exports["default"] = _default;

},{"../../../db.json":64,"./event-bus":9,"./filter-components":11,"./misc":28,"./store":51,"axios":66,"vue/dist/vue.min.js":234}],43:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var ProductsAccessories = function ProductsAccessories() {
  var products = document.querySelectorAll('.products-acc__wrapper');

  var productsConstructor = function productsConstructor(id) {
    _vueMin["default"].component('products-accessories-template', {
      data: function data() {
        return {
          paginated: null,
          openText: '',
          collapseText: '',
          isExpanded: false,
          totalItems: null,
          initialItems: null,
          buttonText: ''
        };
      },
      watch: {
        isExpanded: function isExpanded() {
          this.buttonText = this.isExpanded ? this.collapseText : this.openText;
        },
        paginated: function paginated() {
          var _this = this;

          if (this.paginated) {
            this.$nextTick(function () {
              _this.openText = _this.$refs.openButton.dataset.openText;
              _this.collapseText = _this.$refs.openButton.dataset.collapseText;
              _this.buttonText = _this.isExpanded ? _this.collapseText : _this.openText;
            });
          }
        }
      },
      methods: {
        handleClick: function handleClick() {
          var contentArea = this.$refs.contentContainer;
          var contentHeight = this.$refs.contentInner.getBoundingClientRect().height;

          if (this.isExpanded == true) {
            this.isExpanded = false;
            requestAnimationFrame(function () {
              //set content area height to content height to prevent transitioning from auto
              contentArea.style.maxHeight = contentHeight + 'px'; // have the element transition to height: 0

              requestAnimationFrame(function () {
                contentArea.style.maxHeight = '0px';
              });
            });
            contentArea.addEventListener('transitionend', function () {
              contentArea.style.maxHeight = '0';
            });
          } else {
            this.isExpanded = true;
            contentArea.style.maxHeight = contentHeight + "px";
            contentArea.addEventListener('transitionend', function () {
              contentArea.style.maxHeight = 'none';
            });
          }
        },
        init: function init() {
          var _this2 = this;

          // init counts
          this.initialItems = this.$refs.initialContent.querySelectorAll('.product-card').length;
          this.moreItems = this.$refs.contentInner.querySelectorAll('.product-card').length;
          this.totalItems = this.initialItems + this.moreItems;
          this.paginated = this.moreItems > 0 ? true : false; // init button only if paginated

          if (this.paginated) {
            this.$nextTick(function () {
              _this2.openText = _this2.$refs.openButton.dataset.openText;
              _this2.collapseText = _this2.$refs.openButton.dataset.collapseText;
              _this2.buttonText = _this2.isExpanded ? _this2.collapseText : _this2.openText;
            });
          }
        }
      },
      mounted: function mounted() {
        this.init();
      }
    });

    new _vueMin["default"]({
      el: ".products-accessories-".concat(id),
      store: _store["default"]
    }).$mount(".products-accessories-".concat(id), true);
  };

  if (products.length > 0) {
    products.forEach(function (item, index) {
      item.classList.add("products-accessories-".concat(index));
      productsConstructor(index);
    });
  }
};

var _default = ProductsAccessories;
exports["default"] = _default;

},{"./store":51,"vue/dist/vue.min.js":234}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _modals = require("./modals");

var _store = _interopRequireDefault(require("./store"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var quickLinks = function quickLinks() {
  var links = document.querySelectorAll('.quick-links');

  _vueMin["default"].use(_vueJsModal["default"]);

  var quickLinksConstructor = function quickLinksConstructor(id) {
    _vueMin["default"].component('quick-links', {
      computed: {
        isMobile: function isMobile() {
          return _store["default"].state.isMobile;
        }
      },
      watch: {
        isMobile: function isMobile() {
          if (!this.isMobile) {
            this.$modal.hide('quickLinks');
          }
        }
      },
      methods: {
        triggerModal: function triggerModal() {
          var links = this.$refs.links.cloneNode(true);
          this.$modal.show(_modals.quickLinksModal.template, _modals.quickLinksModal.name, _modals.quickLinksModal.options, _modals.quickLinksModal.events(links));
        }
      }
    });

    new _vueMin["default"]({
      el: ".quick-links-".concat(id)
    }).$mount(".quick-links-".concat(id), true);
  };

  if (links.length > 0) {
    links.forEach(function (item, index) {
      item.classList.add("quick-links-".concat(index));
      quickLinksConstructor(index);
    });
  }
};

var _default = quickLinks;
exports["default"] = _default;

},{"./modals":30,"./store":51,"vue-js-modal":233,"vue/dist/vue.min.js":234}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _axios = _interopRequireDefault(require("axios"));

var _db = _interopRequireDefault(require("../../../db.json"));

var _misc = require("./misc");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var searchResults = function searchResults() {
  var search = document.querySelectorAll('.search-results');

  var searchResultsConstructor = function searchResultsConstructor(id) {
    _vueMin["default"].component('search-results-template', {
      data: function data() {
        return {
          data: {
            inputQuery: null,
            query: null,
            currentPage: 1,
            //current page #
            filtersVisible: null,
            //are filters visible
            filterAreaVisible: true,
            filters: [],
            results: [],
            totalResults: null,
            savedDocs: [],
            //bookmarked items
            savedDocsLabel: null,
            //label for saved docs
            isMobile: null,
            urlParams: null,
            //for deeplinking in-browser
            counts: {},
            store: _store["default"],
            didYouMean: null,
            resultsReturned: null,
            "class": 'search-results'
          },
          isLoading: null
        };
      },
      computed: {
        computedIsMobile: function computedIsMobile() {
          return _store["default"].state.isMobile;
        },
        saved: function saved() {
          return _store["default"].state.favorites;
        },
        taggingMetaL1: function taggingMetaL1() {
          return JSON.stringify({
            "type": "search-results",
            "category": "Search",
            "action": this.data.query,
            "label": this.data.totalResults || 0,
            "content": "Hero",
            "title": "Search Results",
            "name": "Hero - Search Results",
            "no": "01"
          });
        },
        taggingMetaL2: function taggingMetaL2() {
          return JSON.stringify({
            "type": "search-results",
            "category": "Search",
            "action": this.data.query,
            "label": this.data.totalResults || 0
          });
        },
        taggingTrigger: function taggingTrigger() {
          return this.data.resultsReturned ? "trigger" : null;
        }
      },
      watch: {
        saved: function saved() {
          var allSaved = [];
          var saved = _store["default"].state.favorites;

          for (var prop in saved) {
            allSaved = [].concat(_toConsumableArray(allSaved), _toConsumableArray(saved[prop]));
          }

          this.data.savedDocs = allSaved.filter(function (item) {
            return item !== "";
          });
        },
        computedIsMobile: function computedIsMobile() {
          this.data.isMobile = this.computedIsMobile;
          this.data.filtersVisible = !this.computedIsMobile ? true : this.data.filtersVisible;
          this.initSubmit();
        },
        "data.filters": function dataFilters() {
          console.log(this.data.filters);
          this.data.currentPage = 1; //reset page to 1

          this.addLoading();
          this.getResults(); // handle api call
        },
        "data.query": function dataQuery() {
          this.data.currentPage = 1; //reset page to 1 when query changes
          // this.getResults(this.data.query);
        }
      },
      methods: {
        toggleFilters: function toggleFilters() {
          if (this.data.isMobile) {
            this.data.filtersVisible = !this.data.filtersVisible;
          }
        },
        updateFilters: function updateFilters(el, e, type) {
          if (el !== 'search') {
            return;
          }

          var type = type;
          var value = encodeURIComponent(e.currentTarget.value);
          var checked = e.currentTarget.checked; // console.log("type", type)
          // console.log(e.currentTarget.name);
          // console.log("value", encodeURIComponent(e.target.value));
          // console.log("checked",e.target.checked);

          if (checked) {
            if (type !== "savedDocuments") {
              this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                "value": value,
                "type": type,
                "name": e.currentTarget.name
              }]);
            } else {
              this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                "value": checked,
                "type": type,
                "name": e.currentTarget.name
              }]);
            }
          } else {
            var index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf(value); // console.log("INDEX", index);

            this.data.filters.splice(index, 1);
          }
        },
        // removes specific filter
        removeFilter: function removeFilter(el, value, type) {
          if (el !== this.data["class"]) {
            return;
          }

          ;
          console.log("remove", value);
          var index = this.data.filters.map(function (e) {
            return e.value;
          }).indexOf(value);
          this.data.filters.splice(index, 1);
        },
        // clears filters
        removeAll: function removeAll() {
          this.data.filters = [];
        },
        addLoading: function addLoading() {
          this.isLoading = true;
          var inputField = document.querySelectorAll('.search-results__input-container');
          inputField.forEach(function (element) {
            return element.classList.add('loading');
          });
        },
        removeLoading: function removeLoading() {
          this.isLoading = false;
          var inputField = document.querySelectorAll('.search-results__input-container');
          inputField.forEach(function (element) {
            return element.classList.remove('loading');
          });
        },
        getResults: function getResults() {
          var _this = this;

          // this.data.query = query ? query : null;
          this.data.resultsReturned = true; //set this once after initial results returned

          var baseUrl = window.searchAPIUrl;
          var apiUrl = "".concat(baseUrl).concat(baseUrl.indexOf('?') > -1 ? '' : '?'); // let apiUrl = "http://localhost:3003/searchResults"; //from json-server

          var self = this;

          var savedDocumentsTrueParams = function savedDocumentsTrueParams() {
            var savedOnly = _this.data.filters.find(function (item) {
              return item.type == "savedDocuments";
            });

            if (savedOnly) {
              return true;
            } else {
              return false;
            }
          };

          var filters = [];
          this.data.filters.map(function (item) {
            if (item.value !== true && item.value !== false) {
              filters.push(item.value);
            }
          });
          var filtersStr = decodeURIComponent(filters.join('|')); // console.log(filtersStr);

          var axiosParams = {
            q: this.data.inputQuery ? this.data.inputQuery : this.data.query ? this.data.query : null,
            filters: filtersStr == "" ? null : filtersStr,
            savedDocuments: savedDocumentsTrueParams() ? savedDocumentsTrueParams() : null,
            saved: savedDocumentsTrueParams() ? this.data.savedDocs.join('|') : null,
            page: this.data.currentPage
          };
          this.data.axiosParams = axiosParams; // console.log(axiosParams);

          _axios["default"].get(apiUrl, {
            params: _objectSpread({}, axiosParams)
          }).then(function (response) {
            // console.log(response);
            ///
            /// Did you mean query logic from episerver find:
            ///
            var didyoumeanEl, didyoumeanContainer;

            if (response.data.results.length == 0) {
              didyoumeanEl = document.querySelectorAll('.global__didyoumean');
              didyoumeanContainer = document.querySelectorAll('.search-results__input-container__didyoumean');
            } else {
              didyoumeanEl = document.querySelectorAll('.global__peoplealsosearchedfor');
              didyoumeanContainer = document.querySelectorAll('.search-results__input-container__peoplealsosearchedfor');
            }

            if (response.data.didYouMean && response.data.didYouMean.length > 0) {
              var commaEl;

              (function () {
                var allElements = [];
                response.data.didYouMean.forEach(function (dym) {
                  var anchorElement = document.createElement('a');
                  anchorElement.href = "#";
                  anchorElement.innerText = dym; //anchorElement.addEventListener("click", function (e) {
                  //    self.didYouMean(e);
                  //    didyoumeanContainer.forEach(element => element.classList.remove('show'));
                  //});

                  allElements.push(anchorElement);
                }); //clear out all previous elements

                didyoumeanEl.forEach(function (parent) {
                  while (parent.firstChild) {
                    parent.removeChild(parent.firstChild);
                  }
                });

                var _loop = function _loop(i) {
                  didyoumeanEl.forEach(function (el) {
                    var anchorElement = allElements[i].cloneNode(true);
                    anchorElement.addEventListener("click", function (e) {
                      e.stopPropagation();
                      self.didYouMean(e); //didyoumeanContainer.forEach(element => element.classList.remove('show'));
                    });
                    el.append(anchorElement);
                  });

                  if (i + 1 < allElements.length) {
                    commaEl = document.createElement('span'); //commaEl.innerText = ' ';

                    commaEl.style.paddingLeft = "7px";
                    didyoumeanEl.forEach(function (el) {
                      el.append(commaEl.cloneNode(true));
                    });
                  }
                };

                for (var i = 0; i < allElements.length; i++) {
                  _loop(i);
                }

                didyoumeanContainer.forEach(function (element) {
                  return element.classList.add('show');
                });
              })();
            } else {
              didyoumeanContainer.forEach(function (element) {
                return element.classList.remove('show');
              });
            } ///
            /// End of did you mean query logic
            ///


            if (response.data.results) {
              // construct site section label into the title
              self.data.results = response.data.results.map(function (item) {
                if (item.title && item.filterText) {
                  if (item.title.indexOf("<p>") > -1) {
                    return _objectSpread(_objectSpread({}, item), {}, {
                      "title": "<p>".concat(item.filterText, " / ").concat(item.title.replace("<p>", "")),
                      "rawTitle": item.title
                    });
                  } else {
                    return _objectSpread(_objectSpread({}, item), {}, {
                      "title": "".concat(item.filterText, " / ").concat(item.title),
                      "rawTitle": item.title
                    });
                  }
                } else {
                  return _objectSpread({}, item);
                }
              }); //if (!(response.data.results.length > 0)) {
              //self.data.didYouMean = response.data.didYouMean;
              //} else {

              self.data.didYouMean = null; //}
            } else {
              self.data.results = null;
            } // self.data.results = response.data.results ? response.data.results : null; 


            self.data.totalResults = response.data.totalResults; // get counts of search result types

            self.data.counts = response.data.filterCountResults;
            self.data.trackId = response.data.trackId; // console.log(response.data);

            self.removeLoading();
          })["catch"](function (error) {
            console.log(error);
            self.removeLoading();
          });
        },
        loadMore: function loadMore() {
          // console.log("load more");
          this.data.currentPage = this.data.currentPage + 1;
          this.data.axiosParams = _objectSpread(_objectSpread({}, this.data.axiosParams), {}, {
            page: this.data.currentPage
          });
          console.log(this.data.axiosParams);
          var self = this;
          var baseUrl = window.searchAPIUrl;
          var apiUrl = "".concat(baseUrl).concat(baseUrl.indexOf('?') > -1 ? '' : '?'); // let apiUrl = "http://localhost:3003/searchResults2"; //from json-server

          _axios["default"].get(apiUrl, {
            params: _objectSpread({}, this.data.axiosParams)
          }).then(function (response) {
            // self.data.results.push(...response.data.results);
            var results = response.data.results.map(function (item) {
              if (item.title && item.filterText) {
                if (item.title.indexOf("<p>") > -1) {
                  return _objectSpread(_objectSpread({}, item), {}, {
                    "title": "<p>".concat(item.filterText, " / ").concat(item.title.replace("<p>", ""))
                  });
                } else {
                  return _objectSpread(_objectSpread({}, item), {}, {
                    "title": "".concat(item.filterText, " / ").concat(item.title)
                  });
                }
              } else {
                return _objectSpread({}, item);
              }
            }); // console.log("LOAD MORE", results);

            if (results) {
              var _self$data$results;

              (_self$data$results = self.data.results).push.apply(_self$data$results, _toConsumableArray(results));
            }
          })["catch"](function (error) {
            console.log(error);
          });
        },
        submit: function submit() {
          var didyoumeanEl = document.querySelectorAll('.global__didyoumean');
          var didyoumeanContainer = document.querySelectorAll('.search-results__input-container__didyoumean');
          didyoumeanContainer.forEach(function (element) {
            return element.classList.remove('show');
          });
          didyoumeanEl = document.querySelectorAll('.global__peoplealsosearchedfor');
          didyoumeanContainer = document.querySelectorAll('.search-results__input-container__peoplealsosearchedfor');
          didyoumeanContainer.forEach(function (element) {
            return element.classList.remove('show');
          });
          this.updateHistory(this.data.inputQuery);
          this.data.query = this.data.inputQuery; // Set loading icon states

          this.addLoading();
          this.getResults();
        },
        prefilter: function prefilter() {
          var _this2 = this;

          var params = (0, _misc.getUrlParameter)('filters');

          if (params) {
            var paramsArray = params.split(',');
            var filters = [];
            this.$nextTick(function () {
              // if has filter params, dump them into filters array
              paramsArray.forEach(function (item) {
                var name = document.querySelector("[value=\"".concat(item, "\"]")) ? document.querySelector("[value=\"".concat(item, "\"]")).getAttribute('name') : null;
                filters.push({
                  value: "".concat(item),
                  name: name
                });
              });
              _this2.data.filters = filters;
            });
          }
        },
        didYouMean: function didYouMean(e) {
          console.log('didYouMean(', e, ')');
          var query;

          if (e.target) {
            query = e.target.innerText;
          } else {
            query = e;
          }

          console.log('query = ', query, 'e = ', e, e.target);
          this.data.inputQuery = query;
          this.submit();
        },
        updateHistory: function updateHistory(q) {
          var currentParam = "?q=" + (0, _misc.getUrlParameter)('q');
          var newUrl = window.location.href.replace(currentParam, "?q=" + encodeURIComponent(q));
          history.pushState(null, '', newUrl);
        },
        navHistory: function navHistory() {
          var query = (0, _misc.getUrlParameter)('q');
          var filters = (0, _misc.getUrlParameter)('filters');
          var didyoumeanEl = document.querySelectorAll('.global__peoplealsosearchedfor');
          var didyoumeanContainer = document.querySelectorAll('.search-results__input-container__peoplealsosearchedfor');
          didyoumeanContainer.forEach(function (element) {
            return element.classList.remove('show');
          });
          didyoumeanEl = document.querySelectorAll('.global__didyoumean');
          didyoumeanContainer = document.querySelectorAll('.search-results__input-container__didyoumean');
          didyoumeanContainer.forEach(function (element) {
            return element.classList.remove('show');
          });

          if (query) {
            this.data.inputQuery = query.replace(/\+/g, " ");
            this.data.query = query.replace(/\+/g, " ");
          }

          if (filters) {
            this.prefilter();
          } else {
            this.getResults();
          }
        },
        init: function init() {
          var _this3 = this;

          // init is mobile
          this.data.isMobile = _store["default"].state.isMobile; // init saved docs

          var allSaved = [];
          var saved = _store["default"].state.favorites;

          for (var prop in saved) {
            allSaved = [].concat(_toConsumableArray(allSaved), _toConsumableArray(saved[prop]));
          }

          this.data.savedDocs = allSaved.filter(function (item) {
            return item !== "";
          }); // init filters state

          this.data.filtersVisible = this.data.isMobile ? false : true; //init 

          if (window.location.search) {
            var query = (0, _misc.getUrlParameter)('q');
            var filters = (0, _misc.getUrlParameter)('filters');
            this.data.inputQuery = query.replace(/\+/g, " ");
            this.data.query = query.replace(/\+/g, " "); // make api call for results if no filters
            // otherwise data.filters[] will update and the watcher will trigger 
            // another api call

            if (query && !filters) {
              this.getResults();
            }
          }

          window.onpopstate = function () {
            _this3.navHistory();
          }; // listen for filter updates in children


          _eventBus["default"].$on('updateFilters', function (el, e, type) {
            _this3.updateFilters(el, e, type);
          });

          _eventBus["default"].$on('remove-filter', function (el, value, type) {
            _this3.removeFilter(el, value, type);
          });

          this.initSubmit();
        },
        initSubmit: function initSubmit() {
          var self = this;

          if (this.data.isMobile) {
            this.$refs.searchBarMobile.addEventListener("keyup", function (event) {
              if (event.keyCode === 13) {
                event.preventDefault();
                self.submit();
              }
            });
          } else {
            this.$refs.searchBarDesktop.addEventListener("keyup", function (event) {
              if (event.keyCode === 13) {
                event.preventDefault();
                self.submit();
              }
            });
          }
        }
      },
      mounted: function mounted() {
        this.init();

        if (window.location.search) {
          this.prefilter();
        }
      }
    });

    _vueMin["default"].component('checkbox-item', {
      props: ['data', 'name', 'type'],
      data: function data() {
        return {
          id: null,
          isChecked: false,
          isActive: null,
          count: 0,
          label: null
        };
      },
      watch: {
        "data.filters": function dataFilters() {
          this.checkState();
        },
        "data.counts": function dataCounts() {
          this.setCount();
        }
      },
      computed: {
        taggingMeta: function taggingMeta() {
          return JSON.stringify({
            "type": "search",
            "category": "Search",
            "action": "Filters",
            "label": this.label,
            "resultCount": this.count ? this.count : ""
          });
        }
      },
      methods: {
        updateFilters: function updateFilters(el, e, type) {
          _eventBus["default"].$emit('updateFilters', el, e, type);
        },
        checkState: function checkState() {
          var _this4 = this;

          if (this.id == "Saved%20documents%20only") {
            var item = this.data.filters.find(function (el) {
              return encodeURIComponent(el.name) == _this4.id;
            });
            this.isChecked = item ? true : false;
          } else {
            var _item = this.data.filters.find(function (el) {
              return encodeURIComponent(el.value) == _this4.id;
            });

            this.isChecked = _item ? true : false;
          }
        },
        setCount: function setCount() {
          //console.log("set count")
          var paramName = this.$refs.input.value;
          var countObj = this.data.counts.filter(function (item) {
            return item.filterValue.toString() === paramName;
          })[0];
          this.count = countObj ? countObj.count : 0;
        },
        init: function init() {
          this.label = this.$refs.label.innerText;
        }
      },
      mounted: function mounted() {
        this.id = encodeURIComponent(this.$refs.input.value);
        this.checkState();
        this.init(); // this.setCount();
      }
    }); // results list


    _vueMin["default"].component('results-list', {
      props: ['data', 'isLoading'],
      data: function data() {
        return {};
      },
      template: "\n            <div class=\"search-results__cards-content\">\n                <results-item v-for=\"(result, index) in data.results\" :content=\"result\"  :key=\"index\" :data=\"data\" :isLoading=\"isLoading\"/>\n            </div>\n            ",
      methods: {},
      mounted: function mounted() {}
    }); // single results item


    _vueMin["default"].component('results-item', {
      props: ['data', 'content', 'isLoading'],
      data: function data() {
        return {
          resultType: null
        };
      },
      computed: {
        "highlightedCopy": function highlightedCopy() {
          var regex = new RegExp(this.data.query, "g");

          if (this.content.description) {
            return this.content.description.replace(regex, "<strong>".concat(this.data.query, "</strong>"));
          }
        },
        "newTabLink": function newTabLink() {
          return this.content.linkUrl ? this.content.linkUrl.replace('download=true', 'download=false') : null;
        },
        "hrefTarget": function hrefTarget() {
          if (this.newTabLink) {
            return this.newTabLink.includes('download=false') ? '_blank' : '_self';
          }
        },
        "trigger": function trigger() {
          var trackable; // for (let prop in window.searchFilterValues) {
          //     if (window.searchFilterValues[prop] == this.content.filterValue) {
          //         trackable = true;
          //     }
          // }

          return trackable ? "click" : null;
        },
        "taggingMeta": function taggingMeta() {
          var meta; // if (this.resultType) {
          //     switch (this.resultType) {
          //         case 'documentation':
          //             meta = {
          //                 "type": "document",
          //                 "category": "",
          //                 "label": "",
          //                 "productLine": "",
          //                 "language": ""
          //             }
          //             break;
          //         case 'software':
          //             meta = {
          //                 "type": "app",
          //                 "category": "",
          //                 "label": "",
          //                 "productLine": "",
          //                 "language": ""
          //             }
          //             break;
          //         case 'products':
          //             meta = {    
          //                 "type": "layer",
          //                 "category": "Preview Card",
          //                 "productLine": "",
          //                 "label": this.content.rawTitle
          //             }
          //             break;
          //         default:
          //             return;
          //     }
          // }

          return meta ? JSON.stringify(meta) : null;
        }
      },
      template: "\n            <div class=\"results-card\">\n            <a :href=\"newTabLink\" class=\"results-card__link\" :target=\"hrefTarget\" :data-tag-trigger=\"trigger\" :data-tag-meta=\"taggingMeta\">\n                <div class=\"results-card__wrapper\">\n                    <div class=\"results-card__row\">\n                        <div class=\"results-card__area results-card__area-image\" v-if=\"content.imageUrl\">\n                            <div class=\"results-card__image-container\">\n                                <img :src=\"content.imageUrl\" class=\"results-card__image\">\n                            </div>\n                        </div>\n                        <div class=\"results-card__area results-card__area-copy\">\n                            <div class=\"results-card__title\" v-html=\"content.title\">\n                            </div>\n                            <div class=\"results-card__copy\" v-html=\"highlightedCopy\">\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </a>\n            </div>\n            ",
      methods: {
        init: function init() {
          for (var prop in window.searchFilterValues) {
            if (window.searchFilterValues[prop] == this.content.filterValue) {
              this.resultType = prop;
            }
          }
        }
      },
      mounted: function mounted() {
        // this.init();
        var self = this;
        this.$nextTick(function () {
          var trackId = self.data.trackId;

          if (trackId) {
            var hitId = self.content.hitId;
            var query = self.data.query;
            var url = "/api/SearchHit?q=".concat(encodeURIComponent(query), "&h=").concat(encodeURIComponent(hitId), "&t=").concat(encodeURIComponent(trackId));
            var allAnchors = self.$el.querySelectorAll('a');
            allAnchors.forEach(function (el) {
              return el.addEventListener('click', function (e) {
                return _axios["default"].get(url).then(function (response) {//console.log("--> Tracking response: ", response);
                });
              });
            });
          }
        });
      }
    });

    _vueMin["default"].component('selectedFilters', {
      props: ['data'],
      data: function data() {
        return {};
      },
      template: "\n                <div class=\"search-results__selected-filters\" :data=\"data\">\n                    <div class=\"filter-label\" v-for=\"filter in data.filters\" :key=\"filter.value\" :data-value=\"filter.value\" :data-type=\"filter.type\" v-on:click=\"removeFilter($event)\">\n                        <div class=\"filter-label__wrapper\">\n                            <span class=\"filter-label__icon\"></span>\n                            <span class=\"filter-label__text\">{{filter.name}}</span>\n                        </div>\n                    </div>\n                </div>\n            ",
      methods: {
        removeFilter: function removeFilter(e) {
          var type = e.currentTarget.dataset.type;
          var value = e.currentTarget.dataset.value; // console.log(e.currentTarget);

          _eventBus["default"].$emit('remove-filter', this.data["class"], value, type);
        }
      },
      mounted: function mounted() {}
    });

    _vueMin["default"].component('filter-accordion-template', {
      props: ['data'],
      data: function data() {
        return {
          isOpen: false //is the accordion open

        };
      },
      computed: {
        productFilters: function productFilters() {
          return this.data.products;
        }
      },
      watch: {},
      methods: {
        handleClick: function handleClick() {
          this.toggleAccordion();
        },
        toggleAccordion: function toggleAccordion() {
          var contentArea = this.$refs.outerContainer;
          var contentHeight = this.$refs.innerContainer.getBoundingClientRect().height;

          if (this.isOpen == true) {
            this.isOpen = false;
            requestAnimationFrame(function () {
              //set content area height to content height to prevent transitioning from auto
              contentArea.style.maxHeight = contentHeight + 'px'; // have the element transition to height: 0

              requestAnimationFrame(function () {
                contentArea.style.maxHeight = '0px';
              });
            });
            contentArea.addEventListener('transitionend', function () {
              contentArea.style.maxHeight = '0';
            });
          } else {
            this.isOpen = true;
            contentArea.style.maxHeight = contentHeight + "px";
            contentArea.addEventListener('transitionend', function () {
              contentArea.style.maxHeight = 'none';
            });
          }
        }
      },
      mounted: function mounted() {}
    });

    new _vueMin["default"]({
      el: ".search-results-".concat(id),
      store: _store["default"]
    }).$mount(".search-results-".concat(id), true);
  };

  if (search.length > 0) {
    search.forEach(function (item, index) {
      item.classList.add("search-results-".concat(index));
      searchResultsConstructor(index);
    });
  } // window.searchFilterValues = {
  //     documentation: 157,
  //     software: 59,
  //     products: 158
  // }

};

var _default = searchResults;
exports["default"] = _default;

},{"../../../db.json":64,"./event-bus":9,"./misc":28,"./store":51,"axios":66,"vue/dist/vue.min.js":234}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _modals = require("./modals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var softwareCard = function softwareCard() {
  _vueMin["default"].use(_vueJsModal["default"]);

  var software = document.querySelectorAll('.softward-card--nofilter');

  var softwareCardConstructor = function softwareCardConstructor(id) {
    _vueMin["default"].component('software-card-single', {
      data: function data() {
        return {
          isBookmarked: false,
          id: null,
          type: null
        };
      },
      computed: {
        saved: function saved() {
          return _store["default"].state.favorites["".concat(this.type)];
        }
      },
      watch: {
        saved: function saved() {
          this.isBookmarked = this.saved.includes(this.id) ? true : false;
        }
      },
      methods: {
        handleBookmark: function handleBookmark() {
          _store["default"].commit('updateFavorites', {
            id: this.id,
            type: this.type,
            action: this.isBookmarked ? "remove" : "add"
          });

          _store["default"].dispatch('checkFavorites');
        },
        toggleModal: function toggleModal() {
          var releaseNotes = this.$refs.releaseNotes.innerHTML;
          this.$modal.show(_modals.releaseNotesModal.template(releaseNotes), _modals.releaseNotesModal.name, _modals.releaseNotesModal.options);
        }
      },
      mounted: function mounted() {
        this.id = this.$refs.bookmark.dataset.softwareId ? this.$refs.bookmark.dataset.softwareId : null;
        this.type = "softwareId";
        this.isBookmarked = this.saved.includes("".concat(this.id)) ? true : false;
      }
    });

    new _vueMin["default"]({
      el: ".software-card--nofilter-".concat(id)
    }).$mount(".software-card--nofilter-".concat(id), true);
  };

  if (software.length > 0) {
    software.forEach(function (item, index) {
      item.classList.add("software-card--nofilter-".concat(index));
      softwareCardConstructor(index);
    });
  }
};

var _default = softwareCard;
exports["default"] = _default;

},{"./modals":30,"./store":51,"vue-js-modal":233,"vue/dist/vue.min.js":234}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

var _axios = _interopRequireDefault(require("axios"));

var _db = _interopRequireDefault(require("../../../db.json"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _modals = require("./modals");

var _filterComponents = require("./filter-components");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var safeString = function safeString(str) {
  return encodeURIComponent(str);
};

var Software = function Software() {
  var software = document.querySelectorAll('.software');

  _vueMin["default"].use(_vueJsModal["default"]);

  var softwareConstructor = function softwareConstructor(id) {
    _vueMin["default"].component('software-template', {
      data: function data() {
        return {
          data: {
            currentPage: 1,
            //current page #
            totalPages: null,
            //total returns pages
            totalResults: null,
            //total results
            shownResults: null,
            //total shown items
            filtersVisible: null,
            //are filters visible
            filterAreaVisible: true,
            filters: [],
            products: [],
            results: [],
            savedDocs: [],
            //bookmarked items
            savedDocsLabel: null,
            //label for saved docs
            savedDocsOnly: null,
            //is saved docs only checked
            isMobile: null,
            nextActive: null,
            prevActive: null,
            // apiUrl: null, //for api call
            urlParams: null,
            //for deeplinking in-browser
            // store: store
            query: null,
            releaseNotesLabel: null,
            "class": 'software',
            trackingType: 'app'
          },
          isLoading: null
        };
      },
      components: {
        'filter-accordion-template': _filterComponents.Accordion,
        'selectedFilters': _filterComponents.SelectedFiltersComponent,
        'checkbox-item': _filterComponents.Checkbox,
        'pagination': _filterComponents.Pagination
      },
      computed: {
        computedIsMobile: function computedIsMobile() {
          return _store["default"].state.isMobile;
        },
        saved: function saved() {
          return _store["default"].state.favorites.softwareId[0] == "" ? _store["default"].state.favorites.softwareId.slice(1) : _store["default"].state.favorites.softwareId;
        },
        pageRange: function pageRange() {
          if (this.data.totalResults > 10) {
            if (this.data.currentPage == 1) {
              return "1-".concat(this.data.shownResults);
            } else if (this.data.currentPage == this.data.totalPages) {
              return "".concat(this.data.totalResults - this.data.shownResults + 1, "-").concat(this.data.totalResults);
            } else {
              return "".concat(this.data.shownResults * (this.data.currentPage - 1) + 1, "-").concat(this.data.shownResults * this.data.currentPage);
            }
          } else {
            return this.data.shownResults;
          }
        },
        siteLang: function siteLang() {
          return _store["default"].state.currentLang;
        }
      },
      watch: {
        saved: function saved() {
          this.data.savedDocs = this.saved; // remove saved only filter if no saved items

          if (this.saved.length == 0) {
            var index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf('savedDownloads');

            if (index > -1) {
              this.data.filters.splice(index, 1);
            }
          }
        },
        computedIsMobile: function computedIsMobile() {
          this.data.isMobile = this.computedIsMobile;
          this.data.filtersVisible = !this.computedIsMobile ? true : this.data.filtersVisible;
        },
        "data.filters": function dataFilters() {
          var _this = this;

          this.addLoading();
          this.getResults(); // handle api call
          // this.updateHistory(); // handle history record
          // this.data.currentPage = 1; //reset page to 1
          // check for if productline is selected

          var productLines = this.data.filters.filter(function (el) {
            return el.type == "productline";
          }).map(function (el) {
            return el.value;
          }); // set savedDocsOnly value

          var savedOnly = this.data.filters.find(function (item) {
            return item.type == "savedSoftware";
          });
          this.data.savedDocsOnly = savedOnly ? savedOnly.value : null;

          if (productLines.length > 0) {
            this.populateProducts(productLines);
          } else {
            //if not brand selected, empty the products array
            this.data.products = []; // remove selected product filters

            this.data.filters.filter(function (el) {
              return el.type == "product";
            }).forEach(function (item) {
              _this.removeFilter(_this.data["class"], item.value);
            });
          }
        },
        "data.currentPage": function dataCurrentPage() {
          if (this.data.currentPage == 1) {
            this.data.nextActive = true;
            this.data.prevActive = false;
          } else if (this.data.currentPage == this.data.totalPages) {
            this.data.nextActive = false;
            this.data.prevActive = true;
          } else {
            this.data.nextActive = true;
            this.data.prevActive = true;
          } // this.getResults();
          // this.updateHistory();

        },
        "data.totalResults": function dataTotalResults() {
          this.initPages();
        }
      },
      methods: {
        toggleFilters: function toggleFilters() {
          // console.log("clicked");
          if (this.data.isMobile) {
            // console.log("is mobile");
            this.data.filtersVisible = !this.data.filtersVisible;
          }
        },
        updateFilters: function updateFilters(el, e, type) {
          if (el !== this.data["class"]) {
            return;
          }

          var type = type;
          var value = safeString(e.currentTarget.value);
          var label = e.currentTarget.parentNode.innerText;
          var checked = e.currentTarget.checked;
          this.data.currentPage = 1; //reset page to 1 when new filters added/removed
          // console.log("type", type)
          // console.log(e);
          // console.log("value", safeString(e.target.value));
          // console.log("checked",e.target.checked);

          if (checked) {
            if (type !== "savedSoftware") {
              this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                "value": value,
                "type": type,
                "name": label
              }]);
            } else {
              this.data.filters = [].concat(_toConsumableArray(this.data.filters), [{
                "value": checked,
                "type": type,
                "name": label
              }]);
            }
          } else {
            var index = this.data.filters.map(function (e) {
              return e.value;
            }).indexOf(value); // console.log("INDEX", index);

            this.data.filters.splice(index, 1);
          }
        },
        // removes specific filter
        removeFilter: function removeFilter(el, value, type) {
          if (el !== this.data["class"]) {
            return;
          }

          var index = this.data.filters.map(function (e) {
            return e.value;
          }).indexOf(value);
          this.data.filters.splice(index, 1);
        },
        // clears filters
        removeAll: function removeAll() {
          this.data.filters = [];
          this.data.currentPage = 1; //reset page to 1
        },
        populateProducts: function populateProducts(productLines) {
          var productLineStr = decodeURIComponent(productLines.join('|')); // console.log(brandStr);

          var baseUrl = window.softwareAPIUrl;
          var apiUrl = "/api/GetSoftwareProductsByBrand"; // let apiUrl = "http://localhost:3003/productsByBrand"; //from json-server

          var self = this;

          _axios["default"].get(apiUrl, {
            params: {
              brand: productLineStr,
              lang: this.siteLang
            }
          }).then(function (response) {
            // console.log(response);
            self.data.products = response.data.results;
          })["catch"](function (error) {
            console.log(error);
          });
        },
        didYouMean: function didYouMean(e) {
          var didyoumeanEl = document.querySelectorAll('.peoplealsosearchedfor');
          var didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__peoplealsosearchedfor');
          didyoumeanContainer.forEach(function (element) {
            return element.classList.remove('show');
          });
          didyoumeanEl = document.querySelectorAll('.didyoumean');
          didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__didyoumean');
          didyoumeanContainer.forEach(function (element) {
            return element.classList.remove('show');
          }); //console.log('didYouMean',e);

          var query;

          if (e.target) {
            query = e.target.innerText;
          } else {
            query = e;
          } //console.log('query = ',query, 'e = ', e, e.target);


          this.data.query = query; //this.updateHistory();

          document.querySelector('.hero-center__search-input').value = query;
          this.addLoading();
          this.getResults();
        },
        getResults: function getResults(query) {
          var _this2 = this;

          // let apiUrl = "api/documents?";
          this.data.query = query === null ? null : query ? query : this.data.query;
          this.data.currentPage = query ? 1 : this.data.currentPage; // this.getUrl();

          var baseUrl = window.softwareAPIUrl;
          var apiUrl = "".concat(baseUrl).concat(baseUrl.indexOf('?') > -1 ? '' : '?'); // let apiUrl = "http://localhost:3003/software"; //from json-server
          // let apiUrlTest = "http://localhost:3003/documentationTest"; //from json-server

          var self = this;

          var savedDocumentsTrueParams = function savedDocumentsTrueParams() {
            var savedOnly = _this2.data.filters.find(function (item) {
              return item.type == "savedSoftware";
            });

            if (savedOnly) {
              return true;
            } else {
              return false;
            }
          };

          var product = [];
          var lang = [];
          var productLine = [];
          var downloadType = [];
          this.data.filters.map(function (item) {
            switch (item.type) {
              case "product":
                product.push(item.value);
                break;

              case "lang":
                lang.push(item.value);
                break;

              case "productline":
                productLine.push(item.value);
                break;

              case "downloadType":
                downloadType.push(item.value);
                break;

              default:
                return;
            }
          });
          var productStr = decodeURIComponent(product.join('|'));
          var langStr = decodeURIComponent(lang.join('|'));
          var productLineStr = decodeURIComponent(productLine.join('|'));
          var downloadTypeStr = decodeURIComponent(downloadType.join('|'));
          var axiosParams = {
            q: this.data.query ? this.data.query : null,
            saved: this.data.savedDocs.join('|') == "" ? null : this.data.savedDocs.join('|').charAt(0) == "," ? this.data.savedDocs.join('|').slice(1) : this.data.savedDocs.join('|'),
            //@TODO make this less insane. Send NULL if empty string. Remove leading comma if present.
            product: productStr == "" ? null : productStr,
            language: langStr == "" ? null : langStr,
            productLine: productLineStr == "" ? null : productLineStr,
            downloadType: downloadTypeStr == "" ? null : downloadTypeStr,
            savedSoftware: savedDocumentsTrueParams(),
            page: this.data.currentPage,
            lang: this.siteLang
          }; // console.log(axiosParams);

          _axios["default"].get(apiUrl, {
            params: _objectSpread({}, axiosParams)
          }).then(function (response) {
            // console.log(response);
            ///
            /// Did you mean query logic from episerver find:
            ///
            var didyoumeanEl, didyoumeanContainer;

            if (response.data.results.length == 0) {
              didyoumeanEl = document.querySelectorAll('.didyoumean');
              didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__didyoumean');
            } else {
              didyoumeanEl = document.querySelectorAll('.peoplealsosearchedfor');
              didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__peoplealsosearchedfor');
            }

            if (response.data.didYouMean && response.data.didYouMean.length > 0) {
              var commaEl;

              (function () {
                var allElements = [];
                response.data.didYouMean.forEach(function (dym) {
                  var anchorElement = document.createElement('a');
                  anchorElement.href = "#";
                  anchorElement.innerText = dym;
                  anchorElement.addEventListener("click", function (e) {
                    e.stopPropagation();
                    self.didYouMean(anchorElement.innerText);
                  });
                  allElements.push(anchorElement);
                }); //clear out all previous elements

                didyoumeanEl.forEach(function (parent) {
                  while (parent.firstChild) {
                    parent.removeChild(parent.firstChild);
                  }
                }); //console.log('  --> Appending to ', didyoumeanEl);

                var _loop = function _loop(i) {
                  didyoumeanEl.forEach(function (el) {
                    return el.append(allElements[i]);
                  });

                  if (i + 1 < allElements.length) {
                    commaEl = document.createElement('span');
                    commaEl.style.paddingLeft = "7px";
                    didyoumeanEl.forEach(function (el) {
                      return el.append(commaEl);
                    });
                  }
                };

                for (var i = 0; i < allElements.length; i++) {
                  _loop(i);
                }

                didyoumeanContainer.forEach(function (element) {
                  return element.classList.add('show');
                });
              })();
            } else {
              didyoumeanContainer.forEach(function (element) {
                return element.classList.remove('show');
              });
            } ///
            /// End of did you mean query logic
            ///


            self.data.results = response.data.results;
            self.data.totalResults = response.data.totalResults;
            self.data.shownResults = response.data.results.length;
            self.data.trackId = response.data.trackId;
            self.removeLoading();
          })["catch"](function (error) {
            console.log(error);
            self.removeLoading();
          });
        },
        changePage: function changePage(dir) {
          if (dir == "prev" && this.data.currentPage !== 1) {
            this.data.currentPage--;
          } else if (dir == "next" && this.data.currentPage !== this.data.totalPages) {
            this.data.currentPage++;
          } else {
            return;
          }

          _eventBus["default"].$emit('scroll-to-top', this.data["class"]);

          this.addLoading();
          this.getResults();
        },
        scrollToTop: function scrollToTop(el) {
          if (el !== this.data["class"]) {
            return;
          }

          var top = this.$el.querySelector('.software__area-cards').getBoundingClientRect().top + window.scrollY - 100; // console.log(top);

          setTimeout(function () {
            window.scrollTo({
              top: top,
              behavior: 'smooth'
            });
          }, 500);
        },
        initPages: function initPages() {
          // based on total result count, divide by 10 to get total pages needed
          // math ceil to round up
          // set active for prev/next based on current page
          this.data.totalPages = Math.ceil(this.data.totalResults / 10);
          this.data.prevActive = this.data.currentPage !== 1 ? true : false;
          this.data.nextActive = this.data.currentPage !== this.data.totalPages ? true : false;
        },
        addLoading: function addLoading() {
          this.isLoading = true;
          var inputField = document.querySelector('.hero-center__search-input-container');
          inputField.classList.add('loading');
        },
        removeLoading: function removeLoading() {
          this.isLoading = false;
          var inputField = document.querySelector('.hero-center__search-input-container');
          inputField.classList.remove('loading');
        },
        init: function init() {
          var _this3 = this;

          this.data.isMobile = _store["default"].state.isMobile;
          this.data.savedDocs = _store["default"].state.favorites.softwareId[0] == "" ? _store["default"].state.favorites.softwareId.slice(1) : _store["default"].state.favorites.softwareId;
          this.data.filtersVisible = this.data.isMobile ? false : true; //init show/hide filters if/is mobile
          // listen for filter updates in children

          _eventBus["default"].$on('updateFilters', function (el, e, type) {
            _this3.updateFilters(el, e, type);
          });

          _eventBus["default"].$on('remove-filter', function (el, value, type) {
            _this3.removeFilter(el, value, type);
          });

          _eventBus["default"].$on('change-page-to', function (el, num) {
            if (el !== _this3.data["class"]) {
              return;
            }

            ;
            _this3.data.currentPage = num;

            _this3.addLoading();

            _this3.getResults();
          });

          _eventBus["default"].$on('internal-search', function (value, type) {
            if (type == "software") {
              var didyoumeanEl = document.querySelectorAll('.peoplealsosearchedfor');
              var didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__peoplealsosearchedfor');
              didyoumeanContainer.forEach(function (element) {
                return element.classList.remove('show');
              });
              didyoumeanEl = document.querySelectorAll('.didyoumean');
              didyoumeanContainer = document.querySelectorAll('.hero-center__search-input-container__didyoumean');
              didyoumeanContainer.forEach(function (element) {
                return element.classList.remove('show');
              });

              _this3.addLoading();

              _this3.getResults(value);
            }
          });

          _eventBus["default"].$on('scroll-to-top', function (el) {
            _this3.scrollToTop(el);
          }); // init results


          this.data.results = window.initialSoftwareApiResults.results;
          this.data.totalResults = window.initialSoftwareApiResults.totalResults;
          this.data.shownResults = window.initialSoftwareApiResults.results.length;
          this.data.releaseNotesLabel = window.initialSoftwareApiResults.releaseNotesLabel; // this.data.results = fpodb.software.results;
          // this.data.totalResults = fpodb.software.totalResults;
          // this.data.shownResults = fpodb.software.results.length;
          // this.data.releaseNotesLabel = fpodb.software.releaseNotesLabel;

          this.data.filterAreaVisible = parseInt(this.data.totalResults) <= 10 ? false : true; // window.onpopstate = () => {
          //     this.deeplink();
          // }
        }
      },
      mounted: function mounted() {
        this.init();
        this.initPages(); // for deeplinking
        // if (window.location.search) {
        //     this.$nextTick(() => {
        //         this.deeplink();
        //     });
        // }
      }
    });

    _vueMin["default"].component('software-products', {
      props: ['data', 'category'],
      data: function data() {
        return {
          type: "product"
        };
      },
      components: {
        'checkbox-item': _filterComponents.Checkbox
      },
      template: "\n            <div class=\"software__products-content\">\n                <checkbox-item v-for=\"(productItem, i) in data.products\" :key=i :type=\"type\" :label=\"productItem.value\" :value=\"productItem.key\" :data=\"data\" :category=\"category\"/>\n            </div>\n            ",
      methods: {},
      mounted: function mounted() {}
    }); // results list


    _vueMin["default"].component('software-results-list', {
      props: ['data', 'isLoading'],
      data: function data() {
        return {
          type: "software"
        };
      },
      template: "\n            <div class=\"software__cards-content\" :data=\"data\">\n                <software-results-item v-for=\"(result, index) in data.results\" :content=\"result\"  :key=\"index\" :data=\"data\" :isLoading=\"isLoading\" />\n            </div>\n            ",
      methods: {},
      mounted: function mounted() {}
    }); // single results item


    _vueMin["default"].component('software-results-item', {
      props: ['data', 'content', 'isLoading'],
      data: function data() {
        return {
          // isChecked: false,
          isBookmarked: false,
          id: null
        };
      },
      computed: {
        saved: function saved() {
          return _store["default"].state.favorites.softwareId;
        },
        tagMetaBody: function tagMetaBody() {
          return JSON.stringify({
            "type": "app",
            "category": this.content.downloadType,
            "label": this.content.name,
            "productLine": this.content.eyebrow,
            "language": this.content.languages.toString()
          });
        }
      },
      watch: {
        saved: function saved() {
          this.isBookmarked = this.saved.includes(this.id) ? true : false;
        },
        "content": function content() {
          var _this4 = this;

          this.$nextTick(function () {
            // console.log(this.$refs.bookmark.dataset.softwareId);
            _this4.id = _this4.$refs.bookmark.dataset.softwareId;
            _this4.isBookmarked = _this4.saved.includes("".concat(_this4.id)) ? true : false;
            console.log('software-results-item - watch() content -> this', _this4);
          });
        }
      },
      template: "\n            <div class=\"software-card\" :data=\"data\" :class=\"{'hide-bookmark': (data.savedDocsOnly === true) && (isBookmarked === false)}\" data-tag-trigger=\"click\" :data-tag-meta=\"tagMetaBody\">\n                <div class=\"software-card__wrapper\">\n                    <div class=\"software-card__row\">\n                        <div class=\"software-card__area software-card__area-left\">\n                            <span class=\"software-card__eyebrow\">\n                                {{content.eyebrow}}\n                            </span>\n                            <a :href=\"content.viewDetailsUrl\" class=\"software-card__title\" v-if=\"content.viewDetailsUrl\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"app\", \"action\": \"Details\"}'>\n                                {{content.name}}\n                            </a>\n                            <div class=\"software-card__title\" v-if=\"!content.viewDetailsUrl\">\n                                {{content.name}}\n                            </div>\n                            <span class=\"software-card__subtitle\" ref=\"details\">\n                                {{content.details}} <span v-if=\"content.releaseNotes\">| </span><a href=\"#\" v-on:click.prevent=\"triggerModal\" v-if=\"content.releaseNotes\">{{data.releaseNotesLabel}} <span class=\"release-notes\" ref=\"releaseNotes\">{{content.releaseNotes}}</span></a>\n                            </span>\n                        </div>\n                        <div class=\"software-card__area software-card__area-right\">\n                            <a class=\"software-card__icon software-card__icon-download\" :data-download-url=\"content.downloadUrl\" :data-download-name=\"content.name\" :href=\"content.downloadHref\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"app\", \"action\": \"Download\"}'></a>\n                            <a class=\"software-card__icon software-card__icon-bookmark\" ref=\"bookmark\" :data-software-id=\"content.id\" v-on:click.prevent=\"handleBookmark\" :class=\"{active: isBookmarked}\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"app\", \"action\": \"Favorite\"}'></a>\n                            <a class=\"software-card__icon software-card__icon-arrow\" :class=\"{inactive: content.viewDetailsUrl == undefined}\" :href=\"content.viewDetailsUrl\" data-tag-trigger=\"click\" data-tag-meta='{\"type\": \"app\", \"action\": \"Details\"}'></a>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            ",
      methods: {
        handleBookmark: function handleBookmark() {
          _store["default"].commit('updateFavorites', {
            id: this.id,
            type: "softwareId",
            action: this.isBookmarked ? "remove" : "add"
          });

          _store["default"].dispatch('checkFavorites');
        },
        // initReleaseNotes() {
        //     this.$refs.details.addEventListener('click', (e) => {
        //         e.preventDefault();
        //         this.triggerModal();
        //     });
        // },
        triggerModal: function triggerModal() {
          this.$modal.show(_modals.releaseNotesModal.template(this.content.releaseNotes), _modals.releaseNotesModal.name, _modals.releaseNotesModal.options);
        }
      },
      mounted: function mounted() {
        this.id = this.$refs.bookmark.dataset.softwareId; // console.log("saved",this.saved);

        this.isBookmarked = this.saved.includes("".concat(this.id)) ? true : false; // this.initReleaseNotes();

        var self = this;
        this.$nextTick(function () {
          var trackId = self.data.trackId;

          if (trackId) {
            var hitId = self.content.hitId;
            var query = self.data.query;
            var url = "/api/SearchHit?q=".concat(encodeURIComponent(query), "&h=").concat(encodeURIComponent(hitId), "&t=").concat(encodeURIComponent(trackId));
            var allAnchors = self.$el.querySelectorAll('a');
            allAnchors.forEach(function (el) {
              return el.addEventListener('click', function (e) {
                return _axios["default"].get(url).then(function (response) {//console.log("--> Tracking response: ", response);
                });
              });
            });
          }
        });
      }
    });

    new _vueMin["default"]({
      el: ".software-".concat(id),
      store: _store["default"]
    }).$mount(".software-".concat(id), true);
  };

  if (software.length > 0) {
    software.forEach(function (item, index) {
      item.classList.add("software-".concat(index));
      softwareConstructor(index);
    });
  }
};

var _default = Software;
exports["default"] = _default;

},{"../../../db.json":64,"./event-bus":9,"./filter-components":11,"./modals":30,"./store":51,"axios":66,"vue-js-modal":233,"vue/dist/vue.min.js":234}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.specTableLoadMore = exports.specsTableTemplate = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// const SpecTable = () => {
// const tables = document.querySelectorAll('.spec-table');
// const specTableConstructor = (id) => {
var specsTableTemplate = function specsTableTemplate() {
  _vueMin["default"].component('spec-table-template', {
    props: ['selectedItem'],
    data: function data() {
      return {
        selectedUnit: _store["default"].state.units,
        usLabel: '',
        metricLabel: '',
        labelText: '',
        store: _store["default"],
        switchToText: '',
        loadMore: true,
        isOpen: null
      };
    },
    computed: {
      computedUnit: function computedUnit() {
        return _store["default"].state.units;
      },
      taggingMeta: function taggingMeta() {
        return JSON.stringify({
          "type": "cta",
          "category": "View all",
          "action": "Specifications",
          "label": this.selectedItem ? this.selectedItem : ""
        });
      }
    },
    watch: {
      computedUnit: function computedUnit() {
        this.selectedUnit = this.computedUnit;
        this.setLabels();
      }
    },
    methods: {
      toggleUnits: function toggleUnits() {
        _store["default"].commit('setUnits');
      },
      setLabels: function setLabels() {
        this.labelText = this.selectedUnit == 'us' ? this.usLabel : this.metricLabel;
        this.switchToText = this.selectedUnit == 'us' ? this.metricLabel : this.usLabel;
      },
      handleViewAll: function handleViewAll() {
        this.$refs.loadMore.viewAll();
      }
    },
    mounted: function mounted() {
      var _this = this;

      // get labels from mark up to accomodate multi lang
      this.usLabel = this.$refs.unitToggler.dataset.usLabel;
      this.metricLabel = this.$refs.unitToggler.dataset.metricLabel;
      this.setLabels();

      _eventBus["default"].$on('toggleOpen', function (state) {
        _this.isOpen = state;
      });
    }
  });
};

exports.specsTableTemplate = specsTableTemplate;

var specTableLoadMore = function specTableLoadMore() {
  _vueMin["default"].component('specifications-load-more', {
    props: ['labelText', 'switchToText', 'selectedUnit', 'isOpen'],
    data: function data() {
      return {
        innerHeight: null // isOpen: false

      };
    },
    methods: {
      viewAll: function viewAll() {
        var contentArea = this.$refs.allContainer;
        var contentHeight = this.innerHeight;

        if (this.isOpen == true) {
          // this.isOpen = false;
          _eventBus["default"].$emit('toggleOpen', false);

          requestAnimationFrame(function () {
            //set content area height to content height to prevent transitioning from auto
            contentArea.style.maxHeight = contentHeight + 'px'; // have the element transition to height: 0

            requestAnimationFrame(function () {
              contentArea.style.maxHeight = '0px';
            });
          });
          contentArea.addEventListener('transitionend', function () {
            contentArea.style.maxHeight = '0';
          });
        } else {
          // this.isOpen = true;
          _eventBus["default"].$emit('toggleOpen', true);

          contentArea.style.maxHeight = contentHeight + "px";
          contentArea.addEventListener('transitionend', function () {
            contentArea.style.maxHeight = 'none';
          });
        }
      }
    },
    mounted: function mounted() {
      this.innerHeight = this.$refs.allInner.getBoundingClientRect().height;
    }
  });
}; // new Vue({
//     el: `.spec-table-${id}`,
//     store: store,
// }).$mount(`.spec-table-${id}`, true);
// }
// if (tables.length > 0) {
//     tables.forEach((item, index) => {
//         item.classList.add(`spec-table-${index}`);
//         specTableConstructor(index);
//     })
// }
// }
// export default SpecTable;


exports.specTableLoadMore = specTableLoadMore;

},{"./event-bus":9,"./store":51,"vue/dist/vue.min.js":234}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _specTable = require("./spec-table");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Specifications = function Specifications() {
  var specs = document.querySelectorAll('.specs .page-section__wrapper');

  var specsConstructor = function specsConstructor(id) {
    _vueMin["default"].component('specifications-template', {
      data: function data() {
        return {
          selectedItem: null,
          selectedUrl: null
        };
      },
      computed: {
        tagMetaSelect: function tagMetaSelect() {
          return JSON.stringify({
            "type": "document",
            "category": "Product Data Sheet",
            "action": "Download",
            "label": this.selectedItem
          });
        },
        tagMetaCSI: function tagMetaCSI() {
          return JSON.stringify({
            "type": "document",
            "category": "CSI Specifications",
            "action": "Download",
            "label": this.selectedItem
          });
        }
      },
      methods: {
        selectItem: function selectItem(e) {
          var select = this.$refs.dropdown;
          var text = select.options[select.selectedIndex].text;
          this.selectedItem = text;

          if (e) {
            this.selectedUrl = e.target.value;
          } else {
            this.selectedUrl = select.options[select.selectedIndex].value;
          }
        },
        submit: function submit(e) {
          // console.log(e.target);
          window.open(this.selectedUrl, '_blank');
        }
      },
      mounted: function mounted() {
        this.selectItem();
      }
    });

    new _vueMin["default"]({
      el: ".specs-".concat(id),
      store: _store["default"]
    }).$mount(".specs-".concat(id), true);
  };

  (0, _specTable.specsTableTemplate)();
  (0, _specTable.specTableLoadMore)();

  if (specs.length > 0) {
    specs.forEach(function (item, index) {
      item.classList.add("specs-".concat(index));
      specsConstructor(index);
    });
  }
};

var _default = Specifications;
exports["default"] = _default;

},{"./spec-table":48,"./store":51,"vue/dist/vue.min.js":234}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.LocalStorageManager = exports.SessionStorageManager = void 0;

/*
    #StorageManager
       This component provides an interface to control and store the information with different kinds of storage. By default use SessionStorageManager (SessionStorage).

        # get:
           This method is for reading a value stored

        # set:
           This method is to store a value

        # remove:
           This method is to remove a value stored

        # addTimes:
           This method is to add a number to a integer value stored

        # subTimes:
           This method is to subtract a number to a integer value stored
*/
var StorageManager = function StorageManager(manager) {
  var instance = {
    get: function get(key) {
      return instance._manager._get(key);
    },
    set: function set(key, value) {
      return instance._manager._set(key, value);
    },
    remove: function remove(key) {
      return instance._manager._remove(key);
    },
    addTimes: function addTimes(key, num) {
      var add = parseInt(num || 1);
      return instance._manager._add(key, add);
    },
    subTimes: function subTimes(key, num) {
      var sub = parseInt(num || 1);
      return instance._manager._sub(key, sub);
    }
  };
  instance._manager = manager || SessionStorageManager;
  return instance;
};

var SessionStorageManager = {
  _get: function _get(key) {
    return sessionStorage.getItem(key);
  },
  _set: function _set(key, value) {
    return sessionStorage.setItem(key, value);
  },
  _remove: function _remove(key) {
    return sessionStorage.removeItem(key);
  },
  _add: function _add(key, num) {
    var current = parseInt(SessionStorageManager._get(key) || 0);

    SessionStorageManager._set(key, current + num);
  },
  _sub: function _sub(key, num) {
    SessionStorageManager._add(key, num * -1);
  }
};
exports.SessionStorageManager = SessionStorageManager;
var LocalStorageManager = {
  _get: function _get(key) {
    return localStorage.getItem(key);
  },
  _set: function _set(key, value) {
    return localStorage.setItem(key, value);
  },
  _remove: function _remove(key) {
    return localStorage.removeItem(key);
  },
  _add: function _add(key, num) {
    var current = parseInt(LocalStorageManager._get(key) || 0);

    LocalStorageManager._set(key, current + num);
  },
  _sub: function _sub(key, num) {
    LocalStorageManager._add(key, num * -1);
  }
};
exports.LocalStorageManager = LocalStorageManager;
var _default = StorageManager;
exports["default"] = _default;

},{}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _vuex = _interopRequireDefault(require("vuex"));

var _axios = _interopRequireDefault(require("axios"));

var _misc = require("./misc.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

_vueMin["default"].use(_vuex["default"]);

var store = new _vuex["default"].Store({
  state: {
    pageTitle: '',
    isMobile: null,
    //is viewport < 835px
    isSmallMobile: null,
    //is viewport < 650px
    isMdDesktop: null,
    //is viewport < 1024px
    pageAnchors: [],
    showInlineAnchors: false,
    units: null,
    menuKeys: [],
    favorites: {
      //NOTE: all ids stored as strings
      documentId: [],
      softwareId: [],
      articleId: [],
      productId: [],
      legalDocumentId: []
    },
    currentLang: null,
    litOrderCart: [],
    GAID: null
  },
  mutations: {
    updateTitle: function updateTitle(state, title) {
      state.pageTitle = title;
    },
    setMobileState: function setMobileState(state, mobileState) {
      state.isMobile = mobileState;
    },
    setSmallMobileState: function setSmallMobileState(state, mobileState) {
      state.isSmallMobile = mobileState;
    },
    setMdDesktopState: function setMdDesktopState(state, mobileState) {
      state.isMdDesktop = mobileState;
    },
    setPageAnchors: function setPageAnchors(state, anchors) {
      state.pageAnchors = anchors;
    },
    setAnchorDropdownVis: function setAnchorDropdownVis(state, anchorState) {
      state.showInlineAnchors = anchorState;
    },
    setUnits: function setUnits(state, units) {
      if (units) {
        state.units = units;
      } else {
        state.units = state.units == 'us' ? 'metric' : state.units == 'metric' ? 'us' : null;
      }
    },
    updateMenu: function updateMenu(state, obj) {
      state.menuKeys.push(obj);
    },
    updateFavorites: function updateFavorites(state, data) {
      // add/remove items from stores favorites
      if (data.action == "add") {
        // console.log("add");
        state.favorites[data.type].push(data.id);
      } else if (data.action == "remove") {
        // console.log("remove");
        if (state.favorites[data.type].includes(data.id)) {
          state.favorites[data.type].splice(state.favorites[data.type].indexOf(data.id), 1);
        }
      } else {
        return;
      }
    },
    initFavorites: function initFavorites(state, data) {
      state.favorites[data.type] = data.arr;
    },
    sanitizeFavorites: function sanitizeFavorites(state, results) {
      // sanitisze favorites based on valid favs returned from api
      state.favorites.documentId = results.documentIds.map(function (i) {
        return "".concat(i);
      });
      state.favorites.softwareId = results.softwareIds.map(function (i) {
        return "".concat(i);
      });
      state.favorites.articleId = results.articleIds.map(function (i) {
        return "".concat(i);
      });
      state.favorites.productId = results.productIds.map(function (i) {
        return "".concat(i);
      });
      state.favorites.legalDocumentId = results.legalDocumentIds.map(function (i) {
        return "".concat(i);
      });
    },
    setCurrentLang: function setCurrentLang(state, lang) {
      state.currentLang = lang;
    },
    updateLitOrderCart: function updateLitOrderCart(state, data) {
      state.litOrderCart = data;
    },
    setGAID: function setGAID(state, id) {
      state.GAID = id;
    }
  },
  actions: {
    checkMobile: function checkMobile(context) {
      var mqlMd = window.matchMedia('(max-width: 835px)');
      var mqlSm = window.matchMedia('(max-width: 650px)');
      var mqlMdDesktop = window.matchMedia('(max-width: 1024px)'); // console.log(mqlMd.matches);

      var isMobile = mqlMd.matches ? true : false;
      context.commit('setMobileState', isMobile);
      mqlMd.addEventListener('change', function () {
        isMobile = mqlMd.matches ? true : false;
        context.commit('setMobileState', isMobile);
      });
      var isSmallMobile = mqlSm.matches ? true : false;
      context.commit('setSmallMobileState', isSmallMobile);
      mqlSm.addEventListener('change', function () {
        isSmallMobile = mqlSm.matches ? true : false;
        context.commit('setSmallMobileState', isSmallMobile);
      });
      var isMdDesktop = mqlMdDesktop.matches ? true : false;
      context.commit('setMdDesktopState', isMdDesktop);
      mqlMdDesktop.addEventListener('change', function () {
        isMdDesktop = mqlMdDesktop.matches ? true : false;
        context.commit('setMdDesktopState', isMdDesktop);
      });
    },
    initCookies: function initCookies(context) {
      // check for current cookies
      context.commit('initFavorites', {
        "type": 'documentId',
        arr: (0, _misc.getCookieValue)('documentIds').split(',')
      });
      context.commit('initFavorites', {
        "type": 'softwareId',
        arr: (0, _misc.getCookieValue)('softwareIds').split(',')
      });
      context.commit('initFavorites', {
        "type": 'articleId',
        arr: (0, _misc.getCookieValue)('articleIds').split(',')
      });
      context.commit('initFavorites', {
        "type": 'productId',
        arr: (0, _misc.getCookieValue)('productIds').split(',')
      });
      context.commit('initFavorites', {
        "type": 'legalDocumentId',
        arr: (0, _misc.getCookieValue)('legalDocumentIds').split(',')
      }); // console.log(context.state.favorites);

      context.dispatch('checkFavorites');
    },
    cookieFavorites: function cookieFavorites(context) {
      // cookie current saved items in store
      var docStr = context.state.favorites.documentId.toString();
      var softwareStr = context.state.favorites.softwareId.toString();
      var articleStr = context.state.favorites.articleId.toString();
      var productStr = context.state.favorites.productId.toString();
      var legalDocStr = context.state.favorites.legalDocumentId.toString();
      document.cookie = "documentIds=".concat(docStr, "; max-age=1209600; path=/");
      document.cookie = "softwareIds=".concat(softwareStr, "; max-age=1209600; path=/");
      document.cookie = "articleIds=".concat(articleStr, "; max-age=1209600; path=/");
      document.cookie = "productIds=".concat(productStr, "; max-age=1209600; path=/");
      document.cookie = "legalDocumentIds=".concat(legalDocStr, "; max-age=1209600; path=/");
    },
    checkFavorites: function checkFavorites(context) {
      // validate cookies with api
      var docStr = context.state.favorites.documentId.toString();
      var softwareStr = context.state.favorites.softwareId.toString();
      var articleStr = context.state.favorites.articleId.toString();
      var productStr = context.state.favorites.productId.toString();
      var legalDocStr = context.state.favorites.legalDocumentId.toString();
      var axiosParams = {
        documentId: docStr == "" ? null : docStr.charAt(0) == "," ? docStr.slice(1) : docStr,
        softwareId: softwareStr == "" ? null : softwareStr.charAt(0) == "," ? softwareStr.slice(1) : softwareStr,
        articleId: articleStr == "" ? null : articleStr.charAt(0) == "," ? articleStr.slice(1) : articleStr,
        productId: productStr == "" ? null : productStr.charAt(0) == "," ? productStr.slice(1) : productStr,
        legalDocumentId: legalDocStr == "" ? null : legalDocStr.charAt(0) == "," ? legalDocStr.slice(1) : legalDocStr
      }; // console.log(axiosParams);
      // const apiUrl = getApiUrl();

      var apiUrl = "/api/validateids?"; // console.log(apiUrl);
      // let TESTURL = "http://localhost:3003/validateIds";

      _axios["default"].get(apiUrl, {
        params: _objectSpread({}, axiosParams)
      }).then(function (response) {
        store.commit('sanitizeFavorites', response.data.results);
        store.dispatch('cookieFavorites');
      })["catch"](function (error) {
        console.log(error);
      });
    },
    initUnits: function initUnits(context) {
      var lang = document.querySelector('.top-bar__subnav-link.active') ? document.querySelector('.top-bar__subnav-link.active').dataset.lang : null; // console.log("LANG", lang)

      store.commit('setCurrentLang', lang);

      if (lang !== "en-us") {
        store.commit('setUnits', 'metric');
      } else {
        store.commit('setUnits', 'us');
      }
    },
    initGAID: function initGAID(context) {
      var id = (0, _misc.getCookieValue)('_ga') == '' ? null : (0, _misc.getCookieValue)('_ga');
      store.commit('setGAID', id); // console.log(id);
    }
  }
});
var _default = store;
exports["default"] = _default;

},{"./misc.js":28,"axios":66,"vue/dist/vue.min.js":234,"vuex":235}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _store = _interopRequireDefault(require("./store"));

var _eventBus = _interopRequireDefault(require("./event-bus"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Subnav = function Subnav() {
  var subnavDom = document.querySelectorAll('.sub-nav');

  var subnavConstructor = function subnavConstructor(id) {
    _vueMin["default"].component('subnav-template', {
      data: function data() {
        return {
          isMobile: _store["default"].state.isMobile,
          anchors: _store["default"].state.pageAnchors
        };
      },
      computed: {
        computedIsMobile: function computedIsMobile() {
          return _store["default"].state.isMobile;
        } // computedShowAnchors: function() {
        //     return store.state.showInlineAnchors;
        // }

      },
      watch: {
        computedIsMobile: function computedIsMobile() {
          this.isMobile = this.computedIsMobile;
        } // computedShowAnchors() {
        //     this.showAnchors = this.computedShowAnchors;
        // }

      },
      methods: {},
      mounted: function mounted() {}
    });

    _vueMin["default"].component('subnav-desktop', {
      props: ['isMobile'],
      data: function data() {
        return {};
      },
      methods: {},
      mounted: function mounted() {}
    });

    _vueMin["default"].component('subnavDropdown', {
      props: ['anchors'],
      data: function data() {
        return {};
      },
      template: "\n            <select name=\"pageSection\" class=\"persistent-cta__dropdown persistent-cta__dropdown--inline\" :anchor=anchors v-on:change=\"jump\">\n                <anchor-dropdown-item v-for=\"(item, index) in anchors\" :key=\"index\" :data=\"item\"/>\n            </select>\n            ",
      methods: {
        jump: function jump(e) {
          window.location.hash = "#".concat(e.target.value);
          console.log(e.target.value);
        }
      },
      mounted: function mounted() {}
    });

    _vueMin["default"].component('anchor-dropdown-item', {
      props: ['data'],
      data: function data() {
        return {};
      },
      template: "\n                <option :value=\"data.key\">{{data.name}}</option>\n            ",
      methods: {},
      mounted: function mounted() {}
    });

    new _vueMin["default"]({
      el: ".subnav-".concat(id)
    }).$mount(".subnav-".concat(id), true);
  };

  if (subnavDom.length > 0) {
    subnavDom.forEach(function (item, index) {
      item.classList.add("subnav-".concat(index));
      subnavConstructor(index);
    });
  }
};

var _default = Subnav;
exports["default"] = _default;

},{"./event-bus":9,"./store":51,"vue/dist/vue.min.js":234}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _tabsComponent = require("./template-strings/tabs-component");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var tabs = function tabs() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$name = _ref.name,
      name = _ref$name === void 0 ? 'tabs' : _ref$name,
      props = _ref.props,
      dataProp = _ref.data,
      _mounted = _ref.mounted,
      methods = _ref.methods,
      components = _ref.components,
      tabProps = _ref.tabProps,
      contentProps = _ref.contentProps,
      tabData = _ref.tabData,
      tabContentData = _ref.tabContentData,
      tabOptions = _ref.tabOptions,
      tabContentOptions = _ref.tabContentOptions,
      options = _objectWithoutProperties(_ref, ["name", "props", "data", "mounted", "methods", "components", "tabProps", "contentProps", "tabData", "tabContentData", "tabOptions", "tabContentOptions"]);

  return _objectSpread({
    name: name,
    props: _objectSpread({
      currentIdTab: [String, Number],
      activeClass: String
    }, props),
    data: function data() {
      var _dataProp = dataProp && dataProp();

      var data = _objectSpread({
        currentTab: this.currentIdTab || 1
      }, _dataProp);

      return data;
    },
    mounted: function mounted() {
      _mounted && _mounted.call(this);
      var tabChildren = {};
      this.$children.forEach(function (c) {
        var tag = c.$vnode.componentOptions.tag;

        if (!['tab', 'tab-content'].includes(tag)) {
          return;
        }

        var id = c.idTab;
        var e = tabChildren[id];

        if (!e) {
          tabChildren[id] = c;
          return;
        }

        c.setTabInstance(e);
      });
    },
    methods: _objectSpread({
      changeTab: function changeTab(id) {
        this.currentTab = id;
      }
    }, methods),
    components: _objectSpread({
      'tab': _objectSpread(_objectSpread({
        name: 'tab',
        template: _tabsComponent.tab,
        props: _objectSpread({
          idTab: [String, Number],
          activeClass: {
            type: String,
            "default": 'active'
          },
          currentTab: [String, Number],
          changeTab: Function
        }, tabProps),
        data: function data() {
          return _objectSpread({}, tabData);
        }
      }, tabOptions), {}, {
        methods: {
          onClick: function onClick() {
            this.changeTab(this.idTab);
          },
          setTabInstance: function setTabInstance(e) {
            return e.setTabDefaultSlot(this.getDefaultSlot());
          },
          getDefaultSlot: function getDefaultSlot() {
            return this.$slots["default"];
          }
        }
      }),
      'tab-content': _objectSpread(_objectSpread({
        name: 'tab-content',
        template: _tabsComponent.content,
        props: _objectSpread({
          idTab: [String, Number],
          currentTab: [String, Number],
          tabClass: {
            type: String,
            "default": 'tab'
          },
          activeClass: {
            type: String,
            "default": 'active'
          },
          changeTab: Function
        }, contentProps),
        data: function data() {
          var data = _objectSpread({
            tabSlot: undefined
          }, tabContentData);

          return data;
        }
      }, tabContentOptions), {}, {
        beforeUpdate: function beforeUpdate() {
          this.$slots.tab = this.tabSlot;
        },
        methods: {
          onClick: function onClick() {
            this.changeTab(this.idTab);
          },
          setTabInstance: function setTabInstance(e) {
            this.setTabDefaultSlot(e.getDefaultSlot());
          },
          setTabDefaultSlot: function setTabDefaultSlot(slot) {
            this.tabSlot = slot;
          }
        }
      })
    }, components)
  }, options);
};

var _default = tabs;
exports["default"] = _default;

},{"./template-strings/tabs-component":57}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.articleItem = exports.softwareItem = exports.documentItem = exports.productItem = exports.tabSelectMobile = void 0;
var tabSelectMobile = "\n    <div>\n        <select :value=\"currentTab\" :class=\"selectClass\" v-on:change=\"change\">\n            <option v-for=\"o in options\" :value=\"o.id\">{{o.text}}</option>\n        </select>\n        <slot></slot>\n    </div>\n";
exports.tabSelectMobile = tabSelectMobile;
var productItem = "\n    <div class=\"product-card-hor\" :checked=\"checked\" :data=\"data\">\n        <div class=\"product-card-hor__wrapper\">\n            <div class=\"product-card-hor__row\">\n                <div class=\"product-card-hor__area product-card-hor__area-utils\">\n                    <div class=\"product-card-hor__util product-card-hor__util-checkbox\">\n                        <div class=\"checkbox\">\n                            <label class=\"checkbox__label\">\n                                <input type=\"checkbox\" class=\"checkbox__input\" v-model=\"isChecked\" :data-product-id=\"data.id\" ref=\"checkbox\">\n                                <span class=\"checkbox__checkmark\"></span>\n                            </label>\n                        </div>\n                    </div>\n                    <div class=\"product-card-hor__util product-card-hor__util-bookmark\">\n                        <div class=\"product-bookmark-container\">\n                            <product-bookmark inline-template :data=\"data\">\n                                <span class=\"product-card-hor__bookmark\" :data-product-id=\"data.id\" ref=\"bookmark\" v-on:click=\"handleBookmark()\" v-bind:class=\"isBookmarked ? 'active' : ''\"></span>\n                            </product-bookmark>\n                        </div>\n                    </div>\n                </div>\n                <div class=\"product-card-hor__area product-card-hor__area-image\">\n                    <div class=\"product-card-hor__image-container\">\n                        <img :src=\"data.productImageUrl\" :alt=\"data.productImageUrlAltText\" class=\"product-card-hor__image\">\n                    </div>\n                </div>\n                <div class=\"product-card-hor__area product-card-hor__area-content\">\n                    <div>\n                        <span class=\"product-card-hor__eyebrow\">\n                            <img :src=\"data.brandImageUrl\" :alt=\"data.brandImageUrlAltText\" class=\"product-card-hor__eyebrow-image\">\n                        </span>\n                        <p class=\"product-card-hor__title\">\n                            {{data.productName}}\n                        </p>\n                        <div class=\"product-card-hor__copy\">\n                            {{data.description}}\n                        </div>\n                        <div class=\"product-card-hor__cta\">\n                        <a :href=\"data.url\" class=\"button tertiary-button\"><span class=\"button-text\">View product</span><span class=\"button-icon\"></span></a>\n                        \n                        </div>\n                    </div>\n\n                </div>\n            </div>\n        </div>\n    </div>\n";
exports.productItem = productItem;
var documentItem = "\n<div class=\"doc-card\">\n    <div class=\"doc-card__wrapper\">\n        <div class=\"doc-card__row\">\n            <div class=\"doc-card__area doc-card__area-left\">\n                <span class=\"doc-card__eyebrow\">\n                    {{data.eyebrow}}\n                </span>\n                <a href=\"#\" class=\"doc-card__title\">\n                    {{data.name}}\n                </a>\n                <span class=\"doc-card__subtitle\">\n                    {{data.details}}\n                </span>\n            </div>\n            <div class=\"doc-card__area doc-card__area-right\">\n                <a class=\"doc-card__icon doc-card__icon-download\" :href=\"data.url\"></a>\n                <a class=\"doc-card__icon doc-card__icon-email\" :href=\"mailto\"></a>\n                <document-bookmark inline-template :data=\"data\">\n                <a class=\"doc-card__icon doc-card__icon-bookmark\" v-on:click.prevent=\"handleBookmark()\" :data-document-id=\"data.id\" ref=\"bookmark\"></a>\n                </document-bookmark>\n            </div>\n        </div>\n    </div>\n</div>\n";
exports.documentItem = documentItem;
var softwareItem = "\n    <div class=\"software-card\">\n        <div class=\"software-card__wrapper\">\n            <div class=\"software-card__row\">\n                <div class=\"software-card__area software-card__area-left\">\n                    <span class=\"software-card__eyebrow\">\n                       {{data.eyebrow}}\n                    </span>\n                    <a href=\"#\" class=\"software-card__title\">\n                        {{data.name}}\n                    </a>\n                    <span class=\"software-card__subtitle\" v-html=\"data.details\">\n                        \n                    </span>\n                </div>\n                <div class=\"software-card__area software-card__area-right\">\n                    <a class=\"software-card__icon software-card__icon-download\" :href=\"data.downloadUrl\"></a>\n                    <software-bookmark inline-template :data=\"data\">\n                        <a class=\"software-card__icon software-card__icon-bookmark\" href=\"#\" v-on:click.prevent=\"handleBookmark()\" :data-software-id=\"data.id\" ref=\"bookmark\"></a>\n                    </software-bookmark>\n                    <a class=\"software-card__icon software-card__icon-arrow\" :class=\"{inactive: !data.viewDetailsUrl}\" :href=\"data.viewDetailsUrl\"></a>\n                </div>\n            </div>\n        </div>\n    </div>\n";
exports.softwareItem = softwareItem;
var articleItem = "\n<div class=\"article-card-h\">\n    <div class=\"article-card-h__wrapper\">\n        <div class=\"article-card-h__row\">\n            <div class=\"article-card-h__area article-card-h__area-utils\">\n                <div class=\"article-card-h__util article-card-h__util-bookmark\">\n                    <div class=\"bookmark-container\">\n                        <article-bookmark inline-template :data=\"data\">\n                            <span class=\"article-card-h__bookmark\" :data-product-id=\"data.id\" ref=\"bookmark\" v-on:click=\"handleBookmark()\" v-bind:class=\"isBookmarked ? 'active' : ''\"></span>\n                        </article-bookmark>\n                    </div>\n                </div>\n            </div>\n            <div class=\"article-card-h__area article-card-h__area-image\" v-bind:style=\"{ backgroundImage: 'url(' + data.articleImageUrl + ')' }\">\n            </div>\n            <div class=\"article-card-h__area article-card-h__area-content\">\n                <div>\n                    <p class=\"article-card-h__title\">\n                        {{data.articleTitle}}\n                    </p>\n                    <div class=\"article-card-h__copy\">\n                        <p>{{data.articleDetails}}</p>\n                    </div>\n                </div>\n\n            </div>\n        </div>\n    </div>\n</div>\n\n";
exports.articleItem = articleItem;

},{}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.paginator = exports.content = void 0;
var content = "\n<div>\n    <slot v-if=\"data.keepContent\"></slot>\n    <div v-for=\"item in data.results\" class=\"recent-posts__cell\">\n        <div class=\"article-tile__wrapper\">\n            <a class=\"article-tile__link\" href=\"#\" :href=\"item.url\">\n                <div class=\"article-tile__image-container\">\n                    <img src=\"https://placehold.it/305x180\" class=\"article-tile__image\" :src=\"item.image\" :alt=\"item.imageAltText\" />\n                </div>\n                <p class=\"article-tile__title\" v-html=\"item.title\"></p>\n                <p class=\"article-tile__info\">{{item.type}} / {{item.info}}</p>\n            </a>\n        </div>\n    </div>\n</div>\n";
exports.content = content;
var paginator = "\n<div v-if=\"(data.firstLoad && isShow) || data.nextPage\">\n    <slot></slot>\n</div>\n";
exports.paginator = paginator;

},{}],56:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.contentApplications = void 0;
var contentApplications = "\n    <div v-if=\"currentTab == idTab\" :class=\"activeClass\" data-tag-trigger=\"click\" :data-tag-meta=\"taggingMeta\">\n        <slot></slot>\n    </div>\n";
exports.contentApplications = contentApplications;

},{}],57:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tab = exports.content = void 0;
var content = "\n    <div :class=\"currentTab == idTab && activeClass\" :data-tag-meta=\"taggingMeta\">\n        <div v-if=\"changeTab && tabSlot\" v-on:click=\"onClick\" :class=\"tabClass\">\n            <slot name=\"tab\"></slot>\n        </div>\n        <slot v-if=\"currentTab == idTab\"></slot>\n    </div>\n";
exports.content = content;
var tab = "\n    <li v-on:click=\"onClick\" :class=\"currentTab == idTab && activeClass\" :data-tag-meta=\"taggingMeta\">\n        <slot></slot>\n    </li>\n";
exports.tab = tab;

},{}],58:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _lory = require("lory.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var testimonial = function testimonial() {
  var testimonialItem = document.querySelectorAll('.testimonial');

  var testimonialConstructor = function testimonialConstructor(id) {
    _vueMin["default"].component('testimonial', {
      data: function data() {
        return {
          sliderEl: null,
          options: {
            classNameFrame: 'testimonial__frame',
            enableMouseEvents: true
          },
          lory: null,
          currentSlide: 1,
          length: null
        };
      },
      computed: {},
      watch: {},
      methods: {
        initLory: function initLory() {
          this.lory = (0, _lory.lory)(this.sliderEl, this.options);
        },
        initListener: function initListener() {
          var _this = this;

          this.sliderEl.addEventListener('after.lory.slide', function () {
            _this.currentSlide = _this.lory.returnIndex() + 1;
          });
        },
        nextSlide: function nextSlide() {
          this.lory.next();
        },
        prevSlide: function prevSlide() {
          this.lory.prev();
        }
      },
      mounted: function mounted() {
        this.sliderEl = this.$el.querySelector('.testimonial__slider');
        this.length = this.$el.querySelectorAll('.testimonial__slide').length;
        this.initLory();
        this.initListener();
      }
    });

    new _vueMin["default"]({
      el: ".testimonial-".concat(id)
    }).$mount(".testimonial-".concat(id), true);
  };

  if (testimonialItem.length > 0) {
    testimonialItem.forEach(function (item, index) {
      item.classList.add("testimonial-".concat(index));
      testimonialConstructor(index);
    });
  }
};

var _default = testimonial;
exports["default"] = _default;

},{"lory.js":223,"vue/dist/vue.min.js":234}],59:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _tippy = _interopRequireDefault(require("tippy.js"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _modals = require("./modals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

_vueMin["default"].use(_vueJsModal["default"]);

var Timeline = function Timeline() {
  var timelineItems = document.querySelectorAll('.timeline');

  var timelineConstructor = function timelineConstructor(id) {
    _vueMin["default"].component('timeline', {
      data: function data() {
        return {
          isMobile: null,
          instance: null
        };
      },
      methods: {
        initIsMobile: function initIsMobile() {
          var _this = this;

          // console.log("calc this", window.innerWidth);
          // note this is checking for a smaller screen size than the isMobile value in the vuex store
          var mql = window.matchMedia('(max-width: 650px)');
          this.isMobile = mql.matches ? true : false;
          mql.addEventListener('change', function () {
            _this.isMobile = mql.matches ? true : false;
          });
        }
      },
      mounted: function mounted() {
        this.initIsMobile();
      }
    });

    _vueMin["default"].component('timeline-item', {
      props: ['isMobile'],
      data: function data() {
        return {
          message: {},
          isOpen: null
        };
      },
      watch: {
        isMobile: function isMobile() {
          if (this.isMobile) {
            this.disableTooltips;
          }
        }
      },
      methods: {
        initTippy: function initTippy() {
          var self = this;
          (0, _tippy["default"])(this.$refs.tooltip, {
            allowHTML: true,
            arrow: true,
            hideOnClick: true,
            trigger: 'click',
            interactive: true,
            zIndex: 99,
            onShow: function onShow(instance) {
              // console.log("OPENED");
              self.isOpen = true;
            },
            onHide: function onHide(instance) {
              self.isOpen = false;
            }
          });
        },
        mobileTooltip: function mobileTooltip() {
          if (this.isMobile) {
            var content = "\n                            <div class=\"timeline__item-date\">".concat(this.message.date, "</div>\n                            <div class=\"timeline__item-desc\">").concat(this.message.title, "</div>\n                            <div>").concat(this.message.copy, "</div>\n                        ");
            this.$modal.show(_modals.tooltipModal.template(content), _modals.tooltipModal.name, _modals.tooltipModal.options);
          }
        },
        disableTooltips: function disableTooltips() {
          var target = this.$refs.tooltip;
          var instance = target._tippy;
          instance.disable(); //@TODO: figure out why disable method isn't working
        },
        initMessageData: function initMessageData() {
          this.message.copy = this.$refs.tooltip.getAttribute('data-tippy-content');
          this.message.title = this.$refs.desc.innerText;
          this.message.date = this.$refs.date.innerText;
        }
      },
      mounted: function mounted() {
        var _this2 = this;

        this.$nextTick(function () {
          _this2.initTippy();

          if (_this2.isMobile) {
            _this2.disableTooltips();
          }
        });
        this.initMessageData();
      }
    });

    new _vueMin["default"]({
      el: ".timeline-".concat(id)
    }).$mount(".timeline-".concat(id), true);
  };

  if (timelineItems.length > 0) {
    timelineItems.forEach(function (item, index) {
      item.classList.add("timeline-".concat(index));
      timelineConstructor(index);
    });
  }
};

var _default = Timeline;
exports["default"] = _default;

},{"./modals":30,"tippy.js":232,"vue-js-modal":233,"vue/dist/vue.min.js":234}],60:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _vueMin = _interopRequireDefault(require("vue/dist/vue.min.js"));

var _vueJsModal = _interopRequireDefault(require("vue-js-modal"));

var _modals = require("./modals");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var VideoPlayer = function VideoPlayer() {
  var videos = document.querySelectorAll('.video-player');

  _vueMin["default"].use(_vueJsModal["default"]);

  var VideoConstructor = function VideoConstructor(id) {
    _vueMin["default"].component('video-player-template', {
      data: function data() {
        return {
          videoUrl: '',
          videoName: null
        };
      },
      methods: {
        launchVideo: function launchVideo() {
          this.$modal.show(_modals.videoModal.template(this.videoUrl, this.videoName), _modals.videoModal.name, _modals.videoModal.options);
        }
      },
      mounted: function mounted() {
        this.videoUrl = this.$refs.overlay.dataset.videoId;
        this.videoName = this.$refs.name ? this.$refs.name.innerHTML : null;
      }
    });

    new _vueMin["default"]({
      el: ".video-player-".concat(id)
    }).$mount(".video-player-".concat(id), true);
  };

  if (videos.length > 0) {
    videos.forEach(function (item, index) {
      item.classList.add("video-player-".concat(index));
      VideoConstructor(index);
    });
  }
};

var _default = VideoPlayer;
exports["default"] = _default;

},{"./modals":30,"vue-js-modal":233,"vue/dist/vue.min.js":234}],61:[function(require,module,exports){
"use strict";

require("./polyfills/element.closest");

require("./polyfills/matchMedia");

require("nodelist-foreach-polyfill");

require("core-js/features/promise");

require("core-js/es/symbol/iterator");

require("core-js/es/object/assign");

require("core-js/es/array/find");

require("core-js/es/array/from");

require("core-js/es/array/includes");

require("core-js/es/string/includes");

require("intersection-observer");

var _drawer = _interopRequireDefault(require("./lib/drawer.js"));

var _productsAccessories = _interopRequireDefault(require("./lib/products-accessories.js"));

var _ctaBarTop = _interopRequireDefault(require("./lib/cta-bar-top.js"));

var _ctaBarBottom = _interopRequireDefault(require("./lib/cta-bar-bottom.js"));

var _subNav = _interopRequireDefault(require("./lib/sub-nav.js"));

var _menuTopBar = _interopRequireDefault(require("./lib/menu-top-bar.js"));

var _fwMedia = _interopRequireDefault(require("./lib/fw-media.js"));

var _howItWorks = _interopRequireDefault(require("./lib/how-it-works.js"));

var _videoPlayer = _interopRequireDefault(require("./lib/video-player.js"));

var _specifications = _interopRequireDefault(require("./lib/specifications.js"));

var _heroProducts = _interopRequireDefault(require("./lib/hero-products.js"));

var _marketApplications = _interopRequireDefault(require("./lib/market-applications.js"));

var _megamenu = _interopRequireDefault(require("./lib/megamenu.js"));

var _footerUnits = _interopRequireDefault(require("./lib/footer-units.js"));

var _documentation = _interopRequireDefault(require("./lib/documentation.js"));

var _softwareFirmware = _interopRequireDefault(require("./lib/software-firmware.js"));

var _productCatalog = _interopRequireDefault(require("./lib/product-catalog.js"));

var _internalSearch = _interopRequireDefault(require("./lib/internal-search.js"));

var _pardotForm = require("./lib/pardot-form.js");

var _bookmarks = _interopRequireDefault(require("./lib/bookmarks.js"));

var _modalTrigger = require("./lib/modal-trigger.js");

var _documentationContextual = _interopRequireDefault(require("./lib/documentation-contextual.js"));

var _softwareCard = _interopRequireDefault(require("./lib/software-card.js"));

var _quickLinks = _interopRequireDefault(require("./lib/quick-links.js"));

var _homeHero = _interopRequireDefault(require("./lib/home-hero.js"));

var _searchResults = _interopRequireDefault(require("./lib/search-results"));

var _testimonial = _interopRequireDefault(require("./lib/testimonial"));

var _patents = _interopRequireDefault(require("./lib/patents"));

var _legalCompliance = _interopRequireDefault(require("./lib/legal-compliance"));

var _timeline = _interopRequireDefault(require("./lib/timeline"));

var _litOrder = _interopRequireDefault(require("./lib/lit-order"));

var _genericModal = _interopRequireDefault(require("./lib/generic-modal"));

var _store = _interopRequireDefault(require("./lib/store"));

var _componentModule = _interopRequireDefault(require("./lib/component-module"));

require("./lib/modules");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// Polyfills for IE
// import sample from './lib/sample.js';
//for software/firmware no filtering version
// importing libraries for modules
document.addEventListener('DOMContentLoaded', function () {
  (0, _genericModal["default"])();
  (0, _drawer["default"])();
  (0, _productsAccessories["default"])();
  (0, _ctaBarTop["default"])();
  (0, _ctaBarBottom["default"])();
  (0, _subNav["default"])();
  (0, _menuTopBar["default"])();
  (0, _fwMedia["default"])();
  (0, _howItWorks["default"])();
  (0, _videoPlayer["default"])();
  (0, _specifications["default"])();
  (0, _heroProducts["default"])();
  (0, _marketApplications["default"])();
  (0, _megamenu["default"])();
  (0, _footerUnits["default"])();
  (0, _documentation["default"])();
  (0, _softwareFirmware["default"])();
  (0, _productCatalog["default"])();
  (0, _internalSearch["default"])();
  (0, _pardotForm.pardotForm)();
  (0, _bookmarks["default"])(); // Initialization modules

  _componentModule["default"].Init();

  _modalTrigger.instance;
  (0, _modalTrigger.trigger)();
  (0, _documentationContextual["default"])();
  (0, _softwareCard["default"])();
  (0, _quickLinks["default"])();
  (0, _homeHero["default"])();
  (0, _searchResults["default"])();
  (0, _testimonial["default"])();
  (0, _patents["default"])();
  (0, _legalCompliance["default"])();
  (0, _timeline["default"])();
  (0, _litOrder["default"])(); // always scroll lock body when modal or mobile megamenu is open

  var observerTarget = document.querySelector('body');

  var scrollLock = function scrollLock() {
    if (document.querySelector('.bmi-modal') || document.querySelector('.megamenu__mobile-submenu.active')) {
      observerTarget.classList.add('scroll-lock');
    } else {
      observerTarget.classList.remove('scroll-lock');
    }
  };

  var options = {
    subtree: true,
    childList: true
  };
  var observer = new MutationObserver(scrollLock);
  observer.observe(observerTarget, options); // init units to us or metric

  _store["default"].dispatch('initUnits'); // init getting GA client ID


  _store["default"].dispatch('initGAID');
});

_store["default"].dispatch('initCookies'); //init cookies for bookmark feature


_store["default"].dispatch('checkMobile');

},{"./lib/bookmarks.js":1,"./lib/component-module":2,"./lib/cta-bar-bottom.js":4,"./lib/cta-bar-top.js":5,"./lib/documentation-contextual.js":6,"./lib/documentation.js":7,"./lib/drawer.js":8,"./lib/footer-units.js":12,"./lib/fw-media.js":13,"./lib/generic-modal":14,"./lib/hero-products.js":15,"./lib/home-hero.js":16,"./lib/how-it-works.js":17,"./lib/internal-search.js":18,"./lib/legal-compliance":19,"./lib/lit-order":20,"./lib/market-applications.js":21,"./lib/megamenu.js":22,"./lib/menu-top-bar.js":23,"./lib/modal-trigger.js":29,"./lib/modules":34,"./lib/pardot-form.js":40,"./lib/patents":41,"./lib/product-catalog.js":42,"./lib/products-accessories.js":43,"./lib/quick-links.js":44,"./lib/search-results":45,"./lib/software-card.js":46,"./lib/software-firmware.js":47,"./lib/specifications.js":49,"./lib/store":51,"./lib/sub-nav.js":52,"./lib/testimonial":58,"./lib/timeline":59,"./lib/video-player.js":60,"./polyfills/element.closest":62,"./polyfills/matchMedia":63,"core-js/es/array/find":92,"core-js/es/array/from":93,"core-js/es/array/includes":94,"core-js/es/object/assign":95,"core-js/es/string/includes":97,"core-js/es/symbol/iterator":98,"core-js/features/promise":99,"intersection-observer":222,"nodelist-foreach-polyfill":224}],62:[function(require,module,exports){
"use strict";

if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
}

if (!Element.prototype.closest) {
  Element.prototype.closest = function closest(s) {
    var el = this;
    var ancestor = this;
    if (!document.documentElement.contains(el)) return null;

    do {
      if (ancestor.matches(s)) return ancestor;
      ancestor = ancestor.parentElement;
    } while (ancestor !== null);

    return null;
  };
}

},{}],63:[function(require,module,exports){
"use strict";

// Modernizr style test
if (!(window.webkitMatchMedia || window.mozMatchMedia || window.oMatchMedia || window.msMatchMedia || window.matchMedia)) {
  var root = document.getElementsByTagName('html')[0];
  root.className += ' no-matchmedia';
}
/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */


window.matchMedia || (window.matchMedia = function () {
  "use strict"; // For browsers that support matchMedium api such as IE 9 and webkit

  var styleMedia = window.styleMedia || window.media; // For those that don't support matchMedium

  if (!styleMedia) {
    var style = document.createElement('style'),
        script = document.getElementsByTagName('script')[0],
        info = null;
    style.type = 'text/css';
    style.id = 'matchmediajs-test';
    script.parentNode.insertBefore(style, script); // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers

    info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;
    styleMedia = {
      matchMedium: function matchMedium(media) {
        var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }'; // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers

        if (style.styleSheet) {
          style.styleSheet.cssText = text;
        } else {
          style.textContent = text;
        } // Test if media query is true or false


        return info.width === '1px';
      }
    };
  }

  return function (media) {
    return {
      matches: styleMedia.matchMedium(media || 'all'),
      media: media || 'all'
    };
  };
}());
/*! matchMedia() polyfill addEventListener/removeEventListener extension. Author & copyright (c) 2012: Scott Jehl. Dual MIT/BSD license */

(function () {
  // Bail out for browsers that have addEventListener support
  if (window.matchMedia && window.matchMedia('all').addEventListener) {
    return false;
  }

  var localMatchMedia = window.matchMedia,
      hasMediaQueries = localMatchMedia('only all').matches,
      isListening = false,
      timeoutID = 0,
      // setTimeout for debouncing 'handleChange'
  queries = [],
      // Contains each 'mql' and associated 'listeners' if 'addEventListener' is used
  handleChange = function handleChange(evt) {
    // Debounce
    clearTimeout(timeoutID);
    timeoutID = setTimeout(function () {
      for (var i = 0, il = queries.length; i < il; i++) {
        var mql = queries[i].mql,
            listeners = queries[i].listeners || [],
            matches = localMatchMedia(mql.media).matches; // Update mql.matches value and call listeners
        // Fire listeners only if transitioning to or from matched state

        if (matches !== mql.matches) {
          mql.matches = matches;

          for (var j = 0, jl = listeners.length; j < jl; j++) {
            listeners[j].call(window, mql);
          }
        }
      }
    }, 30);
  };

  window.matchMedia = function (media) {
    var mql = localMatchMedia(media),
        listeners = [],
        index = 0;

    mql.addEventListener = function (listener) {
      // Changes would not occur to css media type so return now (Affects IE <= 8)
      if (!hasMediaQueries) {
        return;
      } // Set up 'resize' listener for browsers that support CSS3 media queries (Not for IE <= 8)
      // There should only ever be 1 resize listener running for performance


      if (!isListening) {
        isListening = true;
        window.addEventListener('resize', handleChange, true);
      } // Push object only if it has not been pushed already


      if (index === 0) {
        index = queries.push({
          mql: mql,
          listeners: listeners
        });
      }

      listeners.push(listener);
    };

    mql.removeEventListener = function (listener) {
      for (var i = 0, il = listeners.length; i < il; i++) {
        if (listeners[i] === listener) {
          listeners.splice(i, 1);
        }
      }
    };

    return mql;
  };
})();

},{}],64:[function(require,module,exports){
module.exports={
	"meterSelector": {
		"apiQuery": [
			"flowType"
		  ],
		  "question": "What are you measuring?",
		  "totalSteps": 9,
		  "filterName": "Flow type",
		  "stepId": "01.0",
		  "button": [
			{
			  "label": "Water",
			  "value": "Water",
			  "icon": "water",
			  "totalPages": 10
			},
			{
			  "label": "Oil",
			  "value": "Oil",
			  "icon": "oil"
			},
			{
			  "label": "Steam",
			  "value": "Steam",
			  "icon": "steam",
			  "totalPages": 10
			},
			{
			  "label": "Air / Gas",
			  "value": "Air / Gas",
			  "icon": "air-gas"
			},
			{
			  "label": "Other liquid",
			  "value": "Other liquid",
			  "icon": "other",
			  "selectedLabel": "Based on your selection, we recommend you <a title=\"Connect with a product expert\" href=\"/meter-selector/#meterselector\">connect with a product expert</a>for assistance finding the appropriate meter options for your application.",
			  "totalPages": 10
			}
		  ],
		"searchResults": {
			"Results": [
				{
					"productImageUrl": "https://badgermeter.widen.net/content/9ffrt62foa/jpeg/Air%20and%20Compressed%20Gas%20Meters%20%28low-res%29.png?w=600&h=600&position=c&color=ffffffff&quality=80&u=rb73pf",
					"brandImageUrl": "https://badgermeter.widen.net/content/yhf0kktfsd/png/Hedland-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
					"productName": "Air and Compressed Gas Meter",
					"url": "/products/meters/variable-area-flow-meters/air-and-compressed-gas-meter/",
					"id": "94",
					"stats": [
						{
							"label": "<p>Size</p>",
							"valueImperial": "1/4...3 in.",
							"valueMetric": "6...80 mm"
						},
						{
							"label": "<p>Temperature Range</p>",
							"valueImperial": "-20...240 F",
							"valueMetric": "-29...116 C"
						},
						{
							"label": "<p>Flow Range</p>",
							"valueImperial": "0.5...2200 scfm",
							"valueMetric": "0.2...1130 l/sec"
						},
						{
							"label": "<p>Pressure Range</p>",
							"valueImperial": "Up to 1500 PSI",
							"valueMetric": "Up to 103 bar"
						}
					],
					"markets": [
						"Automotive Fluid Dispensing",
						"Aviation & Aerospace",
						"Municipal Water Treatment & Distribution",
						"Oil & Gas",
						"Process & General Industry",
						"Refining, Chemical & Petrochemical",
						"Test Equipment & Services"
					],
					"productCategory": "Meters",
					"productType": "Variable Area Flow Meters",
					"brand": "Hedland",
					"flowTypes": [
						"Air / Gas"
					],
					"guid": "ca331136-ff6e-43c1-b513-d209a455e138"
				},
				{
					"productImageUrl": "https://badgermeter.widen.net/content/ly4uvs42he/jpeg/Air-Caustic%20and%20Corrosive%20Gas%20Meters%20%28low-res%29.png?w=600&h=600&position=c&color=ffffffff&quality=80&u=rb73pf",
					"brandImageUrl": "https://badgermeter.widen.net/content/yhf0kktfsd/png/Hedland-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
					"productName": "Caustic and Corrosive Air/Gas Meter",
					"url": "/products/meters/variable-area-flow-meters/caustic-and-corrosive-airgas-meter/",
					"id": "96",
					"stats": [
						{
							"label": "Size Range",
							"valueImperial": "1/41 1/2 in.",
							"valueMetric": "6...40 mm"
						},
						{
							"label": "Temperature Range",
							"valueImperial": " -20...240 F",
							"valueMetric": "-29116 C"
						},
						{
							"label": "Flow Range",
							"valueImperial": "2...800 scfm",
							"valueMetric": "1350 lpm"
						},
						{
							"label": "Accuracy",
							"valueImperial": "2% (1/4 in. is +7%)",
							"valueMetric": "2% (1/4 in. is +7%)"
						}
					],
					"markets": [
						"Automotive Fluid Dispensing",
						"Aviation & Aerospace",
						"Municipal Water Treatment & Distribution",
						"Oil & Gas",
						"Process & General Industry",
						"Refining, Chemical & Petrochemical",
						"Test Equipment & Services"
					],
					"productCategory": "Meters",
					"productType": "Variable Area Flow Meters",
					"brand": "Hedland",
					"flowTypes": [
						"Air / Gas"
					],
					"guid": "34907486-2783-4301-bbe8-d254e02e197b"
				},
				{
					"productImageUrl": "https://badgermeter.widen.net/content/5lrawuyqnd/jpeg/COIN-FF%20%28low%20res%29.png?w=400&h=400&position=c&color=ffffffff&quality=80&u=rf1shk",
					"brandImageUrl": "https://badgermeter.widen.net/content/zzheljuso0/png/Preso-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
					"productName": "COIN FF",
					"url": "/products/meters/differential-pressure-flow-meters/coin-wedge-flange-process-by-flange-instrumentation-model-ff-flow-meter/",
					"id": "139",
					"stats": [
						{
							"label": "Size",
							"valueImperial": "1/2...48 in.",
							"valueMetric": "12...1219 mm"
						},
						{
							"label": "Temperature Range",
							"valueImperial": "Up to 1500 F",
							"valueMetric": "Up to 815 C"
						},
						{
							"label": "Pressure Range",
							"valueImperial": "Dependent on flange rating",
							"valueMetric": "Dependent on flange rating"
						},
						{
							"label": "Accuracy",
							"valueImperial": "(uncalibrated) 3% (calibrated) 0.5%",
							"valueMetric": "(uncalibrated) 3% (calibrated) 0.5%"
						}
					],
					"markets": [
						"Oil & Gas",
						"Process & General Industry",
						"Refining, Chemical & Petrochemical"
					],
					"productCategory": "Meters",
					"productType": "Differential Pressure Flow Meters",
					"brand": "Preso",
					"flowTypes": [
						"Oil",
						"Steam",
						"Air / Gas",
						"Water",
						"Other liquid"
					],
					"guid": "57869087-8c87-46e4-b962-c0a43247632d"
				},
				{
					"productImageUrl": "https://badgermeter.widen.net/content/s8iymbnqc3/jpeg/COIN-NB-%28with-weld%29%20%28low%20res%29.png?w=400&h=400&position=c&color=ffffffff&quality=80&u=rf1shk",
					"brandImageUrl": "https://badgermeter.widen.net/content/zzheljuso0/png/Preso-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
					"productName": "COIN NB",
					"url": "/products/meters/differential-pressure-flow-meters/coin-butt-weld-wedge-model-nb-flow-meter/",
					"id": "137",
					"stats": [
						{
							"label": "Size",
							"valueImperial": "1/2...4 in.",
							"valueMetric": "12...101 mm"
						},
						{
							"label": "Temperature Range",
							"valueImperial": "Up to 800 F",
							"valueMetric": "Up to 426 C"
						},
						{
							"label": "Pressure Range",
							"valueImperial": "Dependent on flange rating",
							"valueMetric": "Dependent on flange rating"
						},
						{
							"label": "Accuracy",
							"valueImperial": "(uncalibrated) 3% (calibrated) 0.5%",
							"valueMetric": "(uncalibrated) 3% (calibrated) 0.5%"
						}
					],
					"markets": [
						"Oil & Gas",
						"Process & General Industry",
						"Refining, Chemical & Petrochemical"
					],
					"productCategory": "Meters",
					"productType": "Differential Pressure Flow Meters",
					"brand": "Preso",
					"flowTypes": [
						"Oil",
						"Steam",
						"Air / Gas",
						"Water",
						"Other liquid"
					],
					"guid": "31fdfe6b-d040-401a-ad0b-4e64e0016016"
				},
				{
					"productImageUrl": "https://badgermeter.widen.net/content/m8verp5tni/jpeg/COIN-NF%20%28low%20res%29.png?w=400&h=400&position=c&color=ffffffff&quality=80&u=rf1shk",
					"brandImageUrl": "https://badgermeter.widen.net/content/zzheljuso0/png/Preso-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
					"productName": "COIN NF",
					"url": "/products/meters/differential-pressure-flow-meters/coin-flanged-with-npt-pressure-taps-model-nf-flow-meter/",
					"id": "138",
					"stats": [
						{
							"label": "Size",
							"valueImperial": "1/2...48 in.",
							"valueMetric": "12...1,219 mm"
						},
						{
							"label": "Accuracy",
							"valueImperial": "(uncalibrated) 3% (calibrated) 0.5%",
							"valueMetric": "(uncalibrated) 3% (calibrated) 0.5%"
						}
					],
					"markets": [
						"Process & General Industry"
					],
					"productCategory": "Meters",
					"productType": "Differential Pressure Flow Meters",
					"brand": "Preso",
					"flowTypes": [
						"Oil",
						"Air / Gas",
						"Water",
						"Other liquid"
					],
					"guid": "dcb7bd65-a1fa-4309-bb4d-697274a1623a"
				},
				{
					"productImageUrl": "https://badgermeter.widen.net/content/3niwaz7vpr/jpeg/NN%20Back-to-Back-Wedge-Meter%20%28low%20res%29.png?w=400&h=400&position=c&color=ffffffff&quality=80&u=rf1shk",
					"brandImageUrl": "https://badgermeter.widen.net/content/zzheljuso0/png/Preso-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
					"productName": "COIN NN",
					"url": "/products/meters/differential-pressure-flow-meters/coin-back-to-back-wedge-model-nn-flow-meter/",
					"id": "136",
					"stats": [
						{
							"label": "Size",
							"valueImperial": "1/2...6 in.",
							"valueMetric": "12...152 mm"
						},
						{
							"label": "Temperature Range",
							"valueImperial": "Up to 800 F",
							"valueMetric": "Up to 426 C"
						},
						{
							"label": "Pressure Range",
							"valueImperial": "Dependent on flange rating",
							"valueMetric": "Dependent on flange rating"
						},
						{
							"label": "Accuracy",
							"valueImperial": "(uncalibrated) 3% (calibrated) 0.5%",
							"valueMetric": "(uncalibrated) 3% (calibrated) 0.5%"
						}
					],
					"markets": [
						"Oil & Gas",
						"Process & General Industry",
						"Refining, Chemical & Petrochemical"
					],
					"productCategory": "Meters",
					"productType": "Differential Pressure Flow Meters",
					"brand": "Preso",
					"flowTypes": [
						"Oil",
						"Steam",
						"Air / Gas",
						"Water",
						"Other liquid"
					],
					"guid": "2acc193c-dad7-45e2-b2da-d66715c99b6d"
				},
				{
					"productImageUrl": "https://badgermeter.widen.net/content/qi7m5tqc94/jpeg/COIN-NW%20%28low%20res%29.png?w=400&h=400&position=c&color=ffffffff&quality=80&u=rf1shk",
					"brandImageUrl": "https://badgermeter.widen.net/content/zzheljuso0/png/Preso-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
					"productName": "Coin NW",
					"url": "/products/meters/differential-pressure-flow-meters/coin-wedge-wafer-model-nw-flow-meter/",
					"id": "135",
					"stats": [
						{
							"label": "Size",
							"valueImperial": "1/2...4 in.",
							"valueMetric": "13...101 mm"
						},
						{
							"label": "Temperature Range",
							"valueImperial": "Up to 800 F",
							"valueMetric": "Up to 426 C"
						},
						{
							"label": "Pressure Rating",
							"valueImperial": "Dependent on flange rating ",
							"valueMetric": "Dependent on flange rating"
						},
						{
							"label": "Accuracy",
							"valueImperial": "(uncalibrated) 3% (calibrated) 0.5%",
							"valueMetric": "(uncalibrated) 3% (calibrated) 0.5%"
						}
					],
					"markets": [
						"Oil & Gas",
						"Process & General Industry",
						"Refining, Chemical & Petrochemical"
					],
					"productCategory": "Meters",
					"productType": "Differential Pressure Flow Meters",
					"brand": "Preso",
					"flowTypes": [
						"Oil",
						"Steam",
						"Air / Gas",
						"Water",
						"Other liquid"
					],
					"guid": "d7a7121d-391a-4f4c-80f8-d682bf7669d8"
				},
				{
					"productImageUrl": "https://badgermeter.widen.net/content/pyfbogfk4l/jpeg/2019_Cone%20Meter%20%28low%20res%29.png?w=400&h=400&position=c&color=ffffffff&quality=80&u=rf1shk",
					"brandImageUrl": "https://badgermeter.widen.net/content/zzheljuso0/png/Preso-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
					"productName": "Cone DP Meters",
					"url": "/products/meters/differential-pressure-flow-meters/cone-differential-pressure-flow-meter/",
					"id": "140",
					"stats": [
						{
							"label": "Size",
							"valueImperial": "1/2...24 in.",
							"valueMetric": "12...609 mm"
						},
						{
							"label": "Accuracy",
							"valueImperial": "0.5%",
							"valueMetric": "0.5%"
						}
					],
					"markets": [
						"Aviation & Aerospace",
						"Building Design, HVAC, & Plumbing",
						"Municipal Water Treatment & Distribution",
						"Oil & Gas",
						"Process & General Industry",
						"Refining, Chemical & Petrochemical",
						"Test Equipment & Services"
					],
					"productCategory": "Meters",
					"productType": "Differential Pressure Flow Meters",
					"brand": "Preso",
					"flowTypes": [
						"Oil",
						"Steam",
						"Air / Gas",
						"Water",
						"Other liquid"
					],
					"guid": "d3bcb2a8-dab3-459d-8be6-b7c7489d6298"
				},
				{
					"productImageUrl": "https://badgermeter.widen.net/content/sabwvp2yss/jpeg/Cox%20Gas%20Turbine%20Meters%20%28low-res%29.png?w=600&h=600&position=c&color=ffffffff&quality=80&u=rb73pf",
					"brandImageUrl": "https://badgermeter.widen.net/content/i3c0moz15i/png/Cox-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
					"productName": "CPG - Precision Meter for Gases",
					"url": "/products/meters/turbine-flow-meters/precision-gas-flow-meter/",
					"id": "148",
					"stats": [
						{
							"label": "Size Range",
							"valueImperial": "0.25...2 in. ",
							"valueMetric": "6...50 mm"
						},
						{
							"label": "Flow Range",
							"valueImperial": "0.4...250 scfm",
							"valueMetric": "1.89...118 lps"
						},
						{
							"label": "Pressure Range",
							"valueImperial": "Up to 5000 PSI",
							"valueMetric": "Up to 344 bar"
						},
						{
							"label": "Temperature Range",
							"valueImperial": "Up to 500 F",
							"valueMetric": "Up to 260 C"
						}
					],
					"markets": [
						"Aviation & Aerospace",
						"Process & General Industry",
						"Refining, Chemical & Petrochemical",
						"Test Equipment & Services"
					],
					"productCategory": "Meters",
					"productType": "Turbine Flow Meters",
					"brand": "Cox",
					"flowTypes": [
						"Air / Gas"
					],
					"guid": "ce0c3b13-f870-4112-baba-a86e1fc064c0"
				},
				{
					"productImageUrl": "https://badgermeter.widen.net/content/ylw0ld9kol/jpeg/Cox%20Precision%20Turbine%20Meters%20%28low-res%29.png?w=600&h=600&keep=c&crop=yes&color=ffffffff&quality=80&u=rf1shk",
					"brandImageUrl": "https://badgermeter.widen.net/content/i3c0moz15i/png/Cox-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
					"productName": "CPT - Precision Single Rotor",
					"url": "/products/meters/turbine-flow-meters/precision-turbine-meter/",
					"id": "146",
					"stats": [
						{
							"label": "Size Range",
							"valueImperial": "0.25...2 in.",
							"valueMetric": "6...50 mm"
						},
						{
							"label": "Flow Range",
							"valueImperial": "0.05...310 gpm",
							"valueMetric": "0.19...1173 l/min"
						},
						{
							"label": "Pressure Range",
							"valueImperial": "Up to 6000 PSI",
							"valueMetric": "Up to 408 bar"
						},
						{
							"label": "Temperature Range",
							"valueImperial": "Up to 450 F ",
							"valueMetric": "Up to 232 C"
						}
					],
					"markets": [
						"Aviation & Aerospace",
						"Process & General Industry",
						"Refining, Chemical & Petrochemical",
						"Test Equipment & Services"
					],
					"productCategory": "Meters",
					"productType": "Turbine Flow Meters",
					"brand": "Cox",
					"flowTypes": [
						"Oil",
						"Air / Gas",
						"Water",
						"Other liquid"
					],
					"guid": "f9efd9cf-2b00-4661-97ac-2c6eba04a994"
				}
			],
			"SavedItemsCount": 0,
			"TotalResults": 7,
			"ViewProductLabel": "view product label"
		}
	},
	"searchResults": {
		"results": [
			{
				"title": null,
				"description": null,
				"imageUrl": null,
				"linkUrl": "https://badgermeter.widen.net/content/kosvfczpgm/original/ESM-UM-02782-EN_E-Series%20Ultrasonic%203%2C%204%20inch%20Meters%20User%20Manual?download=true&x.app=api",
				"filterValue": 157,
				"filterText": "Blog Posts"
			},
			{
				"title": "<p>Why Utilities Choose Cellular AMI Fixed Networks Over Traditional Fixed Networks</p>",
				"description": null,
				"imageUrl": null,
				"linkUrl": "/blog/why-utilities-choose-cellular-ami-fixed-networks-over-traditional-fixed-networks/",
				"filterValue": 157,
				"filterText": "Blog Posts"
			},
			{
				"title": null,
				"description": "Smart water systems are a growing trend among water utilities around the world. Find out why utilities are upgrading to improve meter reading efficiency and accuracy, decrease non-revenue water, enhance customer service processes and so much more. ",
				"imageUrl": null,
				"linkUrl": null,
				"filterValue": 157,
				"filterText": "Blog Posts"
			},
			{
				"title": "<p>AMR vs. AMI: What&rsquo;s the Difference?</p>",
				"description": "Discover the meanings behind automated meter reading (AMR) and advanced metering infrastructure (AMI), including what the technologies are and how they are used within the water metering industry. ",
				"imageUrl": null,
				"linkUrl": "/blog/amr-vs.-ami-whats-the-difference/",
				"filterValue": 157,
				"filterText": "Blog Posts"
			},
			{
				"title": "<p>How Cellular AMI and BEACON<sup>&reg;</sup> AMA Provide Enhanced Flexibility</p>",
				"description": "In order to support our water utility customers, our cellular advanced metering infrastructure (AMI) solution implements network as a service (NaaS) and BEACON Advanced Metering Analytics (AMA) cloud-based software. Find out how this combination helps utilities deliver high-quality water with improved flexibility.  ",
				"imageUrl": null,
				"linkUrl": "/blog/how-cellular-ami-and-beacon-ama-provide-enhanced-flexibility/",
				"filterValue": 157,
				"filterText": "Blog Posts"
			},
			{
				"title": "Endpoints",
				"description": "<p><span style=\"font-weight: 400;\">Badger Meter offers Advanced Metering Infrastructure (AMI) and Automated Meter Reading (AMR) endpoint hardware options as part of the ORION product family, including mobile, cellular, traditional fixed network and migratable solutions. </span></p>",
				"imageUrl": null,
				"linkUrl": "/products/endpoints/",
				"filterValue": 59,
				"filterText": "Product Categories"
			},
			{
				"title": "Managed AMI solution increases meter accuracy and optimizes customer service for Avon, Ohio",
				"description": "Once a small town not far from Cleveland, the City of Avon is now one of the fastest growing communities in northeast Ohio. The city is situated near Lake Erie, and its Distribution System serves approximately 10,500 residential and 1,000 commercial accounts. With a history of obsolete accounting records and older meter reading technologies (AMR), the City of Avon's water system was not keeping pace with its changing needs. ",
				"imageUrl": "https://via.placeholder.com/535x370",
				"linkUrl": "/case-studies/managed-ami-solution-increases-meter-accuracy-and-optimizes-customer-service-for-avon-ohio/",
				"filterValue": 59,
				"filterText": "Case Studies"
			},
			{
				"title": "Managed AMI solution increases meter accuracy and optimizes customer service for Avon, Ohio",
				"description": "Once a small town not far from Cleveland, the City of Avon is now one of the fastest growing communities in northeast Ohio. The city is situated near Lake Erie, and its Distribution System serves approximately 10,500 residential and 1,000 commercial accounts. With a history of obsolete accounting records and older meter reading technologies (AMR), the City of Avon's water system was not keeping pace with its changing needs. ",
				"imageUrl": "https://via.placeholder.com/535x370",
				"linkUrl": "/case-studies2/managed-ami-solution-increases-meter-accuracy-and-optimizes-customer-service-for-avon-ohio/",
				"filterValue": 158,
				"filterText": "Case Studies"
			},
			{
				"title": "<p>Advanced Metering Infrastructure</p>",
				"description": "",
				"imageUrl": "https://via.placeholder.com/535x370",
				"linkUrl": "/markets/potable-water-billing/advanced-metering-infrastructure/",
				"filterValue": 159,
				"filterText": "Market Segments"
			},
			{
				"title": "ORION",
				"description": "<p><span style=\"font-weight: 400;\">Badger Meter offers </span><span style=\"font-weight: 400;\">Advanced Metering Infrastructure (AMI)</span><span style=\"font-weight: 400;\"> and </span><span style=\"font-weight: 400;\">Automated Meter Reading (AMR)</span><span style=\"font-weight: 400;\"> endpoint hardware options as part of the ORION product family, including mobile, cellular, traditional fixed network and migratable solutions.</span></p>",
				"imageUrl": null,
				"linkUrl": "/products/endpoints/orion/",
				"filterValue": 56,
				"filterText": "Product Lines"
			},
			{
				"title": "<p>3 Ways Smart Water Solutions Improve Meter Reading for Utilities</p>",
				"description": "",
				"imageUrl": null,
				"linkUrl": "/blog/3-ways-smart-water-solutions-improve-meter-reading-for-utilities/",
				"filterValue": 157,
				"filterText": "Blog Posts"
			},
			{
				"title": "<p>Smart Water Is: Future-Proof Technology</p>",
				"description": "Cellular advanced metering infrastructure (AMI) solutions are designed to provide utilities with future-proof technology that supports their water system now and for decades to come. ",
				"imageUrl": null,
				"linkUrl": "/blog/smart-water-is-future-proof-technology/",
				"filterValue": 157,
				"filterText": "Blog Posts"
			},
			{
				"title": "<p>Columbia, SC Case Study</p>",
				"description": "City and utility leaders in Columbia, South Carolina, recognized a need to upgrade the city's aging water system to improve reliability, efficiency and conservation. After careful review, they selected an advanced metering infrastructure (AMI) system from Badger Meter. ",
				"imageUrl": null,
				"linkUrl": "/blog/columbia-sc-case-study/",
				"filterValue": 157,
				"filterText": "Blog Posts"
			},
			{
				"title": "<p>Smart Water Is: The Widest Range of Metering Solutions</p>",
				"description": "To meet the needs of all utilities, Badger Meter offers the widest range of metering solutions to help every utility find their tailored systemwhether that means mechanical or electronic meters, mobile automated meter reading (AMR) or advanced metering infrastructure (AMI) networks supporting a partial or full deployment.",
				"imageUrl": null,
				"linkUrl": "/blog/smart-water-is-the-widest-range-of-metering-solutions/",
				"filterValue": 157,
				"filterText": "Blog Posts"
			},
			{
				"title": "<p>Smart Water 101: What You Need to Know</p>",
				"description": "When every drop counts more than ever, it's clear to see why the municipal water industry has undergone a pivotal transformation to implement smart solutions that are revolutionizing water systems. Learn everything you need to know in this Smart Water 101 blog. ",
				"imageUrl": null,
				"linkUrl": "/blog/smart-water-101-what-you-need-to-know/",
				"filterValue": 157,
				"filterText": "Blog Posts"
			}
		],
		"savedItemsCount": 0,
		"totalResults": 17,
		"filterCountResults": [
			{
				"filterValue": 45,
				"count": 1
			},
			{
				"filterValue": 128,
				"count": 2
			},
			{
				"filterValue": 59,
				"count": 3
			}
		],
		"didYouMean": "SEARCH TERM"
	},
	"searchResults2": {
		"results": [
			{
				"title": "<p>blahblah</p>",
				"contentType": "BlogPage",
				"description": "In order to support our water utility customers, our cellular advanced metering infrastructure (AMI) solution implements network as a service (NaaS) and BEACON Advanced Metering Analytics (AMA) cloud-based software. Find out how this combination helps utilities deliver high-quality water with improved flexibility.  ",
				"imageUrl": null,
				"linkUrl": "/blog/how-cellular-ami-and-beacon-ama-provide-enhanced-flexibility/",
				"filterGroup": "News & Insights",
				"filterValue": "BlogPage",
				"filterText": "Blog"
			},
			{
				"title": "<p>Smart Water Is: Robust and Resilient AMI</p>",
				"contentType": "BlogPage",
				"description": "With cellular advanced metering infrastructure (AMI) solutions, utilities are benefiting from the unmatched uptime and resilience of cellular networks to keep their operations safe and secure.",
				"imageUrl": null,
				"linkUrl": "/blog/smart-water-is-robust-and-resilient-ami/",
				"filterGroup": "News & Insights",
				"filterValue": "BlogPage",
				"filterText": "Blog"
			}
		],
		"filterCountResults": [
			{
				"filterValue": 45,
				"count": 1
			},
			{
				"filterValue": 128,
				"count": 1
			},
			{
				"filterValue": 94,
				"count": 1
			}
		]
	},
	"documentsById": {
		"results": [
			{
				"eyebrow": "APPLICATION DATA SHEET",
				"name": "Electromagnetic flow meter data sheet",
				"details": "ModMAG M-Series M2000",
				"language": "English",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "36"
			},
			{
				"eyebrow": "APPLICATION DATA SHEET2",
				"name": "Electromagnetic flow meter data sheet",
				"details": "ModMAG M-Series M2000",
				"language": "English",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "36"
			},
			{
				"eyebrow": "APPLICATION DATA SHEET3",
				"name": "Electromagnetic flow meter data sheet",
				"details": "ModMAG M-Series M2000",
				"language": "English",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "36"
			}
		]
	},
	"softwareById": {
		"results": [
			{
				"eyebrow": "Dynasonics",
				"name": "<p>Dynasonics TFX Ultra - English Firmware<sup>&reg;</sup><p>",
				"details": "Firmware | Version D007-1045-018_RevT | Updated July 23, 2020 | 190 KB | <a href=\"\">See release notes</a>",
				"downloadUrl": "https://badgermeter.widen.net/content/v4yty5lduv/original/Dynasonics%20TFX%20Ultra%20-%20English%20Firmware-D007-1045-018_RevT.zip?download=true&x.app=api&expires=1595695089240&signature.version=V3&signature=aY-cU4AjThtvO94DKpSRRQrSh9ZCgOLNPxZF_zKFoPQ%3D",
				"viewDetailsUrl": "/en/test-software-page-1/",
				"id": "73"
			},
			{
				"eyebrow": "eyebrow",
				"name": "Dynasonics TFX Ultra - French Firmware2",
				"details": "Firmware | Version D007-1045-020_RevU | Updated July 23, 2020 | 190 KB | <a href=\"\">See release notes</a>",
				"downloadUrl": "https://badgermeter.widen.net/content/rrutsxzq68/original/Dynasonics%20TFX%20Ultra%20-%20French%20Firmware-D007-1045-020_RevU.zip?download=true&x.app=api&expires=1595695089240&signature.version=V3&signature=f74dbR2mLkoPvrwCrBmbJm-s899ZfXukzr3hLRJr_Lw%3D",
				"viewDetailsUrl": null,
				"id": "74"
			},
			{
				"eyebrow": "Dynasonics",
				"name": "Dynasonics TFX Ultra EtherNet-IP eds file",
				"details": "Software | Version N/A | Updated July 23, 2020 | 25 KB | <a href=\"\">See release notes</a>",
				"downloadUrl": "https://badgermeter.widen.net/content/w98jtufybu/original/Dynasonics%20TFX%20Ultra%20EtherNet-IP%20eds%20file.eds?download=true&x.app=api&expires=1595695089240&signature.version=V3&signature=gapKEGxWK38f6VfA55eWyYZRZxueLPQMR-iuzfijZsY%3D",
				"viewDetailsUrl": null,
				"id": "75"
			}
		]
	},
	"recentPosts": {
		"success": "true",
		"page": 1,
		"count": 50,
		"prevPage": null,
		"nextPage": 3,
		"pageCount": 3,
		"totalPages": 6,
		"limit": 24,
		"results": [
			{
				"image": "https://placehold.it/353x550",
				"title": "<p>10 ways flow meters aid in water & wastewater treatment</p>",
				"url": "#",
				"type": "Article",
				"info": "2 min read"
			},
			{
				"image": "https://placehold.it/353x550",
				"title": "<b>Blancett meters</b> help hydraulic fracturing companies",
				"url": "#",
				"type": "Article",
				"info": "2 min read"
			},
			{
				"image": "https://placehold.it/353x550",
				"title": "<strong>High temperature</strong><sup></sup> gas control for automotive test cell",
				"url": "#",
				"type": "Article",
				"info": "2 min read"
			},
			{
				"image": "https://placehold.it/353x550",
				"title": "<span style='font-weight: 400;font-size:20px;color: red;line-height:30px;'>High temperature gas control for automotive test cell</span>",
				"url": "#",
				"type": "Article",
				"info": "2 min read"
			}
		]
	},
	"productsByBrand": {
		"success": "true",
		"results": [
			{
				"key": "B1500 Turbine Flow Meter",
				"value": "B1500 Turbine Flow Meter"
			},
			{
				"key": "B1750 Positive Displacement Meter",
				"value": "B1750 Positive Displacement Meter"
			},
			{
				"key": "B2900 Series Flow Monitor",
				"value": "B2900 Series Flow Monitor"
			},
			{
				"key": "B3000 Series Flow Monitor",
				"value": "B3000 Series Flow Monitor"
			},
			{
				"key": "B3100 Series Flow Monitor",
				"value": "B3100 Series Flow Monitor"
			},
			{
				"key": "FloClean Sanitary Turbine Flow Meter",
				"value": "FloClean Sanitary Turbine Flow Meter"
			},
			{
				"key": "Intelligent Frequency Converter",
				"value": "<p>Intelligent Frequency Converter</p>"
			},
			{
				"key": "K-Factor Scaler (Blancett)",
				"value": "<p>K-Factor Scaler (Blancett)</p>"
			},
			{
				"key": "Model 1100 Turbine Flow Meter",
				"value": "Model 1100 Turbine Flow Meter"
			},
			{
				"key": "Model 1200 In-Line Turbine Flow Meter",
				"value": "Model 1200 In-Line Turbine Flow Meter"
			},
			{
				"key": "Model 900 Series Flow Meter",
				"value": "900 Series Flow Meter"
			},
			{
				"key": "QuikSert Gas B142",
				"value": "<p>B142 Gas QuikSert<sup>&reg;</sup> Turbine Flow Meter</p>"
			},
			{
				"key": "QuikSert In-Line Turbine Flow Meter",
				"value": "<p>QuikSert<sup>&reg;</sup> In-Line Turbine Flow Meter</p>"
			}
		]
	},
	"products": {
		"success": "true",
		"viewProductLabel": "View product label",
		"totalResults": 10,
		"results": [
			{
				"productImageUrl": "https://badgermeter.widen.net/content/odvvjf5xo7/jpeg/10%2C000%20psi%20-%20HP-10%20%28low-res%29.png?w=600&h=600&position=c&color=ffffffff&quality=80&u=rb73pf",
				"brandImageUrl": "https://badgermeter.widen.net/content/9pdcioduim/png/RCV-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
				"productName": "<p>10,000 PSI Type HP-10 High Pressure Control Valve</p>",
				"url": "/products/valves/10000-psi-type-hp-10-high-pressure-control-valve/",
				"id": "70",
				"stats": [
					{
						"label": "Size",
						"valueImperial": "1/4...1/2 in.",
						"valueMetric": "6...12 mm"
					},
					{
						"label": "Temperature Range",
						"valueImperial": "751000 F",
						"valueMetric": "24538 C"
					},
					{
						"label": "Flow Range",
						"valueImperial": "02.5 cv",
						"valueMetric": "0...35.75 kv"
					},
					{
						"label": "Pressure Range",
						"valueImperial": "Up to 10,000 PSI",
						"valueMetric": "Up to 689 bar"
					}
				],
				"markets": [
					"Aviation & Aerospace",
					"Oil & Gas",
					"Process & General Industry",
					"Refining, Chemical & Petrochemical",
					"Test Equipment & Services"
				],
				"productCategory": "Valves",
				"productType": null,
				"brand": "Research Control Valves",
				"flowTypes": [
					"Oil",
					"Steam",
					"Air / Gas",
					"Water",
					"Other liquid"
				],
				"guid": "b51983af-7c6e-44d2-850d-477bf9968dc5"
			},
			{
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG <sup>M-Series</sup> sample",
				"url": "/url/to/product",
				"id": "7",
				"brand": "brand2",
				"stats": [
					{
						"label": "Size",
						"valueMetric": "54 cm.",
						"valueImperial": "5634 in."
					},
					{
						"label": "Temperature range",
						"valueMetric": "up tp 123C",
						"valueImperial": "up tp 123F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 123 metric",
						"valueImperial": "up tp 123 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "8",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000",
				"url": "/url/to/product",
				"id": "12",
				"brand": "brand4",
				"stats": [
					{
						"label": "Size",
						"valueMetric": "1-7 cm.",
						"valueImperial": "1/4-2 in."
					},
					{
						"label": "Temperature range",
						"valueMetric": "up tp 000C",
						"valueImperial": "up tp 000F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 000 metric",
						"valueImperial": "up tp 000 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "9",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "10",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "11",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "17",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "18",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			}
		]
	},
	"productsTest": {
		"success": "true",
		"viewProductLabel": "View product label",
		"totalResults": 10,
		"results": [
			{
				"productImageUrl": "https://badgermeter.widen.net/content/odvvjf5xo7/jpeg/10%2C000%20psi%20-%20HP-10%20%28low-res%29.png?w=600&h=600&position=c&color=ffffffff&quality=80&u=rb73pf",
				"brandImageUrl": "https://badgermeter.widen.net/content/9pdcioduim/png/RCV-Logo_Simplified_Gray%20%28Low%20Res%29.png?h=36&position=c&color=ffffff00&quality=80&u=uzmwhv",
				"productName": "<p>Test</p>",
				"url": "/products/valves/10000-psi-type-hp-10-high-pressure-control-valve/",
				"id": "4561",
				"stats": [
					{
						"label": "Size",
						"valueImperial": "1/4...1/2 in.",
						"valueMetric": "6...12 mm"
					},
					{
						"label": "Temperature Range",
						"valueImperial": "751000 F",
						"valueMetric": "24538 C"
					},
					{
						"label": "Flow Range",
						"valueImperial": "02.5 cv",
						"valueMetric": "0...35.75 kv"
					},
					{
						"label": "Pressure Range",
						"valueImperial": "Up to 10,000 PSI",
						"valueMetric": "Up to 689 bar"
					}
				],
				"markets": [
					"Aviation & Aerospace",
					"Oil & Gas",
					"Process & General Industry",
					"Refining, Chemical & Petrochemical",
					"Test Equipment & Services"
				],
				"productCategory": "Valves",
				"productType": null,
				"brand": "Research Control Valves",
				"flowTypes": [
					"Oil",
					"Steam",
					"Air / Gas",
					"Water",
					"Other liquid"
				],
				"guid": "b51983af-7c6e-44d2-850d-477bf9968dc5"
			},
			{
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG <sup>M-Series</sup> sample",
				"url": "/url/to/product",
				"id": "700",
				"brand": "brand2",
				"stats": [
					{
						"label": "Size",
						"valueMetric": "54 cm.",
						"valueImperial": "5634 in."
					},
					{
						"label": "Temperature range",
						"valueMetric": "up tp 123C",
						"valueImperial": "up tp 123F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 123 metric",
						"valueImperial": "up tp 123 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "test testModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "800",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000",
				"url": "/url/to/product",
				"id": "1200",
				"brand": "brand4",
				"stats": [
					{
						"label": "Size",
						"valueMetric": "1-7 cm.",
						"valueImperial": "1/4-2 in."
					},
					{
						"label": "Temperature range",
						"valueMetric": "up tp 000C",
						"valueImperial": "up tp 000F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 000 metric",
						"valueImperial": "up tp 000 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "900",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "500",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "400",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "100",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			},
			{
				"productImageUrl": "https://placehold.it/200x150",
				"brandImageUrl": "https://placehold.it/62x20",
				"productName": "ModMAG M-Series M2000 blah blah blah",
				"url": "/url/to/product",
				"id": "150",
				"brand": "brand3",
				"stats": [
					{
						"label": "Something else",
						"valueMetric": "97 cm.",
						"valueImperial": "3435 in."
					},
					{
						"label": "Something",
						"valueMetric": "up tp 765C",
						"valueImperial": "up tp 777F"
					},
					{
						"label": "Prassure range",
						"valueMetric": "up tp 777 metric",
						"valueImperial": "up tp 777 us"
					}
				]
			}
		]
	},
	"software": {
		"results": [
			{
				"eyebrow": "Dynasonics",
				"name": "LM_LM-OGA-OGTAER_ZUL_MID_01_2012",
				"details": "Firmware | Version D007-1045-018_RevT | Updated July 23, 2020 | 190 KB",
				"downloadUrl": "https://badgermeter.widen.net/content/v4yty5lduv/original/Dynasonics%20TFX%20Ultra%20Firmware%20%5BEnglish%5D%20-%20D007-1045-018_RevT.zip?download=true&x.app=api",
				"downloadHref": "#downloadhref",
				"viewDetailsUrl": null,
				"id": "295",
				"productName": null,
				"languages": [
					"English"
				],
				"brand": "Dynasonics",
				"brands": [
					"Dynasonics"
				],
				"downloadType": "Firmware",
				"documentName": "Dynasonics TFX Ultra Firmware [English]",
				"releaseNotes": "test test test test test"
			},
			{
				"eyebrow": "Impeller/Data Industrial",
				"name": "Impeller 340LW Series LonWorks Configuration Software",
				"details": "Software | Updated August 19, 2020 | 1 KB",
				"downloadUrl": "https://badgermeter.widen.net/content/hlnzlwdv0t/original/Impeller%20340LW%20Series%20LonWorks%20Configuration%20Software.zip?download=true&x.app=api",
				"downloadHref": "#downloadhref",
				"viewDetailsUrl": "/software-firmware/Impeller-340lw-series-lonworks-configuration-software/",
				"id": "438",
				"productName": "Type 340 LW-LonWorks BTU Transmitter",
				"languages": [
					"English"
				],
				"brand": "Impeller/Data Industrial",
				"brands": [
					"Impeller/Data Industrial"
				],
				"downloadType": "Software",
				"documentName": "Impeller 340LW Series LonWorks Configuration Software",
				"releaseNotes": null
			},
			{
				"eyebrow": "ModMAG",
				"name": "ModMag Field Verification Device PC Software",
				"details": "Software | Version v1.0.17 | Updated August 19, 2020 | 7.02 MB",
				"downloadUrl": "https://badgermeter.widen.net/content/zjvppiew3o/original/ModMAG%20Field%20Verification%20Device%20PC%20Software%20-%20v1.0.17.zip?download=true&x.app=api",
				"downloadHref": "#downloadhref",
				"viewDetailsUrl": "/software-firmware/modmag-field-verification-device-pc-software/",
				"id": "446",
				"productName": null,
				"languages": [
					"English"
				],
				"brand": "ModMAG",
				"brands": [
					"ModMAG"
				],
				"downloadType": "Software",
				"documentName": "ModMag Field Verification Device PC Software",
				"releaseNotes": null
			},
			{
				"eyebrow": "Blancett",
				"name": "Blancett B3100 Monitor Configuration Software",
				"details": "Software | Updated August 19, 2020 | 1.51 MB",
				"downloadUrl": "https://badgermeter.widen.net/content/5y34yrqpp6/original/Blancett%20B3100%20Monitor%20Configuration%20Software.zip?download=true&x.app=api",
				"downloadHref": "#downloadhref",
				"viewDetailsUrl": "/software-firmware/blancett-b3100-monitor-configuration-software/",
				"id": "452",
				"productName": "B3100 Series Flow Monitor",
				"languages": [
					"English"
				],
				"brand": "Blancett",
				"brands": [
					"Blancett"
				],
				"downloadType": "Software",
				"documentName": "Blancett B3100 Monitor Configuration Software",
				"releaseNotes": "test"
			},
			{
				"eyebrow": "Cox ; Impeller/Data Industrial",
				"name": "FC-5000 Firmware [Legacy]",
				"details": "Firmware | Version v1.2.4 | Updated August 19, 2020 | 374 KB",
				"downloadUrl": "https://badgermeter.widen.net/content/ka4jpbkvo0/original/FC-5000%20Firmware%20-%20Legacy%201.2.4.zip?download=true&x.app=api",
				"downloadHref": "#downloadhref",
				"viewDetailsUrl": "/software-firmware/fc-5000-firmware-legacy/",
				"id": "436",
				"productName": "FC-5000 BTU Monitor ; FC-5000 Flow Computer ; FC-5000 Flow Display",
				"languages": [
					"English"
				],
				"brand": "Cox, Impeller/Data Industrial",
				"brands": [
					"Cox",
					"Impeller/Data Industrial"
				],
				"downloadType": "Firmware",
				"documentName": "FC-5000 Firmware [Legacy]",
				"releaseNotes": null
			},
			{
				"eyebrow": "Coriolis",
				"name": "Coriolls RCTX Transmitter EtherNet/IP EDS",
				"details": "Software | Updated August 19, 2020 | 3 KB",
				"downloadUrl": "https://badgermeter.widen.net/content/b3csju1yft/original/Coriolls%20EtherNetIP%20eds%20file%20for%20RCTX%20transmitter.zip?download=true&x.app=api",
				"downloadHref": "#downloadhref",
				"viewDetailsUrl": "/software-firmware/coriolis-ethernet-ip-eds-file-for-rctx-transmitter/",
				"id": "450",
				"productName": null,
				"languages": [
					"English"
				],
				"brand": "Coriolis",
				"brands": [
					"Coriolis"
				],
				"downloadType": "Software",
				"documentName": "Coriolls RCTX Transmitter EtherNet/IP EDS",
				"releaseNotes": null
			},
			{
				"eyebrow": "Dynasonics",
				"name": "Dynaconics Flow Meter Tool",
				"details": "Software | Version v1.6.10 | Updated August 19, 2020 | 2.24 MB",
				"downloadUrl": "https://badgermeter.widen.net/content/p2nz5p5ylj/original/Dynaconics%20Flow%20Meter%20Tool%20-%20v1.6.10.zip?download=true&x.app=api",
				"downloadHref": "#downloadhref",
				"viewDetailsUrl": "/software-firmware/dynasonics-isonic-4000-flow-meter-software/",
				"id": "455",
				"productName": null,
				"languages": [
					"English"
				],
				"brand": "Dynasonics",
				"brands": [
					"Dynasonics"
				],
				"downloadType": "Software",
				"documentName": "Dynaconics Flow Meter Tool",
				"releaseNotes": null
			},
			{
				"eyebrow": "Research Control Valve (RCV)",
				"name": "RCV SEVA 100 EtherNet/IP Driver",
				"details": "Software | Updated August 19, 2020 | 3 KB",
				"downloadUrl": "https://badgermeter.widen.net/content/riwznioshg/original/RCV%20SEVA%20100%20EtherNetIP%20Driver.zip?download=true&x.app=api",
				"downloadHref": "#downloadhref",
				"viewDetailsUrl": "/software-firmware/rcv-seva-100-ethernet-ip-driver/",
				"id": "444",
				"productName": null,
				"languages": [
					"English"
				],
				"brand": "Research Control Valve (RCV)",
				"brands": [
					"Research Control Valve (RCV)"
				],
				"downloadType": "Software",
				"documentName": "RCV SEVA 100 EtherNet/IP Driver",
				"releaseNotes": null
			},
			{
				"eyebrow": "Coriolis",
				"name": "Coriolis RCT Calc Selection Tool",
				"details": "Software | Updated August 19, 2020 | 21.73 MB",
				"downloadUrl": "https://badgermeter.widen.net/content/ryl0fcae6v/original/Coriolis%20RCT%20Calc%20Selection%20Tool.zip?download=true&x.app=api",
				"downloadHref": "#downloadhref",
				"viewDetailsUrl": "/sizing-and-selection-tools/coriolis-rctcalc-selection-tool/",
				"id": "460",
				"productName": null,
				"languages": [
					"English"
				],
				"brand": "Coriolis",
				"brands": [
					"Coriolis"
				],
				"downloadType": "Software",
				"documentName": "Coriolis RCT Calc Selection Tool",
				"releaseNotes": null
			},
			{
				"eyebrow": "ModMAG",
				"name": "ModMAG M5000 Firmware",
				"details": "Firmware | Version v2.0.25 | Updated August 19, 2020 | 53 KB",
				"downloadUrl": "https://badgermeter.widen.net/content/767ksclvco/original/ModMAG%20M5000%20Firmware-v2.0.25.zip?download=true&x.app=api",
				"downloadHref": "#downloadhref",
				"viewDetailsUrl": "/software-firmware/modmag-m5000-firmware/",
				"id": "442",
				"productName": "M5000",
				"languages": [
					"English"
				],
				"brand": "ModMAG",
				"brands": [
					"ModMAG"
				],
				"downloadType": "Firmware",
				"documentName": "ModMAG M5000 Firmware",
				"releaseNotes": null
			}
		],
		"savedItemsCount": 0,
		"totalResults": 60,
		"releaseNotesLabel": "release notes label"
	},
	"documentation": {
		"results": [
			{
				"eyebrow": "APPLICATION DATA SHEET",
				"name": "LM_LM-OGA-OGTAER_ZUL_MID_01_2012",
				"details": "ModMAG M-Series M2000",
				"language": "English",
				"url": "https://badgermeter.widen.net/content/fjcdopcl3n/original/IOG-PS-00137-EN_Industrial%20Oval%20Gear%20Inline%20and%20Flanged%20Meters%20and%20Register%20Parts.pdf?download=true&x.app=api",
				"id": "35",
				"documentId": "abc-000-0000-000"
			},
			{
				"eyebrow": "MANUALS & GUIDES",
				"name": "Electromagnetic flow meter user manual",
				"details": "ModMAG M-Series M2000, test1, test2,test3, test4, test5",
				"language": "French",
				"url": "https://badgermeter.widen.net/content/hiv7vd69uo/original/TTM-SS-03125-EN_Dynasonics TFX-5000 Flow Meter Specifications.docx?download=true",
				"id": "36",
				"documentId": "def-000-0000-000"
			},
			{
				"eyebrow": "MANUALS & GUIDES",
				"name": "Test item 3",
				"details": "ModMAG M-Series M2000",
				"language": "French",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "37",
				"documentId": "ghi-000-0000-000"
			},
			{
				"eyebrow": "APPLICATION DATA SHEET",
				"name": "Electromagnetic flow meter data sheet",
				"details": "ModMAG M-Series M2000, test, test, test, test, test",
				"language": "English",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "38",
				"documentId": "jkl-000-0000-000"
			},
			{
				"eyebrow": "MANUALS & GUIDES",
				"name": "Electromagnetic flow meter user manual",
				"details": "ModMAG M-Series M2000",
				"language": "French",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "39",
				"documentId": "mno-000-0000-000"
			},
			{
				"eyebrow": "MANUALS & GUIDES",
				"name": "Test item 3",
				"details": "ModMAG M-Series M2000",
				"language": "French",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "40",
				"documentId": "prq-000-0000-000"
			},
			{
				"eyebrow": "MANUALS & GUIDES",
				"name": "Test item 3",
				"details": "ModMAG M-Series M2000",
				"language": "French",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "41",
				"documentId": "abc-000-0000-000"
			},
			{
				"eyebrow": "MANUALS & GUIDES",
				"name": "Test item 3",
				"details": "ModMAG M-Series M2000",
				"language": "French",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "42",
				"documentId": "abc-000-0000-000"
			},
			{
				"eyebrow": "MANUALS & GUIDES",
				"name": "Test item 3",
				"details": "ModMAG M-Series M2000",
				"language": "French",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "43",
				"documentId": "abc-000-0000-000"
			},
			{
				"eyebrow": "MANUALS & GUIDES",
				"name": "Test item 3",
				"details": "ModMAG M-Series M2000",
				"language": "French",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "44",
				"documentId": "abc-000-0000-000"
			}
		],
		"totalResults": 88
	},
	"documentationTest": {
		"results": [
			{
				"eyebrow": "APPLICATION DATA SHEET test",
				"name": "Electromagnetic flow meter data sheet",
				"details": "ModMAG M-Series M2000",
				"language": "English",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "350"
			},
			{
				"eyebrow": "MANUALS & GUIDES test",
				"name": "Electromagnetic flow meter user manual",
				"details": "ModMAG M-Series M2000",
				"language": "French",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "360"
			},
			{
				"eyebrow": "MANUALS & GUIDES",
				"name": "Test item 3",
				"details": "ModMAG M-Series M2000",
				"language": "French",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "370"
			}
		],
		"totalResults": 11
	},
	"legal": {
		"results": [
			{
				"eyebrow": "Purchase terms",
				"name": "Purchase order - general terms and conditions",
				"details": "North America, test2, test3, test4, test5",
				"language": "English",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "40"
			},
			{
				"eyebrow": "Sales terms",
				"name": "Badger Meter sales terms and onditions",
				"details": "North America, test1, test2",
				"language": "English",
				"url": "https://widen.badgermeter.com/damstuff/document.docx",
				"id": "70"
			}
		],
		"totalResults": 67
	},
	"validateIds": {
		"success": "true",
		"results": {
			"invalidIds": [
				10,
				5,
				110,
				2
			],
			"documentIds": [
				35,
				41
			],
			"softwareIds": [
				74
			],
			"productIds": [
				11,
				20,
				35,
				8
			],
			"articleIds": []
		}
	}
}
},{}],65:[function(require,module,exports){
/**
 * @popperjs/core v2.6.0 - MIT License
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect();
  return {
    width: rect.width,
    height: rect.height,
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    y: rect.top
  };
}

/*:: import type { Window } from '../types'; */

/*:: declare function getWindow(node: Node | Window): Window; */
function getWindow(node) {
  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/*:: declare function isElement(node: mixed): boolean %checks(node instanceof
  Element); */

function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof
  HTMLElement); */


function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
/*:: declare function isShadowRoot(node: mixed): boolean %checks(node instanceof
  ShadowRoot); */


function isShadowRoot(node) {
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = getComputedStyle(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// Composite means it takes into account transforms as well as layout.

function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement);
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }

    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.
function getLayoutRect(element) {
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}

function getParentNode(element) {
  if (getNodeName(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    // $FlowFixMe[incompatible-return]: need a better way to handle this...
    element.host || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element) // fallback

  );
}

function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }

  return getScrollParent(getParentNode(node));
}

/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  if (list === void 0) {
    list = [];
  }

  var scrollParent = getScrollParent(element);
  var isBody = getNodeName(scrollParent) === 'body';
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents(getParentNode(target)));
}

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
}

function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle(element).position === 'fixed') {
    return null;
  }

  var offsetParent = element.offsetParent;

  if (offsetParent) {
    var html = getDocumentElement(offsetParent);

    if (getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && getComputedStyle(html).position !== 'static') {
      return html;
    }
  }

  return offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var currentNode = getParentNode(element);

  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.

    if (css.transform !== 'none' || css.perspective !== 'none' || css.willChange && css.willChange !== 'auto') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static') {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    Object.keys(modifier).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

        case 'phase':
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (typeof modifier.effect !== 'function') {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (!Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign(Object.assign(Object.assign({}, existing), current), {}, {
      options: Object.assign(Object.assign({}, existing.options), current.options),
      data: Object.assign(Object.assign({}, existing.data), current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

function getViewportRect(element) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + getWindowScrollBarX(element),
    y: y
  };
}

// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = element.ownerDocument.body;
  var width = Math.max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = Math.max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;

  if (getComputedStyle(body || html).direction === 'rtl') {
    x += Math.max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

function rectToClientRect(rect) {
  return Object.assign(Object.assign({}, rect), {}, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

function getInnerBoundingClientRect(element) {
  var rect = getBoundingClientRect(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = Math.max(rect.top, accRect.top);
    accRect.right = Math.min(rect.right, accRect.right);
    accRect.bottom = Math.min(rect.bottom, accRect.bottom);
    accRect.left = Math.max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

function getVariation(placement) {
  return placement.split('-')[1];
}

function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
    }
  }

  return offsets;
}

function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

function mergePaddingObject(paddingObject) {
  return Object.assign(Object.assign({}, getFreshSideObject()), paddingObject);
}

function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var referenceElement = state.elements.reference;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = getBoundingClientRect(referenceElement);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = rectToClientRect(Object.assign(Object.assign({}, popperRect), popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign(Object.assign({}, DEFAULT_OPTIONS), defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(options) {
        cleanupModifierEffects();
        state.options = Object.assign(Object.assign(Object.assign({}, defaultOptions), state.options), options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if ("development" !== "production") {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);

          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = getComputedStyle(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if ("development" !== "production") {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
          popper: getLayoutRect(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if ("development" !== "production") {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if ("development" !== "production") {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


var eventListeners = {
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
};

function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
};

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: Math.round(x * dpr) / dpr || 0,
    y: Math.round(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets;

  var _ref3 = roundOffsets ? roundOffsetsByDPR(offsets) : offsets,
      _ref3$x = _ref3.x,
      x = _ref3$x === void 0 ? 0 : _ref3$x,
      _ref3$y = _ref3.y,
      y = _ref3$y === void 0 ? 0 : _ref3$y;

  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = left;
  var sideY = top;
  var win = window;

  if (adaptive) {
    var offsetParent = getOffsetParent(popper);

    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it

    /*:: offsetParent = (offsetParent: Element); */


    if (placement === top) {
      sideY = bottom;
      y -= offsetParent.clientHeight - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === left) {
      sideX = right;
      x -= offsetParent.clientWidth - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign(Object.assign({}, commonStyles), {}, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref4) {
  var state = _ref4.state,
      options = _ref4.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if ("development" !== "production") {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: getBasePlacement(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign(Object.assign({}, state.styles.popper), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign(Object.assign({}, state.styles.arrow), mapToStyles(Object.assign(Object.assign({}, commonStyles), {}, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


var computeStyles$1 = {
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
};

// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect$1(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


var applyStyles$1 = {
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect$1,
  requires: ['computeStyles']
};

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign(Object.assign({}, rects), {}, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var offset$1 = {
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
};

var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

var hash$1 = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash$1[matched];
  });
}

/*:: type OverflowsMap = { [ComputedPlacement]: number }; */

/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;

    if ("development" !== "production") {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }

  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = getBasePlacement(placement);

    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = detectOverflow(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }

    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases  research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


var flip$1 = {
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
};

function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

function within(min, value, max) {
  return Math.max(min, Math.min(value, max));
}

function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign(Object.assign({}, state.rects), {}, {
    placement: state.placement
  })) : tetherOffset;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var mainSide = mainAxis === 'y' ? top : left;
    var altSide = mainAxis === 'y' ? bottom : right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = popperOffsets[mainAxis] + overflow[mainSide];
    var max = popperOffsets[mainAxis] - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _mainSide = mainAxis === 'x' ? top : left;

    var _altSide = mainAxis === 'x' ? bottom : right;

    var _offset = popperOffsets[altAxis];

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var _preventedOffset = within(_min, _offset, _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


var preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = state.modifiersData[name + "#persistent"].padding;
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === 'y' ? top : left;
  var maxProp = axis === 'y' ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = within(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect$2(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,
      _options$padding = options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if ("development" !== "production") {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!contains(state.elements.popper, arrowElement)) {
    if ("development" !== "production") {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
  state.modifiersData[name + "#persistent"] = {
    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))
  };
} // eslint-disable-next-line import/no-unused-modules


var arrow$1 = {
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect$2,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
};

function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign(Object.assign({}, state.attributes.popper), {}, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


var hide$1 = {
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
};

var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper$1 = /*#__PURE__*/popperGenerator({
  defaultModifiers: defaultModifiers$1
}); // eslint-disable-next-line import/no-unused-modules

exports.applyStyles = applyStyles$1;
exports.arrow = arrow$1;
exports.computeStyles = computeStyles$1;
exports.createPopper = createPopper$1;
exports.createPopperLite = createPopper;
exports.defaultModifiers = defaultModifiers$1;
exports.detectOverflow = detectOverflow;
exports.eventListeners = eventListeners;
exports.flip = flip$1;
exports.hide = hide$1;
exports.offset = offset$1;
exports.popperGenerator = popperGenerator;
exports.popperOffsets = popperOffsets$1;
exports.preventOverflow = preventOverflow$1;


},{}],66:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":68}],67:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var createError = require('../core/createError');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = require('./../helpers/cookies');

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

},{"../core/buildFullPath":74,"../core/createError":75,"./../core/settle":79,"./../helpers/buildURL":83,"./../helpers/cookies":85,"./../helpers/isURLSameOrigin":87,"./../helpers/parseHeaders":89,"./../utils":91}],68:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = require('./cancel/Cancel');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"./cancel/Cancel":69,"./cancel/CancelToken":70,"./cancel/isCancel":71,"./core/Axios":72,"./core/mergeConfig":78,"./defaults":81,"./helpers/bind":82,"./helpers/spread":90,"./utils":91}],69:[function(require,module,exports){
'use strict';

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

},{}],70:[function(require,module,exports){
'use strict';

var Cancel = require('./Cancel');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./Cancel":69}],71:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],72:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

},{"../helpers/buildURL":83,"./../utils":91,"./InterceptorManager":73,"./dispatchRequest":76,"./mergeConfig":78}],73:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":91}],74:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

},{"../helpers/combineURLs":84,"../helpers/isAbsoluteURL":86}],75:[function(require,module,exports){
'use strict';

var enhanceError = require('./enhanceError');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

},{"./enhanceError":77}],76:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/isCancel":71,"../defaults":81,"./../utils":91,"./transformData":80}],77:[function(require,module,exports){
'use strict';

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};

},{}],78:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
  var defaultToConfig2Keys = [
    'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',
    'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath'
  ];

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
    if (utils.isObject(config2[prop])) {
      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (utils.isObject(config1[prop])) {
      config[prop] = utils.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys);

  var otherKeys = Object
    .keys(config2)
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  return config;
};

},{"../utils":91}],79:[function(require,module,exports){
'use strict';

var createError = require('./createError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};

},{"./createError":75}],80:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

},{"./../utils":91}],81:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('./utils');
var normalizeHeaderName = require('./helpers/normalizeHeaderName');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('./adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('./adapters/http');
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this)}).call(this,require('_process'))

},{"./adapters/http":67,"./adapters/xhr":67,"./helpers/normalizeHeaderName":88,"./utils":91,"_process":225}],82:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],83:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":91}],84:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],85:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

},{"./../utils":91}],86:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

},{}],87:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

},{"./../utils":91}],88:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":91}],89:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":91}],90:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],91:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function deepMerge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = deepMerge(result[key], val);
    } else if (typeof val === 'object') {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
};

},{"./helpers/bind":82}],92:[function(require,module,exports){
require('../../modules/es.array.find');
var entryUnbind = require('../../internals/entry-unbind');

module.exports = entryUnbind('Array', 'find');

},{"../../internals/entry-unbind":131,"../../modules/es.array.find":204}],93:[function(require,module,exports){
require('../../modules/es.string.iterator');
require('../../modules/es.array.from');
var path = require('../../internals/path');

module.exports = path.Array.from;

},{"../../internals/path":177,"../../modules/es.array.from":205,"../../modules/es.string.iterator":215}],94:[function(require,module,exports){
require('../../modules/es.array.includes');
var entryUnbind = require('../../internals/entry-unbind');

module.exports = entryUnbind('Array', 'includes');

},{"../../internals/entry-unbind":131,"../../modules/es.array.includes":206}],95:[function(require,module,exports){
require('../../modules/es.object.assign');
var path = require('../../internals/path');

module.exports = path.Object.assign;

},{"../../internals/path":177,"../../modules/es.object.assign":208}],96:[function(require,module,exports){
require('../../modules/es.aggregate-error');
require('../../modules/es.object.to-string');
require('../../modules/es.promise');
require('../../modules/es.promise.all-settled');
require('../../modules/es.promise.any');
require('../../modules/es.promise.finally');
require('../../modules/es.string.iterator');
require('../../modules/web.dom-collections.iterator');
var path = require('../../internals/path');

module.exports = path.Promise;

},{"../../internals/path":177,"../../modules/es.aggregate-error":203,"../../modules/es.object.to-string":209,"../../modules/es.promise":213,"../../modules/es.promise.all-settled":210,"../../modules/es.promise.any":211,"../../modules/es.promise.finally":212,"../../modules/es.string.iterator":215,"../../modules/web.dom-collections.iterator":221}],97:[function(require,module,exports){
require('../../modules/es.string.includes');
var entryUnbind = require('../../internals/entry-unbind');

module.exports = entryUnbind('String', 'includes');

},{"../../internals/entry-unbind":131,"../../modules/es.string.includes":214}],98:[function(require,module,exports){
require('../../modules/es.symbol.iterator');
require('../../modules/es.string.iterator');
require('../../modules/web.dom-collections.iterator');
var WrappedWellKnownSymbolModule = require('../../internals/well-known-symbol-wrapped');

module.exports = WrappedWellKnownSymbolModule.f('iterator');

},{"../../internals/well-known-symbol-wrapped":201,"../../modules/es.string.iterator":215,"../../modules/es.symbol.iterator":216,"../../modules/web.dom-collections.iterator":221}],99:[function(require,module,exports){
var parent = require('../../es/promise');
require('../../modules/esnext.aggregate-error');
// TODO: Remove from `core-js@4`
require('../../modules/esnext.promise.all-settled');
require('../../modules/esnext.promise.try');
require('../../modules/esnext.promise.any');

module.exports = parent;

},{"../../es/promise":96,"../../modules/esnext.aggregate-error":217,"../../modules/esnext.promise.all-settled":218,"../../modules/esnext.promise.any":219,"../../modules/esnext.promise.try":220}],100:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};

},{}],101:[function(require,module,exports){
var isObject = require('../internals/is-object');

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};

},{"../internals/is-object":150}],102:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');
var create = require('../internals/object-create');
var definePropertyModule = require('../internals/object-define-property');

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

},{"../internals/object-create":164,"../internals/object-define-property":166,"../internals/well-known-symbol":202}],103:[function(require,module,exports){
module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};

},{}],104:[function(require,module,exports){
var isObject = require('../internals/is-object');

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};

},{"../internals/is-object":150}],105:[function(require,module,exports){
'use strict';
var bind = require('../internals/function-bind-context');
var toObject = require('../internals/to-object');
var callWithSafeIterationClosing = require('../internals/call-with-safe-iteration-closing');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var toLength = require('../internals/to-length');
var createProperty = require('../internals/create-property');
var getIteratorMethod = require('../internals/get-iterator-method');

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};

},{"../internals/call-with-safe-iteration-closing":110,"../internals/create-property":120,"../internals/function-bind-context":135,"../internals/get-iterator-method":137,"../internals/is-array-iterator-method":147,"../internals/to-length":195,"../internals/to-object":196}],106:[function(require,module,exports){
var toIndexedObject = require('../internals/to-indexed-object');
var toLength = require('../internals/to-length');
var toAbsoluteIndex = require('../internals/to-absolute-index');

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

},{"../internals/to-absolute-index":192,"../internals/to-indexed-object":193,"../internals/to-length":195}],107:[function(require,module,exports){
var bind = require('../internals/function-bind-context');
var IndexedObject = require('../internals/indexed-object');
var toObject = require('../internals/to-object');
var toLength = require('../internals/to-length');
var arraySpeciesCreate = require('../internals/array-species-create');

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_OUT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push.call(target, value); // filterOut
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterOut` method
  // https://github.com/tc39/proposal-array-filtering
  filterOut: createMethod(7)
};

},{"../internals/array-species-create":109,"../internals/function-bind-context":135,"../internals/indexed-object":144,"../internals/to-length":195,"../internals/to-object":196}],108:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var has = require('../internals/has');

var defineProperty = Object.defineProperty;
var cache = {};

var thrower = function (it) { throw it; };

module.exports = function (METHOD_NAME, options) {
  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
  if (!options) options = {};
  var method = [][METHOD_NAME];
  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
  var argument0 = has(options, 0) ? options[0] : thrower;
  var argument1 = has(options, 1) ? options[1] : undefined;

  return cache[METHOD_NAME] = !!method && !fails(function () {
    if (ACCESSORS && !DESCRIPTORS) return true;
    var O = { length: -1 };

    if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower });
    else O[1] = 1;

    method.call(O, argument0, argument1);
  });
};

},{"../internals/descriptors":123,"../internals/fails":134,"../internals/has":139}],109:[function(require,module,exports){
var isObject = require('../internals/is-object');
var isArray = require('../internals/is-array');
var wellKnownSymbol = require('../internals/well-known-symbol');

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

},{"../internals/is-array":148,"../internals/is-object":150,"../internals/well-known-symbol":202}],110:[function(require,module,exports){
var anObject = require('../internals/an-object');
var iteratorClose = require('../internals/iterator-close');

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    iteratorClose(iterator);
    throw error;
  }
};

},{"../internals/an-object":104,"../internals/iterator-close":154}],111:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};

},{"../internals/well-known-symbol":202}],112:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],113:[function(require,module,exports){
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var classofRaw = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

},{"../internals/classof-raw":112,"../internals/to-string-tag-support":198,"../internals/well-known-symbol":202}],114:[function(require,module,exports){
var has = require('../internals/has');
var ownKeys = require('../internals/own-keys');
var getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');
var definePropertyModule = require('../internals/object-define-property');

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

},{"../internals/has":139,"../internals/object-define-property":166,"../internals/object-get-own-property-descriptor":167,"../internals/own-keys":176}],115:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};

},{"../internals/well-known-symbol":202}],116:[function(require,module,exports){
var fails = require('../internals/fails');

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

},{"../internals/fails":134}],117:[function(require,module,exports){
'use strict';
var IteratorPrototype = require('../internals/iterators-core').IteratorPrototype;
var create = require('../internals/object-create');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var setToStringTag = require('../internals/set-to-string-tag');
var Iterators = require('../internals/iterators');

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};

},{"../internals/create-property-descriptor":119,"../internals/iterators":156,"../internals/iterators-core":155,"../internals/object-create":164,"../internals/set-to-string-tag":185}],118:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"../internals/create-property-descriptor":119,"../internals/descriptors":123,"../internals/object-define-property":166}],119:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],120:[function(require,module,exports){
'use strict';
var toPrimitive = require('../internals/to-primitive');
var definePropertyModule = require('../internals/object-define-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};

},{"../internals/create-property-descriptor":119,"../internals/object-define-property":166,"../internals/to-primitive":197}],121:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var createIteratorConstructor = require('../internals/create-iterator-constructor');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var setToStringTag = require('../internals/set-to-string-tag');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');
var Iterators = require('../internals/iterators');
var IteratorsCore = require('../internals/iterators-core');

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};

},{"../internals/create-iterator-constructor":117,"../internals/create-non-enumerable-property":118,"../internals/export":133,"../internals/is-pure":151,"../internals/iterators":156,"../internals/iterators-core":155,"../internals/object-get-prototype-of":170,"../internals/object-set-prototype-of":174,"../internals/redefine":181,"../internals/set-to-string-tag":185,"../internals/well-known-symbol":202}],122:[function(require,module,exports){
var path = require('../internals/path');
var has = require('../internals/has');
var wrappedWellKnownSymbolModule = require('../internals/well-known-symbol-wrapped');
var defineProperty = require('../internals/object-define-property').f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};

},{"../internals/has":139,"../internals/object-define-property":166,"../internals/path":177,"../internals/well-known-symbol-wrapped":201}],123:[function(require,module,exports){
var fails = require('../internals/fails');

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});

},{"../internals/fails":134}],124:[function(require,module,exports){
var global = require('../internals/global');
var isObject = require('../internals/is-object');

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};

},{"../internals/global":138,"../internals/is-object":150}],125:[function(require,module,exports){
// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

},{}],126:[function(require,module,exports){
var userAgent = require('../internals/engine-user-agent');

module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);

},{"../internals/engine-user-agent":129}],127:[function(require,module,exports){
var classof = require('../internals/classof-raw');
var global = require('../internals/global');

module.exports = classof(global.process) == 'process';

},{"../internals/classof-raw":112,"../internals/global":138}],128:[function(require,module,exports){
var userAgent = require('../internals/engine-user-agent');

module.exports = /web0s(?!.*chrome)/i.test(userAgent);

},{"../internals/engine-user-agent":129}],129:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');

module.exports = getBuiltIn('navigator', 'userAgent') || '';

},{"../internals/get-built-in":136}],130:[function(require,module,exports){
var global = require('../internals/global');
var userAgent = require('../internals/engine-user-agent');

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;

},{"../internals/engine-user-agent":129,"../internals/global":138}],131:[function(require,module,exports){
var global = require('../internals/global');
var bind = require('../internals/function-bind-context');

var call = Function.call;

module.exports = function (CONSTRUCTOR, METHOD, length) {
  return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);
};

},{"../internals/function-bind-context":135,"../internals/global":138}],132:[function(require,module,exports){
// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];

},{}],133:[function(require,module,exports){
var global = require('../internals/global');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var redefine = require('../internals/redefine');
var setGlobal = require('../internals/set-global');
var copyConstructorProperties = require('../internals/copy-constructor-properties');
var isForced = require('../internals/is-forced');

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};

},{"../internals/copy-constructor-properties":114,"../internals/create-non-enumerable-property":118,"../internals/global":138,"../internals/is-forced":149,"../internals/object-get-own-property-descriptor":167,"../internals/redefine":181,"../internals/set-global":183}],134:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

},{}],135:[function(require,module,exports){
var aFunction = require('../internals/a-function');

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"../internals/a-function":100}],136:[function(require,module,exports){
var path = require('../internals/path');
var global = require('../internals/global');

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};

},{"../internals/global":138,"../internals/path":177}],137:[function(require,module,exports){
var classof = require('../internals/classof');
var Iterators = require('../internals/iterators');
var wellKnownSymbol = require('../internals/well-known-symbol');

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"../internals/classof":113,"../internals/iterators":156,"../internals/well-known-symbol":202}],138:[function(require,module,exports){
(function (global){(function (){
var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func
  (function () { return this; })() || Function('return this')();

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],139:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],140:[function(require,module,exports){
module.exports = {};

},{}],141:[function(require,module,exports){
var global = require('../internals/global');

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};

},{"../internals/global":138}],142:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');

module.exports = getBuiltIn('document', 'documentElement');

},{"../internals/get-built-in":136}],143:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var createElement = require('../internals/document-create-element');

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});

},{"../internals/descriptors":123,"../internals/document-create-element":124,"../internals/fails":134}],144:[function(require,module,exports){
var fails = require('../internals/fails');
var classof = require('../internals/classof-raw');

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

},{"../internals/classof-raw":112,"../internals/fails":134}],145:[function(require,module,exports){
var store = require('../internals/shared-store');

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;

},{"../internals/shared-store":187}],146:[function(require,module,exports){
var NATIVE_WEAK_MAP = require('../internals/native-weak-map');
var global = require('../internals/global');
var isObject = require('../internals/is-object');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var objectHas = require('../internals/has');
var shared = require('../internals/shared-store');
var sharedKey = require('../internals/shared-key');
var hiddenKeys = require('../internals/hidden-keys');

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

},{"../internals/create-non-enumerable-property":118,"../internals/global":138,"../internals/has":139,"../internals/hidden-keys":140,"../internals/is-object":150,"../internals/native-weak-map":160,"../internals/shared-key":186,"../internals/shared-store":187}],147:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');
var Iterators = require('../internals/iterators');

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

},{"../internals/iterators":156,"../internals/well-known-symbol":202}],148:[function(require,module,exports){
var classof = require('../internals/classof-raw');

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};

},{"../internals/classof-raw":112}],149:[function(require,module,exports){
var fails = require('../internals/fails');

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;

},{"../internals/fails":134}],150:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],151:[function(require,module,exports){
module.exports = false;

},{}],152:[function(require,module,exports){
var isObject = require('../internals/is-object');
var classof = require('../internals/classof-raw');
var wellKnownSymbol = require('../internals/well-known-symbol');

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};

},{"../internals/classof-raw":112,"../internals/is-object":150,"../internals/well-known-symbol":202}],153:[function(require,module,exports){
var anObject = require('../internals/an-object');
var isArrayIteratorMethod = require('../internals/is-array-iterator-method');
var toLength = require('../internals/to-length');
var bind = require('../internals/function-bind-context');
var getIteratorMethod = require('../internals/get-iterator-method');
var iteratorClose = require('../internals/iterator-close');

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator);
      throw error;
    }
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};

},{"../internals/an-object":104,"../internals/function-bind-context":135,"../internals/get-iterator-method":137,"../internals/is-array-iterator-method":147,"../internals/iterator-close":154,"../internals/to-length":195}],154:[function(require,module,exports){
var anObject = require('../internals/an-object');

module.exports = function (iterator) {
  var returnMethod = iterator['return'];
  if (returnMethod !== undefined) {
    return anObject(returnMethod.call(iterator)).value;
  }
};

},{"../internals/an-object":104}],155:[function(require,module,exports){
'use strict';
var fails = require('../internals/fails');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var has = require('../internals/has');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_PURE = require('../internals/is-pure');

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

},{"../internals/create-non-enumerable-property":118,"../internals/fails":134,"../internals/has":139,"../internals/is-pure":151,"../internals/object-get-prototype-of":170,"../internals/well-known-symbol":202}],156:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"dup":140}],157:[function(require,module,exports){
var global = require('../internals/global');
var getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;
var macrotask = require('../internals/task').set;
var IS_IOS = require('../internals/engine-is-ios');
var IS_WEBOS_WEBKIT = require('../internals/engine-is-webos-webkit');
var IS_NODE = require('../internals/engine-is-node');

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise;
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    then = promise.then;
    notify = function () {
      then.call(promise, flush);
    };
  // Node.js without promises
  } else if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};

},{"../internals/engine-is-ios":126,"../internals/engine-is-node":127,"../internals/engine-is-webos-webkit":128,"../internals/global":138,"../internals/object-get-own-property-descriptor":167,"../internals/task":191}],158:[function(require,module,exports){
var global = require('../internals/global');

module.exports = global.Promise;

},{"../internals/global":138}],159:[function(require,module,exports){
var fails = require('../internals/fails');

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});

},{"../internals/fails":134}],160:[function(require,module,exports){
var global = require('../internals/global');
var inspectSource = require('../internals/inspect-source');

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

},{"../internals/global":138,"../internals/inspect-source":145}],161:[function(require,module,exports){
'use strict';
var aFunction = require('../internals/a-function');

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"../internals/a-function":100}],162:[function(require,module,exports){
var isRegExp = require('../internals/is-regexp');

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};

},{"../internals/is-regexp":152}],163:[function(require,module,exports){
'use strict';
var DESCRIPTORS = require('../internals/descriptors');
var fails = require('../internals/fails');
var objectKeys = require('../internals/object-keys');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var toObject = require('../internals/to-object');
var IndexedObject = require('../internals/indexed-object');

var nativeAssign = Object.assign;
var defineProperty = Object.defineProperty;

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
module.exports = !nativeAssign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  } return T;
} : nativeAssign;

},{"../internals/descriptors":123,"../internals/fails":134,"../internals/indexed-object":144,"../internals/object-get-own-property-symbols":169,"../internals/object-keys":172,"../internals/object-property-is-enumerable":173,"../internals/to-object":196}],164:[function(require,module,exports){
var anObject = require('../internals/an-object');
var defineProperties = require('../internals/object-define-properties');
var enumBugKeys = require('../internals/enum-bug-keys');
var hiddenKeys = require('../internals/hidden-keys');
var html = require('../internals/html');
var documentCreateElement = require('../internals/document-create-element');
var sharedKey = require('../internals/shared-key');

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};

},{"../internals/an-object":104,"../internals/document-create-element":124,"../internals/enum-bug-keys":132,"../internals/hidden-keys":140,"../internals/html":142,"../internals/object-define-properties":165,"../internals/shared-key":186}],165:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var definePropertyModule = require('../internals/object-define-property');
var anObject = require('../internals/an-object');
var objectKeys = require('../internals/object-keys');

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};

},{"../internals/an-object":104,"../internals/descriptors":123,"../internals/object-define-property":166,"../internals/object-keys":172}],166:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');
var anObject = require('../internals/an-object');
var toPrimitive = require('../internals/to-primitive');

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"../internals/an-object":104,"../internals/descriptors":123,"../internals/ie8-dom-define":143,"../internals/to-primitive":197}],167:[function(require,module,exports){
var DESCRIPTORS = require('../internals/descriptors');
var propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var toIndexedObject = require('../internals/to-indexed-object');
var toPrimitive = require('../internals/to-primitive');
var has = require('../internals/has');
var IE8_DOM_DEFINE = require('../internals/ie8-dom-define');

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};

},{"../internals/create-property-descriptor":119,"../internals/descriptors":123,"../internals/has":139,"../internals/ie8-dom-define":143,"../internals/object-property-is-enumerable":173,"../internals/to-indexed-object":193,"../internals/to-primitive":197}],168:[function(require,module,exports){
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};

},{"../internals/enum-bug-keys":132,"../internals/object-keys-internal":171}],169:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],170:[function(require,module,exports){
var has = require('../internals/has');
var toObject = require('../internals/to-object');
var sharedKey = require('../internals/shared-key');
var CORRECT_PROTOTYPE_GETTER = require('../internals/correct-prototype-getter');

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};

},{"../internals/correct-prototype-getter":116,"../internals/has":139,"../internals/shared-key":186,"../internals/to-object":196}],171:[function(require,module,exports){
var has = require('../internals/has');
var toIndexedObject = require('../internals/to-indexed-object');
var indexOf = require('../internals/array-includes').indexOf;
var hiddenKeys = require('../internals/hidden-keys');

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};

},{"../internals/array-includes":106,"../internals/has":139,"../internals/hidden-keys":140,"../internals/to-indexed-object":193}],172:[function(require,module,exports){
var internalObjectKeys = require('../internals/object-keys-internal');
var enumBugKeys = require('../internals/enum-bug-keys');

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};

},{"../internals/enum-bug-keys":132,"../internals/object-keys-internal":171}],173:[function(require,module,exports){
'use strict';
var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

},{}],174:[function(require,module,exports){
var anObject = require('../internals/an-object');
var aPossiblePrototype = require('../internals/a-possible-prototype');

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);

},{"../internals/a-possible-prototype":101,"../internals/an-object":104}],175:[function(require,module,exports){
'use strict';
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var classof = require('../internals/classof');

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};

},{"../internals/classof":113,"../internals/to-string-tag-support":198}],176:[function(require,module,exports){
var getBuiltIn = require('../internals/get-built-in');
var getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');
var getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');
var anObject = require('../internals/an-object');

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

},{"../internals/an-object":104,"../internals/get-built-in":136,"../internals/object-get-own-property-names":168,"../internals/object-get-own-property-symbols":169}],177:[function(require,module,exports){
var global = require('../internals/global');

module.exports = global;

},{"../internals/global":138}],178:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};

},{}],179:[function(require,module,exports){
var anObject = require('../internals/an-object');
var isObject = require('../internals/is-object');
var newPromiseCapability = require('../internals/new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"../internals/an-object":104,"../internals/is-object":150,"../internals/new-promise-capability":161}],180:[function(require,module,exports){
var redefine = require('../internals/redefine');

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};

},{"../internals/redefine":181}],181:[function(require,module,exports){
var global = require('../internals/global');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var has = require('../internals/has');
var setGlobal = require('../internals/set-global');
var inspectSource = require('../internals/inspect-source');
var InternalStateModule = require('../internals/internal-state');

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});

},{"../internals/create-non-enumerable-property":118,"../internals/global":138,"../internals/has":139,"../internals/inspect-source":145,"../internals/internal-state":146,"../internals/set-global":183}],182:[function(require,module,exports){
// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

},{}],183:[function(require,module,exports){
var global = require('../internals/global');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};

},{"../internals/create-non-enumerable-property":118,"../internals/global":138}],184:[function(require,module,exports){
'use strict';
var getBuiltIn = require('../internals/get-built-in');
var definePropertyModule = require('../internals/object-define-property');
var wellKnownSymbol = require('../internals/well-known-symbol');
var DESCRIPTORS = require('../internals/descriptors');

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};

},{"../internals/descriptors":123,"../internals/get-built-in":136,"../internals/object-define-property":166,"../internals/well-known-symbol":202}],185:[function(require,module,exports){
var defineProperty = require('../internals/object-define-property').f;
var has = require('../internals/has');
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};

},{"../internals/has":139,"../internals/object-define-property":166,"../internals/well-known-symbol":202}],186:[function(require,module,exports){
var shared = require('../internals/shared');
var uid = require('../internals/uid');

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

},{"../internals/shared":188,"../internals/uid":199}],187:[function(require,module,exports){
var global = require('../internals/global');
var setGlobal = require('../internals/set-global');

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;

},{"../internals/global":138,"../internals/set-global":183}],188:[function(require,module,exports){
var IS_PURE = require('../internals/is-pure');
var store = require('../internals/shared-store');

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.8.3',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
});

},{"../internals/is-pure":151,"../internals/shared-store":187}],189:[function(require,module,exports){
var anObject = require('../internals/an-object');
var aFunction = require('../internals/a-function');
var wellKnownSymbol = require('../internals/well-known-symbol');

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};

},{"../internals/a-function":100,"../internals/an-object":104,"../internals/well-known-symbol":202}],190:[function(require,module,exports){
var toInteger = require('../internals/to-integer');
var requireObjectCoercible = require('../internals/require-object-coercible');

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};

},{"../internals/require-object-coercible":182,"../internals/to-integer":194}],191:[function(require,module,exports){
var global = require('../internals/global');
var fails = require('../internals/fails');
var bind = require('../internals/function-bind-context');
var html = require('../internals/html');
var createElement = require('../internals/document-create-element');
var IS_IOS = require('../internals/engine-is-ios');
var IS_NODE = require('../internals/engine-is-node');

var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (IS_NODE) {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    typeof postMessage == 'function' &&
    !global.importScripts &&
    location && location.protocol !== 'file:' &&
    !fails(post)
  ) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};

},{"../internals/document-create-element":124,"../internals/engine-is-ios":126,"../internals/engine-is-node":127,"../internals/fails":134,"../internals/function-bind-context":135,"../internals/global":138,"../internals/html":142}],192:[function(require,module,exports){
var toInteger = require('../internals/to-integer');

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

},{"../internals/to-integer":194}],193:[function(require,module,exports){
// toObject with fallback for non-array-like ES3 strings
var IndexedObject = require('../internals/indexed-object');
var requireObjectCoercible = require('../internals/require-object-coercible');

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};

},{"../internals/indexed-object":144,"../internals/require-object-coercible":182}],194:[function(require,module,exports){
var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

},{}],195:[function(require,module,exports){
var toInteger = require('../internals/to-integer');

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

},{"../internals/to-integer":194}],196:[function(require,module,exports){
var requireObjectCoercible = require('../internals/require-object-coercible');

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};

},{"../internals/require-object-coercible":182}],197:[function(require,module,exports){
var isObject = require('../internals/is-object');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"../internals/is-object":150}],198:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';

},{"../internals/well-known-symbol":202}],199:[function(require,module,exports){
var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

},{}],200:[function(require,module,exports){
var NATIVE_SYMBOL = require('../internals/native-symbol');

module.exports = NATIVE_SYMBOL
  // eslint-disable-next-line no-undef
  && !Symbol.sham
  // eslint-disable-next-line no-undef
  && typeof Symbol.iterator == 'symbol';

},{"../internals/native-symbol":159}],201:[function(require,module,exports){
var wellKnownSymbol = require('../internals/well-known-symbol');

exports.f = wellKnownSymbol;

},{"../internals/well-known-symbol":202}],202:[function(require,module,exports){
var global = require('../internals/global');
var shared = require('../internals/shared');
var has = require('../internals/has');
var uid = require('../internals/uid');
var NATIVE_SYMBOL = require('../internals/native-symbol');
var USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};

},{"../internals/global":138,"../internals/has":139,"../internals/native-symbol":159,"../internals/shared":188,"../internals/uid":199,"../internals/use-symbol-as-uid":200}],203:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var getPrototypeOf = require('../internals/object-get-prototype-of');
var setPrototypeOf = require('../internals/object-set-prototype-of');
var create = require('../internals/object-create');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var createPropertyDescriptor = require('../internals/create-property-descriptor');
var iterate = require('../internals/iterate');

var $AggregateError = function AggregateError(errors, message) {
  var that = this;
  if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message);
  if (setPrototypeOf) {
    // eslint-disable-next-line unicorn/error-message
    that = setPrototypeOf(new Error(undefined), getPrototypeOf(that));
  }
  if (message !== undefined) createNonEnumerableProperty(that, 'message', String(message));
  var errorsArray = [];
  iterate(errors, errorsArray.push, { that: errorsArray });
  createNonEnumerableProperty(that, 'errors', errorsArray);
  return that;
};

$AggregateError.prototype = create(Error.prototype, {
  constructor: createPropertyDescriptor(5, $AggregateError),
  message: createPropertyDescriptor(5, ''),
  name: createPropertyDescriptor(5, 'AggregateError')
});

// `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor
$({ global: true }, {
  AggregateError: $AggregateError
});

},{"../internals/create-non-enumerable-property":118,"../internals/create-property-descriptor":119,"../internals/export":133,"../internals/iterate":153,"../internals/object-create":164,"../internals/object-get-prototype-of":170,"../internals/object-set-prototype-of":174}],204:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $find = require('../internals/array-iteration').find;
var addToUnscopables = require('../internals/add-to-unscopables');
var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');

var FIND = 'find';
var SKIPS_HOLES = true;

var USES_TO_LENGTH = arrayMethodUsesToLength(FIND);

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);

},{"../internals/add-to-unscopables":102,"../internals/array-iteration":107,"../internals/array-method-uses-to-length":108,"../internals/export":133}],205:[function(require,module,exports){
var $ = require('../internals/export');
var from = require('../internals/array-from');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});

},{"../internals/array-from":105,"../internals/check-correctness-of-iteration":111,"../internals/export":133}],206:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var $includes = require('../internals/array-includes').includes;
var addToUnscopables = require('../internals/add-to-unscopables');
var arrayMethodUsesToLength = require('../internals/array-method-uses-to-length');

var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: !USES_TO_LENGTH }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');

},{"../internals/add-to-unscopables":102,"../internals/array-includes":106,"../internals/array-method-uses-to-length":108,"../internals/export":133}],207:[function(require,module,exports){
'use strict';
var toIndexedObject = require('../internals/to-indexed-object');
var addToUnscopables = require('../internals/add-to-unscopables');
var Iterators = require('../internals/iterators');
var InternalStateModule = require('../internals/internal-state');
var defineIterator = require('../internals/define-iterator');

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"../internals/add-to-unscopables":102,"../internals/define-iterator":121,"../internals/internal-state":146,"../internals/iterators":156,"../internals/to-indexed-object":193}],208:[function(require,module,exports){
var $ = require('../internals/export');
var assign = require('../internals/object-assign');

// `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign
$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {
  assign: assign
});

},{"../internals/export":133,"../internals/object-assign":163}],209:[function(require,module,exports){
var TO_STRING_TAG_SUPPORT = require('../internals/to-string-tag-support');
var redefine = require('../internals/redefine');
var toString = require('../internals/object-to-string');

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}

},{"../internals/object-to-string":175,"../internals/redefine":181,"../internals/to-string-tag-support":198}],210:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');

// `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled
$({ target: 'Promise', stat: true }, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'fulfilled', value: value };
          --remaining || resolve(values);
        }, function (error) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = { status: 'rejected', reason: error };
          --remaining || resolve(values);
        });
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

},{"../internals/a-function":100,"../internals/export":133,"../internals/iterate":153,"../internals/new-promise-capability":161,"../internals/perform":178}],211:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var aFunction = require('../internals/a-function');
var getBuiltIn = require('../internals/get-built-in');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var iterate = require('../internals/iterate');

var PROMISE_ANY_ERROR = 'No one promise resolved';

// `Promise.any` method
// https://tc39.es/ecma262/#sec-promise.any
$({ target: 'Promise', stat: true }, {
  any: function any(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aFunction(C.resolve);
      var errors = [];
      var counter = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyRejected = false;
        errors.push(undefined);
        remaining++;
        promiseResolve.call(C, promise).then(function (value) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyResolved = true;
          resolve(value);
        }, function (error) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyRejected = true;
          errors[index] = error;
          --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

},{"../internals/a-function":100,"../internals/export":133,"../internals/get-built-in":136,"../internals/iterate":153,"../internals/new-promise-capability":161,"../internals/perform":178}],212:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var NativePromise = require('../internals/native-promise-constructor');
var fails = require('../internals/fails');
var getBuiltIn = require('../internals/get-built-in');
var speciesConstructor = require('../internals/species-constructor');
var promiseResolve = require('../internals/promise-resolve');
var redefine = require('../internals/redefine');

// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
var NON_GENERIC = !!NativePromise && fails(function () {
  NativePromise.prototype['finally'].call({ then: function () { /* empty */ } }, function () { /* empty */ });
});

// `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally
$({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = typeof onFinally == 'function';
    return this.then(
      isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () { return x; });
      } : onFinally,
      isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () { throw e; });
      } : onFinally
    );
  }
});

// patch native Promise.prototype for native async functions
if (!IS_PURE && typeof NativePromise == 'function' && !NativePromise.prototype['finally']) {
  redefine(NativePromise.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
}

},{"../internals/export":133,"../internals/fails":134,"../internals/get-built-in":136,"../internals/is-pure":151,"../internals/native-promise-constructor":158,"../internals/promise-resolve":179,"../internals/redefine":181,"../internals/species-constructor":189}],213:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var IS_PURE = require('../internals/is-pure');
var global = require('../internals/global');
var getBuiltIn = require('../internals/get-built-in');
var NativePromise = require('../internals/native-promise-constructor');
var redefine = require('../internals/redefine');
var redefineAll = require('../internals/redefine-all');
var setToStringTag = require('../internals/set-to-string-tag');
var setSpecies = require('../internals/set-species');
var isObject = require('../internals/is-object');
var aFunction = require('../internals/a-function');
var anInstance = require('../internals/an-instance');
var inspectSource = require('../internals/inspect-source');
var iterate = require('../internals/iterate');
var checkCorrectnessOfIteration = require('../internals/check-correctness-of-iteration');
var speciesConstructor = require('../internals/species-constructor');
var task = require('../internals/task').set;
var microtask = require('../internals/microtask');
var promiseResolve = require('../internals/promise-resolve');
var hostReportErrors = require('../internals/host-report-errors');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');
var InternalStateModule = require('../internals/internal-state');
var isForced = require('../internals/is-forced');
var wellKnownSymbol = require('../internals/well-known-symbol');
var IS_NODE = require('../internals/engine-is-node');
var V8_VERSION = require('../internals/engine-v8-version');

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (V8_VERSION === 66) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    if (!IS_NODE && !NATIVE_REJECTION_EVENT) return true;
  }
  // We need Promise#finally in the pure version for preventing prototype pollution
  if (IS_PURE && !PromiseConstructor.prototype['finally']) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (state) {
  task.call(global, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (state) {
  task.call(global, function () {
    var promise = state.facade;
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function (state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (state.facade === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, wrapper, state),
            bind(internalReject, wrapper, state)
          );
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({ done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.es/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.es/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && typeof NativePromise == 'function') {
    nativeThen = NativePromise.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
    // https://github.com/zloirock/core-js/issues/640
    }, { unsafe: true });

    // wrap fetch result
    if (typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, {
      // eslint-disable-next-line no-unused-vars
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
      }
    });
  }
}

$({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.es/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.es/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.es/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.es/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

},{"../internals/a-function":100,"../internals/an-instance":103,"../internals/check-correctness-of-iteration":111,"../internals/engine-is-node":127,"../internals/engine-v8-version":130,"../internals/export":133,"../internals/get-built-in":136,"../internals/global":138,"../internals/host-report-errors":141,"../internals/inspect-source":145,"../internals/internal-state":146,"../internals/is-forced":149,"../internals/is-object":150,"../internals/is-pure":151,"../internals/iterate":153,"../internals/microtask":157,"../internals/native-promise-constructor":158,"../internals/new-promise-capability":161,"../internals/perform":178,"../internals/promise-resolve":179,"../internals/redefine":181,"../internals/redefine-all":180,"../internals/set-species":184,"../internals/set-to-string-tag":185,"../internals/species-constructor":189,"../internals/task":191,"../internals/well-known-symbol":202}],214:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var notARegExp = require('../internals/not-a-regexp');
var requireObjectCoercible = require('../internals/require-object-coercible');
var correctIsRegExpLogic = require('../internals/correct-is-regexp-logic');

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~String(requireObjectCoercible(this))
      .indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"../internals/correct-is-regexp-logic":115,"../internals/export":133,"../internals/not-a-regexp":162,"../internals/require-object-coercible":182}],215:[function(require,module,exports){
'use strict';
var charAt = require('../internals/string-multibyte').charAt;
var InternalStateModule = require('../internals/internal-state');
var defineIterator = require('../internals/define-iterator');

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});

},{"../internals/define-iterator":121,"../internals/internal-state":146,"../internals/string-multibyte":190}],216:[function(require,module,exports){
var defineWellKnownSymbol = require('../internals/define-well-known-symbol');

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');

},{"../internals/define-well-known-symbol":122}],217:[function(require,module,exports){
// TODO: Remove from `core-js@4`
require('./es.aggregate-error');

},{"./es.aggregate-error":203}],218:[function(require,module,exports){
// TODO: Remove from `core-js@4`
require('./es.promise.all-settled.js');

},{"./es.promise.all-settled.js":210}],219:[function(require,module,exports){
// TODO: Remove from `core-js@4`
require('./es.promise.any');

},{"./es.promise.any":211}],220:[function(require,module,exports){
'use strict';
var $ = require('../internals/export');
var newPromiseCapabilityModule = require('../internals/new-promise-capability');
var perform = require('../internals/perform');

// `Promise.try` method
// https://github.com/tc39/proposal-promise-try
$({ target: 'Promise', stat: true }, {
  'try': function (callbackfn) {
    var promiseCapability = newPromiseCapabilityModule.f(this);
    var result = perform(callbackfn);
    (result.error ? promiseCapability.reject : promiseCapability.resolve)(result.value);
    return promiseCapability.promise;
  }
});

},{"../internals/export":133,"../internals/new-promise-capability":161,"../internals/perform":178}],221:[function(require,module,exports){
var global = require('../internals/global');
var DOMIterables = require('../internals/dom-iterables');
var ArrayIteratorMethods = require('../modules/es.array.iterator');
var createNonEnumerableProperty = require('../internals/create-non-enumerable-property');
var wellKnownSymbol = require('../internals/well-known-symbol');

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}

},{"../internals/create-non-enumerable-property":118,"../internals/dom-iterables":125,"../internals/global":138,"../internals/well-known-symbol":202,"../modules/es.array.iterator":207}],222:[function(require,module,exports){
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.
 *
 *  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document
 *
 */
(function() {
'use strict';

// Exit early if we're not running in a browser.
if (typeof window !== 'object') {
  return;
}

// Exit early if all IntersectionObserver and IntersectionObserverEntry
// features are natively supported.
if ('IntersectionObserver' in window &&
    'IntersectionObserverEntry' in window &&
    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

  // Minimal polyfill for Edge 15's lack of `isIntersecting`
  // See: https://github.com/w3c/IntersectionObserver/issues/211
  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
    Object.defineProperty(window.IntersectionObserverEntry.prototype,
      'isIntersecting', {
      get: function () {
        return this.intersectionRatio > 0;
      }
    });
  }
  return;
}

/**
 * Returns the embedding frame element, if any.
 * @param {!Document} doc
 * @return {!Element}
 */
function getFrameElement(doc) {
  try {
    return doc.defaultView && doc.defaultView.frameElement || null;
  } catch (e) {
    // Ignore the error.
    return null;
  }
}

/**
 * A local reference to the root document.
 */
var document = (function(startDoc) {
  var doc = startDoc;
  var frame = getFrameElement(doc);
  while (frame) {
    doc = frame.ownerDocument;
    frame = getFrameElement(doc);
  }
  return doc;
})(window.document);

/**
 * An IntersectionObserver registry. This registry exists to hold a strong
 * reference to IntersectionObserver instances currently observing a target
 * element. Without this registry, instances without another reference may be
 * garbage collected.
 */
var registry = [];

/**
 * The signal updater for cross-origin intersection. When not null, it means
 * that the polyfill is configured to work in a cross-origin mode.
 * @type {function(DOMRect|ClientRect, DOMRect|ClientRect)}
 */
var crossOriginUpdater = null;

/**
 * The current cross-origin intersection. Only used in the cross-origin mode.
 * @type {DOMRect|ClientRect}
 */
var crossOriginRect = null;


/**
 * Creates the global IntersectionObserverEntry constructor.
 * https://w3c.github.io/IntersectionObserver/#intersection-observer-entry
 * @param {Object} entry A dictionary of instance properties.
 * @constructor
 */
function IntersectionObserverEntry(entry) {
  this.time = entry.time;
  this.target = entry.target;
  this.rootBounds = ensureDOMRect(entry.rootBounds);
  this.boundingClientRect = ensureDOMRect(entry.boundingClientRect);
  this.intersectionRect = ensureDOMRect(entry.intersectionRect || getEmptyRect());
  this.isIntersecting = !!entry.intersectionRect;

  // Calculates the intersection ratio.
  var targetRect = this.boundingClientRect;
  var targetArea = targetRect.width * targetRect.height;
  var intersectionRect = this.intersectionRect;
  var intersectionArea = intersectionRect.width * intersectionRect.height;

  // Sets intersection ratio.
  if (targetArea) {
    // Round the intersection ratio to avoid floating point math issues:
    // https://github.com/w3c/IntersectionObserver/issues/324
    this.intersectionRatio = Number((intersectionArea / targetArea).toFixed(4));
  } else {
    // If area is zero and is intersecting, sets to 1, otherwise to 0
    this.intersectionRatio = this.isIntersecting ? 1 : 0;
  }
}


/**
 * Creates the global IntersectionObserver constructor.
 * https://w3c.github.io/IntersectionObserver/#intersection-observer-interface
 * @param {Function} callback The function to be invoked after intersection
 *     changes have queued. The function is not invoked if the queue has
 *     been emptied by calling the `takeRecords` method.
 * @param {Object=} opt_options Optional configuration options.
 * @constructor
 */
function IntersectionObserver(callback, opt_options) {

  var options = opt_options || {};

  if (typeof callback != 'function') {
    throw new Error('callback must be a function');
  }

  if (options.root && options.root.nodeType != 1) {
    throw new Error('root must be an Element');
  }

  // Binds and throttles `this._checkForIntersections`.
  this._checkForIntersections = throttle(
      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

  // Private properties.
  this._callback = callback;
  this._observationTargets = [];
  this._queuedEntries = [];
  this._rootMarginValues = this._parseRootMargin(options.rootMargin);

  // Public properties.
  this.thresholds = this._initThresholds(options.threshold);
  this.root = options.root || null;
  this.rootMargin = this._rootMarginValues.map(function(margin) {
    return margin.value + margin.unit;
  }).join(' ');

  /** @private @const {!Array<!Document>} */
  this._monitoringDocuments = [];
  /** @private @const {!Array<function()>} */
  this._monitoringUnsubscribes = [];
}


/**
 * The minimum interval within which the document will be checked for
 * intersection changes.
 */
IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


/**
 * The frequency in which the polyfill polls for intersection changes.
 * this can be updated on a per instance basis and must be set prior to
 * calling `observe` on the first target.
 */
IntersectionObserver.prototype.POLL_INTERVAL = null;

/**
 * Use a mutation observer on the root element
 * to detect intersection changes.
 */
IntersectionObserver.prototype.USE_MUTATION_OBSERVER = true;


/**
 * Sets up the polyfill in the cross-origin mode. The result is the
 * updater function that accepts two arguments: `boundingClientRect` and
 * `intersectionRect` - just as these fields would be available to the
 * parent via `IntersectionObserverEntry`. This function should be called
 * each time the iframe receives intersection information from the parent
 * window, e.g. via messaging.
 * @return {function(DOMRect|ClientRect, DOMRect|ClientRect)}
 */
IntersectionObserver._setupCrossOriginUpdater = function() {
  if (!crossOriginUpdater) {
    /**
     * @param {DOMRect|ClientRect} boundingClientRect
     * @param {DOMRect|ClientRect} intersectionRect
     */
    crossOriginUpdater = function(boundingClientRect, intersectionRect) {
      if (!boundingClientRect || !intersectionRect) {
        crossOriginRect = getEmptyRect();
      } else {
        crossOriginRect = convertFromParentRect(boundingClientRect, intersectionRect);
      }
      registry.forEach(function(observer) {
        observer._checkForIntersections();
      });
    };
  }
  return crossOriginUpdater;
};


/**
 * Resets the cross-origin mode.
 */
IntersectionObserver._resetCrossOriginUpdater = function() {
  crossOriginUpdater = null;
  crossOriginRect = null;
};


/**
 * Starts observing a target element for intersection changes based on
 * the thresholds values.
 * @param {Element} target The DOM element to observe.
 */
IntersectionObserver.prototype.observe = function(target) {
  var isTargetAlreadyObserved = this._observationTargets.some(function(item) {
    return item.element == target;
  });

  if (isTargetAlreadyObserved) {
    return;
  }

  if (!(target && target.nodeType == 1)) {
    throw new Error('target must be an Element');
  }

  this._registerInstance();
  this._observationTargets.push({element: target, entry: null});
  this._monitorIntersections(target.ownerDocument);
  this._checkForIntersections();
};


/**
 * Stops observing a target element for intersection changes.
 * @param {Element} target The DOM element to observe.
 */
IntersectionObserver.prototype.unobserve = function(target) {
  this._observationTargets =
      this._observationTargets.filter(function(item) {
        return item.element != target;
      });
  this._unmonitorIntersections(target.ownerDocument);
  if (this._observationTargets.length == 0) {
    this._unregisterInstance();
  }
};


/**
 * Stops observing all target elements for intersection changes.
 */
IntersectionObserver.prototype.disconnect = function() {
  this._observationTargets = [];
  this._unmonitorAllIntersections();
  this._unregisterInstance();
};


/**
 * Returns any queue entries that have not yet been reported to the
 * callback and clears the queue. This can be used in conjunction with the
 * callback to obtain the absolute most up-to-date intersection information.
 * @return {Array} The currently queued entries.
 */
IntersectionObserver.prototype.takeRecords = function() {
  var records = this._queuedEntries.slice();
  this._queuedEntries = [];
  return records;
};


/**
 * Accepts the threshold value from the user configuration object and
 * returns a sorted array of unique threshold values. If a value is not
 * between 0 and 1 and error is thrown.
 * @private
 * @param {Array|number=} opt_threshold An optional threshold value or
 *     a list of threshold values, defaulting to [0].
 * @return {Array} A sorted list of unique and valid threshold values.
 */
IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
  var threshold = opt_threshold || [0];
  if (!Array.isArray(threshold)) threshold = [threshold];

  return threshold.sort().filter(function(t, i, a) {
    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
      throw new Error('threshold must be a number between 0 and 1 inclusively');
    }
    return t !== a[i - 1];
  });
};


/**
 * Accepts the rootMargin value from the user configuration object
 * and returns an array of the four margin values as an object containing
 * the value and unit properties. If any of the values are not properly
 * formatted or use a unit other than px or %, and error is thrown.
 * @private
 * @param {string=} opt_rootMargin An optional rootMargin value,
 *     defaulting to '0px'.
 * @return {Array<Object>} An array of margin objects with the keys
 *     value and unit.
 */
IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
  var marginString = opt_rootMargin || '0px';
  var margins = marginString.split(/\s+/).map(function(margin) {
    var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
    if (!parts) {
      throw new Error('rootMargin must be specified in pixels or percent');
    }
    return {value: parseFloat(parts[1]), unit: parts[2]};
  });

  // Handles shorthand.
  margins[1] = margins[1] || margins[0];
  margins[2] = margins[2] || margins[0];
  margins[3] = margins[3] || margins[1];

  return margins;
};


/**
 * Starts polling for intersection changes if the polling is not already
 * happening, and if the page's visibility state is visible.
 * @param {!Document} doc
 * @private
 */
IntersectionObserver.prototype._monitorIntersections = function(doc) {
  var win = doc.defaultView;
  if (!win) {
    // Already destroyed.
    return;
  }
  if (this._monitoringDocuments.indexOf(doc) != -1) {
    // Already monitoring.
    return;
  }

  // Private state for monitoring.
  var callback = this._checkForIntersections;
  var monitoringInterval = null;
  var domObserver = null;

  // If a poll interval is set, use polling instead of listening to
  // resize and scroll events or DOM mutations.
  if (this.POLL_INTERVAL) {
    monitoringInterval = win.setInterval(callback, this.POLL_INTERVAL);
  } else {
    addEvent(win, 'resize', callback, true);
    addEvent(doc, 'scroll', callback, true);
    if (this.USE_MUTATION_OBSERVER && 'MutationObserver' in win) {
      domObserver = new win.MutationObserver(callback);
      domObserver.observe(doc, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    }
  }

  this._monitoringDocuments.push(doc);
  this._monitoringUnsubscribes.push(function() {
    // Get the window object again. When a friendly iframe is destroyed, it
    // will be null.
    var win = doc.defaultView;

    if (win) {
      if (monitoringInterval) {
        win.clearInterval(monitoringInterval);
      }
      removeEvent(win, 'resize', callback, true);
    }

    removeEvent(doc, 'scroll', callback, true);
    if (domObserver) {
      domObserver.disconnect();
    }
  });

  // Also monitor the parent.
  if (doc != (this.root && this.root.ownerDocument || document)) {
    var frame = getFrameElement(doc);
    if (frame) {
      this._monitorIntersections(frame.ownerDocument);
    }
  }
};


/**
 * Stops polling for intersection changes.
 * @param {!Document} doc
 * @private
 */
IntersectionObserver.prototype._unmonitorIntersections = function(doc) {
  var index = this._monitoringDocuments.indexOf(doc);
  if (index == -1) {
    return;
  }

  var rootDoc = (this.root && this.root.ownerDocument || document);

  // Check if any dependent targets are still remaining.
  var hasDependentTargets =
      this._observationTargets.some(function(item) {
        var itemDoc = item.element.ownerDocument;
        // Target is in this context.
        if (itemDoc == doc) {
          return true;
        }
        // Target is nested in this context.
        while (itemDoc && itemDoc != rootDoc) {
          var frame = getFrameElement(itemDoc);
          itemDoc = frame && frame.ownerDocument;
          if (itemDoc == doc) {
            return true;
          }
        }
        return false;
      });
  if (hasDependentTargets) {
    return;
  }

  // Unsubscribe.
  var unsubscribe = this._monitoringUnsubscribes[index];
  this._monitoringDocuments.splice(index, 1);
  this._monitoringUnsubscribes.splice(index, 1);
  unsubscribe();

  // Also unmonitor the parent.
  if (doc != rootDoc) {
    var frame = getFrameElement(doc);
    if (frame) {
      this._unmonitorIntersections(frame.ownerDocument);
    }
  }
};


/**
 * Stops polling for intersection changes.
 * @param {!Document} doc
 * @private
 */
IntersectionObserver.prototype._unmonitorAllIntersections = function() {
  var unsubscribes = this._monitoringUnsubscribes.slice(0);
  this._monitoringDocuments.length = 0;
  this._monitoringUnsubscribes.length = 0;
  for (var i = 0; i < unsubscribes.length; i++) {
    unsubscribes[i]();
  }
};


/**
 * Scans each observation target for intersection changes and adds them
 * to the internal entries queue. If new entries are found, it
 * schedules the callback to be invoked.
 * @private
 */
IntersectionObserver.prototype._checkForIntersections = function() {
  if (!this.root && crossOriginUpdater && !crossOriginRect) {
    // Cross origin monitoring, but no initial data available yet.
    return;
  }

  var rootIsInDom = this._rootIsInDom();
  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

  this._observationTargets.forEach(function(item) {
    var target = item.element;
    var targetRect = getBoundingClientRect(target);
    var rootContainsTarget = this._rootContainsTarget(target);
    var oldEntry = item.entry;
    var intersectionRect = rootIsInDom && rootContainsTarget &&
        this._computeTargetAndRootIntersection(target, targetRect, rootRect);

    var newEntry = item.entry = new IntersectionObserverEntry({
      time: now(),
      target: target,
      boundingClientRect: targetRect,
      rootBounds: crossOriginUpdater && !this.root ? null : rootRect,
      intersectionRect: intersectionRect
    });

    if (!oldEntry) {
      this._queuedEntries.push(newEntry);
    } else if (rootIsInDom && rootContainsTarget) {
      // If the new entry intersection ratio has crossed any of the
      // thresholds, add a new entry.
      if (this._hasCrossedThreshold(oldEntry, newEntry)) {
        this._queuedEntries.push(newEntry);
      }
    } else {
      // If the root is not in the DOM or target is not contained within
      // root but the previous entry for this target had an intersection,
      // add a new record indicating removal.
      if (oldEntry && oldEntry.isIntersecting) {
        this._queuedEntries.push(newEntry);
      }
    }
  }, this);

  if (this._queuedEntries.length) {
    this._callback(this.takeRecords(), this);
  }
};


/**
 * Accepts a target and root rect computes the intersection between then
 * following the algorithm in the spec.
 * TODO(philipwalton): at this time clip-path is not considered.
 * https://w3c.github.io/IntersectionObserver/#calculate-intersection-rect-algo
 * @param {Element} target The target DOM element
 * @param {Object} targetRect The bounding rect of the target.
 * @param {Object} rootRect The bounding rect of the root after being
 *     expanded by the rootMargin value.
 * @return {?Object} The final intersection rect object or undefined if no
 *     intersection is found.
 * @private
 */
IntersectionObserver.prototype._computeTargetAndRootIntersection =
    function(target, targetRect, rootRect) {
  // If the element isn't displayed, an intersection can't happen.
  if (window.getComputedStyle(target).display == 'none') return;

  var intersectionRect = targetRect;
  var parent = getParentNode(target);
  var atRoot = false;

  while (!atRoot && parent) {
    var parentRect = null;
    var parentComputedStyle = parent.nodeType == 1 ?
        window.getComputedStyle(parent) : {};

    // If the parent isn't displayed, an intersection can't happen.
    if (parentComputedStyle.display == 'none') return null;

    if (parent == this.root || parent.nodeType == /* DOCUMENT */ 9) {
      atRoot = true;
      if (parent == this.root || parent == document) {
        if (crossOriginUpdater && !this.root) {
          if (!crossOriginRect ||
              crossOriginRect.width == 0 && crossOriginRect.height == 0) {
            // A 0-size cross-origin intersection means no-intersection.
            parent = null;
            parentRect = null;
            intersectionRect = null;
          } else {
            parentRect = crossOriginRect;
          }
        } else {
          parentRect = rootRect;
        }
      } else {
        // Check if there's a frame that can be navigated to.
        var frame = getParentNode(parent);
        var frameRect = frame && getBoundingClientRect(frame);
        var frameIntersect =
            frame &&
            this._computeTargetAndRootIntersection(frame, frameRect, rootRect);
        if (frameRect && frameIntersect) {
          parent = frame;
          parentRect = convertFromParentRect(frameRect, frameIntersect);
        } else {
          parent = null;
          intersectionRect = null;
        }
      }
    } else {
      // If the element has a non-visible overflow, and it's not the <body>
      // or <html> element, update the intersection rect.
      // Note: <body> and <html> cannot be clipped to a rect that's not also
      // the document rect, so no need to compute a new intersection.
      var doc = parent.ownerDocument;
      if (parent != doc.body &&
          parent != doc.documentElement &&
          parentComputedStyle.overflow != 'visible') {
        parentRect = getBoundingClientRect(parent);
      }
    }

    // If either of the above conditionals set a new parentRect,
    // calculate new intersection data.
    if (parentRect) {
      intersectionRect = computeRectIntersection(parentRect, intersectionRect);
    }
    if (!intersectionRect) break;
    parent = parent && getParentNode(parent);
  }
  return intersectionRect;
};


/**
 * Returns the root rect after being expanded by the rootMargin value.
 * @return {ClientRect} The expanded root rect.
 * @private
 */
IntersectionObserver.prototype._getRootRect = function() {
  var rootRect;
  if (this.root) {
    rootRect = getBoundingClientRect(this.root);
  } else {
    // Use <html>/<body> instead of window since scroll bars affect size.
    var html = document.documentElement;
    var body = document.body;
    rootRect = {
      top: 0,
      left: 0,
      right: html.clientWidth || body.clientWidth,
      width: html.clientWidth || body.clientWidth,
      bottom: html.clientHeight || body.clientHeight,
      height: html.clientHeight || body.clientHeight
    };
  }
  return this._expandRectByRootMargin(rootRect);
};


/**
 * Accepts a rect and expands it by the rootMargin value.
 * @param {DOMRect|ClientRect} rect The rect object to expand.
 * @return {ClientRect} The expanded rect.
 * @private
 */
IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
  var margins = this._rootMarginValues.map(function(margin, i) {
    return margin.unit == 'px' ? margin.value :
        margin.value * (i % 2 ? rect.width : rect.height) / 100;
  });
  var newRect = {
    top: rect.top - margins[0],
    right: rect.right + margins[1],
    bottom: rect.bottom + margins[2],
    left: rect.left - margins[3]
  };
  newRect.width = newRect.right - newRect.left;
  newRect.height = newRect.bottom - newRect.top;

  return newRect;
};


/**
 * Accepts an old and new entry and returns true if at least one of the
 * threshold values has been crossed.
 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
 *    particular target element or null if no previous entry exists.
 * @param {IntersectionObserverEntry} newEntry The current entry for a
 *    particular target element.
 * @return {boolean} Returns true if a any threshold has been crossed.
 * @private
 */
IntersectionObserver.prototype._hasCrossedThreshold =
    function(oldEntry, newEntry) {

  // To make comparing easier, an entry that has a ratio of 0
  // but does not actually intersect is given a value of -1
  var oldRatio = oldEntry && oldEntry.isIntersecting ?
      oldEntry.intersectionRatio || 0 : -1;
  var newRatio = newEntry.isIntersecting ?
      newEntry.intersectionRatio || 0 : -1;

  // Ignore unchanged ratios
  if (oldRatio === newRatio) return;

  for (var i = 0; i < this.thresholds.length; i++) {
    var threshold = this.thresholds[i];

    // Return true if an entry matches a threshold or if the new ratio
    // and the old ratio are on the opposite sides of a threshold.
    if (threshold == oldRatio || threshold == newRatio ||
        threshold < oldRatio !== threshold < newRatio) {
      return true;
    }
  }
};


/**
 * Returns whether or not the root element is an element and is in the DOM.
 * @return {boolean} True if the root element is an element and is in the DOM.
 * @private
 */
IntersectionObserver.prototype._rootIsInDom = function() {
  return !this.root || containsDeep(document, this.root);
};


/**
 * Returns whether or not the target element is a child of root.
 * @param {Element} target The target element to check.
 * @return {boolean} True if the target element is a child of root.
 * @private
 */
IntersectionObserver.prototype._rootContainsTarget = function(target) {
  return containsDeep(this.root || document, target) &&
    (!this.root || this.root.ownerDocument == target.ownerDocument);
};


/**
 * Adds the instance to the global IntersectionObserver registry if it isn't
 * already present.
 * @private
 */
IntersectionObserver.prototype._registerInstance = function() {
  if (registry.indexOf(this) < 0) {
    registry.push(this);
  }
};


/**
 * Removes the instance from the global IntersectionObserver registry.
 * @private
 */
IntersectionObserver.prototype._unregisterInstance = function() {
  var index = registry.indexOf(this);
  if (index != -1) registry.splice(index, 1);
};


/**
 * Returns the result of the performance.now() method or null in browsers
 * that don't support the API.
 * @return {number} The elapsed time since the page was requested.
 */
function now() {
  return window.performance && performance.now && performance.now();
}


/**
 * Throttles a function and delays its execution, so it's only called at most
 * once within a given time period.
 * @param {Function} fn The function to throttle.
 * @param {number} timeout The amount of time that must pass before the
 *     function can be called again.
 * @return {Function} The throttled function.
 */
function throttle(fn, timeout) {
  var timer = null;
  return function () {
    if (!timer) {
      timer = setTimeout(function() {
        fn();
        timer = null;
      }, timeout);
    }
  };
}


/**
 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
 * @param {Node} node The DOM node to add the event handler to.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to add.
 * @param {boolean} opt_useCapture Optionally adds the even to the capture
 *     phase. Note: this only works in modern browsers.
 */
function addEvent(node, event, fn, opt_useCapture) {
  if (typeof node.addEventListener == 'function') {
    node.addEventListener(event, fn, opt_useCapture || false);
  }
  else if (typeof node.attachEvent == 'function') {
    node.attachEvent('on' + event, fn);
  }
}


/**
 * Removes a previously added event handler from a DOM node.
 * @param {Node} node The DOM node to remove the event handler from.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to remove.
 * @param {boolean} opt_useCapture If the event handler was added with this
 *     flag set to true, it should be set to true here in order to remove it.
 */
function removeEvent(node, event, fn, opt_useCapture) {
  if (typeof node.removeEventListener == 'function') {
    node.removeEventListener(event, fn, opt_useCapture || false);
  }
  else if (typeof node.detatchEvent == 'function') {
    node.detatchEvent('on' + event, fn);
  }
}


/**
 * Returns the intersection between two rect objects.
 * @param {Object} rect1 The first rect.
 * @param {Object} rect2 The second rect.
 * @return {?Object|?ClientRect} The intersection rect or undefined if no
 *     intersection is found.
 */
function computeRectIntersection(rect1, rect2) {
  var top = Math.max(rect1.top, rect2.top);
  var bottom = Math.min(rect1.bottom, rect2.bottom);
  var left = Math.max(rect1.left, rect2.left);
  var right = Math.min(rect1.right, rect2.right);
  var width = right - left;
  var height = bottom - top;

  return (width >= 0 && height >= 0) && {
    top: top,
    bottom: bottom,
    left: left,
    right: right,
    width: width,
    height: height
  } || null;
}


/**
 * Shims the native getBoundingClientRect for compatibility with older IE.
 * @param {Element} el The element whose bounding rect to get.
 * @return {DOMRect|ClientRect} The (possibly shimmed) rect of the element.
 */
function getBoundingClientRect(el) {
  var rect;

  try {
    rect = el.getBoundingClientRect();
  } catch (err) {
    // Ignore Windows 7 IE11 "Unspecified error"
    // https://github.com/w3c/IntersectionObserver/pull/205
  }

  if (!rect) return getEmptyRect();

  // Older IE
  if (!(rect.width && rect.height)) {
    rect = {
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
  }
  return rect;
}


/**
 * Returns an empty rect object. An empty rect is returned when an element
 * is not in the DOM.
 * @return {ClientRect} The empty rect.
 */
function getEmptyRect() {
  return {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    width: 0,
    height: 0
  };
}


/**
 * Ensure that the result has all of the necessary fields of the DOMRect.
 * Specifically this ensures that `x` and `y` fields are set.
 *
 * @param {?DOMRect|?ClientRect} rect
 * @return {?DOMRect}
 */
function ensureDOMRect(rect) {
  // A `DOMRect` object has `x` and `y` fields.
  if (!rect || 'x' in rect) {
    return rect;
  }
  // A IE's `ClientRect` type does not have `x` and `y`. The same is the case
  // for internally calculated Rect objects. For the purposes of
  // `IntersectionObserver`, it's sufficient to simply mirror `left` and `top`
  // for these fields.
  return {
    top: rect.top,
    y: rect.top,
    bottom: rect.bottom,
    left: rect.left,
    x: rect.left,
    right: rect.right,
    width: rect.width,
    height: rect.height
  };
}


/**
 * Inverts the intersection and bounding rect from the parent (frame) BCR to
 * the local BCR space.
 * @param {DOMRect|ClientRect} parentBoundingRect The parent's bound client rect.
 * @param {DOMRect|ClientRect} parentIntersectionRect The parent's own intersection rect.
 * @return {ClientRect} The local root bounding rect for the parent's children.
 */
function convertFromParentRect(parentBoundingRect, parentIntersectionRect) {
  var top = parentIntersectionRect.top - parentBoundingRect.top;
  var left = parentIntersectionRect.left - parentBoundingRect.left;
  return {
    top: top,
    left: left,
    height: parentIntersectionRect.height,
    width: parentIntersectionRect.width,
    bottom: top + parentIntersectionRect.height,
    right: left + parentIntersectionRect.width
  };
}


/**
 * Checks to see if a parent element contains a child element (including inside
 * shadow DOM).
 * @param {Node} parent The parent element.
 * @param {Node} child The child element.
 * @return {boolean} True if the parent node contains the child node.
 */
function containsDeep(parent, child) {
  var node = child;
  while (node) {
    if (node == parent) return true;

    node = getParentNode(node);
  }
  return false;
}


/**
 * Gets the parent node of an element or its host element if the parent node
 * is a shadow root.
 * @param {Node} node The node whose parent to get.
 * @return {Node|null} The parent node or null if no parent exists.
 */
function getParentNode(node) {
  var parent = node.parentNode;

  if (node.nodeType == /* DOCUMENT */ 9 && node != document) {
    // If this node is a document node, look for the embedding frame.
    return getFrameElement(node);
  }

  if (parent && parent.nodeType == 11 && parent.host) {
    // If the parent is a shadow root, return the host element.
    return parent.host;
  }

  if (parent && parent.assignedSlot) {
    // If the parent is distributed in a <slot>, return the parent of a slot.
    return parent.assignedSlot.parentNode;
  }

  return parent;
}


// Exposes the constructors globally.
window.IntersectionObserver = IntersectionObserver;
window.IntersectionObserverEntry = IntersectionObserverEntry;

}());

},{}],223:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /* globals jQuery */

exports.lory = lory;

var _detectPrefixes = __webpack_require__(1);

var _detectPrefixes2 = _interopRequireDefault(_detectPrefixes);

var _detectSupportsPassive = __webpack_require__(2);

var _detectSupportsPassive2 = _interopRequireDefault(_detectSupportsPassive);

var _dispatchEvent = __webpack_require__(3);

var _dispatchEvent2 = _interopRequireDefault(_dispatchEvent);

var _defaults = __webpack_require__(6);

var _defaults2 = _interopRequireDefault(_defaults);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var slice = Array.prototype.slice;

function lory(slider, opts) {
    var position = void 0;
    var slidesWidth = void 0;
    var frameWidth = void 0;
    var slides = void 0;

    /**
     * slider DOM elements
     */
    var frame = void 0;
    var slideContainer = void 0;
    var prevCtrl = void 0;
    var nextCtrl = void 0;
    var prefixes = void 0;
    var transitionEndCallback = void 0;

    var index = 0;
    var options = {};
    var touchEventParams = (0, _detectSupportsPassive2.default)() ? { passive: true } : false;

    /**
     * if object is jQuery convert to native DOM element
     */
    if (typeof jQuery !== 'undefined' && slider instanceof jQuery) {
        slider = slider[0];
    }

    /**
     * private
     * set active class to element which is the current slide
     */
    function setActiveElement(slides, currentIndex) {
        var _options = options,
            classNameActiveSlide = _options.classNameActiveSlide;


        slides.forEach(function (element, index) {
            if (element.classList.contains(classNameActiveSlide)) {
                element.classList.remove(classNameActiveSlide);
            }
        });

        slides[currentIndex].classList.add(classNameActiveSlide);
    }

    /**
     * private
     * setupInfinite: function to setup if infinite is set
     *
     * @param  {array} slideArray
     * @return {array} array of updated slideContainer elements
     */
    function setupInfinite(slideArray) {
        var _options2 = options,
            infinite = _options2.infinite;


        var front = slideArray.slice(0, infinite);
        var back = slideArray.slice(slideArray.length - infinite, slideArray.length);

        front.forEach(function (element) {
            var cloned = element.cloneNode(true);

            slideContainer.appendChild(cloned);
        });

        back.reverse().forEach(function (element) {
            var cloned = element.cloneNode(true);

            slideContainer.insertBefore(cloned, slideContainer.firstChild);
        });

        slideContainer.addEventListener(prefixes.transitionEnd, onTransitionEnd);

        return slice.call(slideContainer.children);
    }

    /**
     * [dispatchSliderEvent description]
     * @return {[type]} [description]
     */
    function dispatchSliderEvent(phase, type, detail) {
        (0, _dispatchEvent2.default)(slider, phase + '.lory.' + type, detail);
    }

    /**
     * translates to a given position in a given time in milliseconds
     *
     * @to        {number} number in pixels where to translate to
     * @duration  {number} time in milliseconds for the transistion
     * @ease      {string} easing css property
     */
    function translate(to, duration, ease) {
        var style = slideContainer && slideContainer.style;

        if (style) {
            style[prefixes.transition + 'TimingFunction'] = ease;
            style[prefixes.transition + 'Duration'] = duration + 'ms';
            style[prefixes.transform] = 'translateX(' + to + 'px)';
        }
    }

    /**
     * returns an element's width
     */
    function elementWidth(element) {
        return element.getBoundingClientRect().width || element.offsetWidth;
    }

    /**
     * slidefunction called by prev, next & touchend
     *
     * determine nextIndex and slide to next postion
     * under restrictions of the defined options
     *
     * @direction  {boolean}
     */
    function slide(nextIndex, direction) {
        var _options3 = options,
            slideSpeed = _options3.slideSpeed,
            slidesToScroll = _options3.slidesToScroll,
            infinite = _options3.infinite,
            rewind = _options3.rewind,
            rewindPrev = _options3.rewindPrev,
            rewindSpeed = _options3.rewindSpeed,
            ease = _options3.ease,
            classNameActiveSlide = _options3.classNameActiveSlide,
            _options3$classNameDi = _options3.classNameDisabledNextCtrl,
            classNameDisabledNextCtrl = _options3$classNameDi === undefined ? 'disabled' : _options3$classNameDi,
            _options3$classNameDi2 = _options3.classNameDisabledPrevCtrl,
            classNameDisabledPrevCtrl = _options3$classNameDi2 === undefined ? 'disabled' : _options3$classNameDi2;


        var duration = slideSpeed;

        var nextSlide = direction ? index + 1 : index - 1;
        var maxOffset = Math.round(slidesWidth - frameWidth);

        dispatchSliderEvent('before', 'slide', {
            index: index,
            nextSlide: nextSlide
        });

        /**
         * Reset control classes
         */
        if (prevCtrl) {
            prevCtrl.classList.remove(classNameDisabledPrevCtrl);
        }
        if (nextCtrl) {
            nextCtrl.classList.remove(classNameDisabledNextCtrl);
        }

        if (typeof nextIndex !== 'number') {
            if (direction) {
                if (infinite && index + infinite * 2 !== slides.length) {
                    nextIndex = index + (infinite - index % infinite);
                } else {
                    nextIndex = index + slidesToScroll;
                }
            } else {
                if (infinite && index % infinite !== 0) {
                    nextIndex = index - index % infinite;
                } else {
                    nextIndex = index - slidesToScroll;
                }
            }
        }

        nextIndex = Math.min(Math.max(nextIndex, 0), slides.length - 1);

        if (infinite && direction === undefined) {
            nextIndex += infinite;
        }

        if (rewindPrev && Math.abs(position.x) === 0 && direction === false) {
            nextIndex = slides.length - 1;
            duration = rewindSpeed;
        }

        var nextOffset = Math.min(Math.max(slides[nextIndex].offsetLeft * -1, maxOffset * -1), 0);

        if (rewind && Math.abs(position.x) === maxOffset && direction) {
            nextOffset = 0;
            nextIndex = 0;
            duration = rewindSpeed;
        }

        /**
         * translate to the nextOffset by a defined duration and ease function
         */
        translate(nextOffset, duration, ease);

        /**
         * update the position with the next position
         */
        position.x = nextOffset;

        /**
         * update the index with the nextIndex only if
         * the offset of the nextIndex is in the range of the maxOffset
         */
        if (slides[nextIndex].offsetLeft <= maxOffset) {
            index = nextIndex;
        }

        if (infinite && (nextIndex === slides.length - infinite || nextIndex === slides.length - slides.length % infinite || nextIndex === 0)) {
            if (direction) {
                index = infinite;
            }

            if (!direction) {
                index = slides.length - infinite * 2;
            }

            position.x = slides[index].offsetLeft * -1;

            transitionEndCallback = function transitionEndCallback() {
                translate(slides[index].offsetLeft * -1, 0, undefined);
            };
        }

        if (classNameActiveSlide) {
            setActiveElement(slice.call(slides), index);
        }

        /**
         * update classes for next and prev arrows
         * based on user settings
         */
        if (prevCtrl && !infinite && !rewindPrev && nextIndex === 0) {
            prevCtrl.classList.add(classNameDisabledPrevCtrl);
        }

        if (nextCtrl && !infinite && !rewind && nextIndex + 1 === slides.length) {
            nextCtrl.classList.add(classNameDisabledNextCtrl);
        }

        dispatchSliderEvent('after', 'slide', {
            currentSlide: index
        });
    }

    /**
     * public
     * setup function
     */
    function setup() {
        dispatchSliderEvent('before', 'init');

        prefixes = (0, _detectPrefixes2.default)();
        options = _extends({}, _defaults2.default, opts);

        var _options4 = options,
            classNameFrame = _options4.classNameFrame,
            classNameSlideContainer = _options4.classNameSlideContainer,
            classNamePrevCtrl = _options4.classNamePrevCtrl,
            classNameNextCtrl = _options4.classNameNextCtrl,
            _options4$classNameDi = _options4.classNameDisabledNextCtrl,
            classNameDisabledNextCtrl = _options4$classNameDi === undefined ? 'disabled' : _options4$classNameDi,
            _options4$classNameDi2 = _options4.classNameDisabledPrevCtrl,
            classNameDisabledPrevCtrl = _options4$classNameDi2 === undefined ? 'disabled' : _options4$classNameDi2,
            enableMouseEvents = _options4.enableMouseEvents,
            classNameActiveSlide = _options4.classNameActiveSlide,
            initialIndex = _options4.initialIndex;


        index = initialIndex;
        frame = slider.getElementsByClassName(classNameFrame)[0];
        slideContainer = frame.getElementsByClassName(classNameSlideContainer)[0];
        prevCtrl = slider.getElementsByClassName(classNamePrevCtrl)[0];
        nextCtrl = slider.getElementsByClassName(classNameNextCtrl)[0];

        position = {
            x: slideContainer.offsetLeft,
            y: slideContainer.offsetTop
        };

        if (options.infinite) {
            slides = setupInfinite(slice.call(slideContainer.children));
        } else {
            slides = slice.call(slideContainer.children);

            if (prevCtrl && !options.rewindPrev) {
                prevCtrl.classList.add(classNameDisabledPrevCtrl);
            }

            if (nextCtrl && slides.length === 1 && !options.rewind) {
                nextCtrl.classList.add(classNameDisabledNextCtrl);
            }
        }

        reset();

        if (classNameActiveSlide) {
            setActiveElement(slides, index);
        }

        if (prevCtrl && nextCtrl) {
            prevCtrl.addEventListener('click', prev);
            nextCtrl.addEventListener('click', next);
        }

        frame.addEventListener('touchstart', onTouchstart, touchEventParams);

        if (enableMouseEvents) {
            frame.addEventListener('mousedown', onTouchstart);
            frame.addEventListener('click', onClick);
        }

        options.window.addEventListener('resize', onResize);

        dispatchSliderEvent('after', 'init');
    }

    /**
     * public
     * reset function: called on resize
     */
    function reset() {
        var _options5 = options,
            infinite = _options5.infinite,
            ease = _options5.ease,
            rewindSpeed = _options5.rewindSpeed,
            rewindOnResize = _options5.rewindOnResize,
            classNameActiveSlide = _options5.classNameActiveSlide,
            initialIndex = _options5.initialIndex;


        slidesWidth = elementWidth(slideContainer);
        frameWidth = elementWidth(frame);

        if (frameWidth === slidesWidth) {
            slidesWidth = slides.reduce(function (previousValue, slide) {
                return previousValue + elementWidth(slide);
            }, 0);
        }

        if (rewindOnResize) {
            index = initialIndex;
        } else {
            ease = null;
            rewindSpeed = 0;
        }

        if (infinite) {
            translate(slides[index + infinite].offsetLeft * -1, 0, null);

            index = index + infinite;
            position.x = slides[index].offsetLeft * -1;
        } else {
            translate(slides[index].offsetLeft * -1, rewindSpeed, ease);
            position.x = slides[index].offsetLeft * -1;
        }

        if (classNameActiveSlide) {
            setActiveElement(slice.call(slides), index);
        }
    }

    /**
     * public
     * slideTo: called on clickhandler
     */
    function slideTo(index) {
        slide(index);
    }

    /**
     * public
     * returnIndex function: called on clickhandler
     */
    function returnIndex() {
        return index - options.infinite || 0;
    }

    /**
     * public
     * prev function: called on clickhandler
     */
    function prev() {
        slide(false, false);
    }

    /**
     * public
     * next function: called on clickhandler
     */
    function next() {
        slide(false, true);
    }

    /**
     * public
     * destroy function: called to gracefully destroy the lory instance
     */
    function destroy() {
        dispatchSliderEvent('before', 'destroy');

        // remove event listeners
        frame.removeEventListener(prefixes.transitionEnd, onTransitionEnd);
        frame.removeEventListener('touchstart', onTouchstart, touchEventParams);
        frame.removeEventListener('touchmove', onTouchmove, touchEventParams);
        frame.removeEventListener('touchend', onTouchend);
        frame.removeEventListener('mousemove', onTouchmove);
        frame.removeEventListener('mousedown', onTouchstart);
        frame.removeEventListener('mouseup', onTouchend);
        frame.removeEventListener('mouseleave', onTouchend);
        frame.removeEventListener('click', onClick);

        options.window.removeEventListener('resize', onResize);

        if (prevCtrl) {
            prevCtrl.removeEventListener('click', prev);
        }

        if (nextCtrl) {
            nextCtrl.removeEventListener('click', next);
        }

        // remove cloned slides if infinite is set
        if (options.infinite) {
            Array.apply(null, Array(options.infinite)).forEach(function () {
                slideContainer.removeChild(slideContainer.firstChild);
                slideContainer.removeChild(slideContainer.lastChild);
            });
        }

        dispatchSliderEvent('after', 'destroy');
    }

    // event handling

    var touchOffset = void 0;
    var delta = void 0;
    var isScrolling = void 0;

    function onTransitionEnd() {
        if (transitionEndCallback) {
            transitionEndCallback();

            transitionEndCallback = undefined;
        }
    }

    function onTouchstart(event) {
        var _options6 = options,
            enableMouseEvents = _options6.enableMouseEvents;

        var touches = event.touches ? event.touches[0] : event;

        if (enableMouseEvents) {
            frame.addEventListener('mousemove', onTouchmove);
            frame.addEventListener('mouseup', onTouchend);
            frame.addEventListener('mouseleave', onTouchend);
        }

        frame.addEventListener('touchmove', onTouchmove, touchEventParams);
        frame.addEventListener('touchend', onTouchend);

        var pageX = touches.pageX,
            pageY = touches.pageY;


        touchOffset = {
            x: pageX,
            y: pageY,
            time: Date.now()
        };

        isScrolling = undefined;

        delta = {};

        dispatchSliderEvent('on', 'touchstart', {
            event: event
        });
    }

    function onTouchmove(event) {
        var touches = event.touches ? event.touches[0] : event;
        var pageX = touches.pageX,
            pageY = touches.pageY;


        delta = {
            x: pageX - touchOffset.x,
            y: pageY - touchOffset.y
        };

        if (typeof isScrolling === 'undefined') {
            isScrolling = !!(isScrolling || Math.abs(delta.x) < Math.abs(delta.y));
        }

        if (!isScrolling && touchOffset) {
            translate(position.x + delta.x, 0, null);
        }

        // may be
        dispatchSliderEvent('on', 'touchmove', {
            event: event
        });
    }

    function onTouchend(event) {
        /**
         * time between touchstart and touchend in milliseconds
         * @duration {number}
         */
        var duration = touchOffset ? Date.now() - touchOffset.time : undefined;

        /**
         * is valid if:
         *
         * -> swipe attempt time is over 300 ms
         * and
         * -> swipe distance is greater than 25px
         * or
         * -> swipe distance is more then a third of the swipe area
         *
         * @isValidSlide {Boolean}
         */
        var isValid = Number(duration) < 300 && Math.abs(delta.x) > 25 || Math.abs(delta.x) > frameWidth / 3;

        /**
         * is out of bounds if:
         *
         * -> index is 0 and delta x is greater than 0
         * or
         * -> index is the last slide and delta is smaller than 0
         *
         * @isOutOfBounds {Boolean}
         */
        var isOutOfBounds = !index && delta.x > 0 || index === slides.length - 1 && delta.x < 0;

        var direction = delta.x < 0;

        if (!isScrolling) {
            if (isValid && !isOutOfBounds) {
                slide(false, direction);
            } else {
                translate(position.x, options.snapBackSpeed);
            }
        }

        touchOffset = undefined;

        /**
         * remove eventlisteners after swipe attempt
         */
        frame.removeEventListener('touchmove', onTouchmove);
        frame.removeEventListener('touchend', onTouchend);
        frame.removeEventListener('mousemove', onTouchmove);
        frame.removeEventListener('mouseup', onTouchend);
        frame.removeEventListener('mouseleave', onTouchend);

        dispatchSliderEvent('on', 'touchend', {
            event: event
        });
    }

    function onClick(event) {
        if (delta.x) {
            event.preventDefault();
        }
    }

    function onResize(event) {
        if (frameWidth !== elementWidth(frame)) {
            reset();

            dispatchSliderEvent('on', 'resize', {
                event: event
            });
        }
    }

    // trigger initial setup
    setup();

    // expose public api
    return {
        setup: setup,
        reset: reset,
        slideTo: slideTo,
        returnIndex: returnIndex,
        prev: prev,
        next: next,
        destroy: destroy
    };
}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = detectPrefixes;
/**
 * Detecting prefixes for saving time and bytes
 */
function detectPrefixes() {
    var transform = void 0;
    var transition = void 0;
    var transitionEnd = void 0;

    (function () {
        var el = document.createElement('_');
        var style = el.style;

        var prop = void 0;

        if (style[prop = 'webkitTransition'] === '') {
            transitionEnd = 'webkitTransitionEnd';
            transition = prop;
        }

        if (style[prop = 'transition'] === '') {
            transitionEnd = 'transitionend';
            transition = prop;
        }

        if (style[prop = 'webkitTransform'] === '') {
            transform = prop;
        }

        if (style[prop = 'msTransform'] === '') {
            transform = prop;
        }

        if (style[prop = 'transform'] === '') {
            transform = prop;
        }

        document.body.insertBefore(el, null);
        style[transform] = 'translateX(0)';
        document.body.removeChild(el);
    })();

    return {
        transform: transform,
        transition: transition,
        transitionEnd: transitionEnd
    };
}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = detectSupportsPassive;
function detectSupportsPassive() {
    var supportsPassive = false;

    try {
        var opts = Object.defineProperty({}, 'passive', {
            get: function get() {
                supportsPassive = true;
            }
        });

        window.addEventListener('testPassive', null, opts);
        window.removeEventListener('testPassive', null, opts);
    } catch (e) {}

    return supportsPassive;
}

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = dispatchEvent;

var _customEvent = __webpack_require__(4);

var _customEvent2 = _interopRequireDefault(_customEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * dispatch custom events
 *
 * @param  {element} el         slideshow element
 * @param  {string}  type       custom event name
 * @param  {object}  detail     custom detail information
 */
function dispatchEvent(target, type, detail) {
    var event = new _customEvent2.default(type, {
        bubbles: true,
        cancelable: true,
        detail: detail
    });

    target.dispatchEvent(event);
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
var NativeCustomEvent = global.CustomEvent;

function useNative () {
  try {
    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
    return  'cat' === p.type && 'bar' === p.detail.foo;
  } catch (e) {
  }
  return false;
}

/**
 * Cross-browser `CustomEvent` constructor.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
 *
 * @public
 */

module.exports = useNative() ? NativeCustomEvent :

// IE >= 9
'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {
  var e = document.createEvent('CustomEvent');
  if (params) {
    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
  } else {
    e.initCustomEvent(type, false, false, void 0);
  }
  return e;
} :

// IE <= 8
function CustomEvent (type, params) {
  var e = document.createEventObject();
  e.type = type;
  if (params) {
    e.bubbles = Boolean(params.bubbles);
    e.cancelable = Boolean(params.cancelable);
    e.detail = params.detail;
  } else {
    e.bubbles = false;
    e.cancelable = false;
    e.detail = void 0;
  }
  return e;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ }),
/* 5 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  /**
   * slides scrolled at once
   * @slidesToScroll {Number}
   */
  slidesToScroll: 1,

  /**
   * time in milliseconds for the animation of a valid slide attempt
   * @slideSpeed {Number}
   */
  slideSpeed: 300,

  /**
   * time in milliseconds for the animation of the rewind after the last slide
   * @rewindSpeed {Number}
   */
  rewindSpeed: 600,

  /**
   * time for the snapBack of the slider if the slide attempt was not valid
   * @snapBackSpeed {Number}
   */
  snapBackSpeed: 200,

  /**
   * Basic easing functions: https://developer.mozilla.org/de/docs/Web/CSS/transition-timing-function
   * cubic bezier easing functions: http://easings.net/de
   * @ease {String}
   */
  ease: 'ease',

  /**
   * if slider reached the last slide, with next click the slider goes back to the startindex.
   * use infinite or rewind, not both
   * @rewind {Boolean}
   */
  rewind: false,

  /**
   * number of visible slides or false
   * use infinite or rewind, not both
   * @infinite {number}
   */
  infinite: false,

  /**
   * the slide index to show when the slider is initialized.
   * @initialIndex {number}
   */
  initialIndex: 0,

  /**
   * class name for slider frame
   * @classNameFrame {string}
   */
  classNameFrame: 'js_frame',

  /**
   * class name for slides container
   * @classNameSlideContainer {string}
   */
  classNameSlideContainer: 'js_slides',

  /**
   * class name for slider prev control
   * @classNamePrevCtrl {string}
   */
  classNamePrevCtrl: 'js_prev',

  /**
   * class name for slider next control
   * @classNameNextCtrl {string}
   */
  classNameNextCtrl: 'js_next',

  /**
   * class name for current active slide
   * if emptyString then no class is set
   * @classNameActiveSlide {string}
   */
  classNameActiveSlide: 'active',

  /**
   * enables mouse events for swiping on desktop devices
   * @enableMouseEvents {boolean}
   */
  enableMouseEvents: false,

  /**
   * window instance
   * @window {object}
   */
  window: typeof window !== 'undefined' ? window : null,

  /**
   * If false, slides lory to the first slide on window resize.
   * @rewindOnResize {boolean}
   */
  rewindOnResize: true
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(0);


/***/ })
/******/ ]);
});
},{}],224:[function(require,module,exports){
if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = function (callback, thisArg) {
        thisArg = thisArg || window;
        for (var i = 0; i < this.length; i++) {
            callback.call(thisArg, this[i], i, this);
        }
    };
}

},{}],225:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],226:[function(require,module,exports){
'use strict';

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

},{}],227:[function(require,module,exports){
'use strict';

var stringify = require('./stringify');
var parse = require('./parse');
var formats = require('./formats');

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};

},{"./formats":226,"./parse":228,"./stringify":229}],228:[function(require,module,exports){
'use strict';

var utils = require('./utils');

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

// This is what browsers will submit when the  character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the  character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset);
            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (val && options.comma && val.indexOf(',') > -1) {
            val = val.split(',');
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === 'number' ? opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};

},{"./utils":230}],229:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var formats = require('./formats');
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    formatter: formats.formatters[formats['default']],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = obj.join(',');
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        }
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};

},{"./formats":226,"./utils":230}],230:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};

},{}],231:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":225,"timers":231}],232:[function(require,module,exports){
/**!
* tippy.js v6.2.7
* (c) 2017-2020 atomiks
* MIT License
*/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@popperjs/core');

var ROUND_ARROW = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>';
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};

function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
  }

  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf('[object') === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === 'function' ? value.apply(void 0, args) : value;
}
function debounce(fn, ms) {
  // Avoid wrapping in `setTimeout` if ms is 0 anyway
  if (ms === 0) {
    return fn;
  }

  var timeout;
  return function (arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function () {
      fn(arg);
    }, ms);
  };
}
function removeProperties(obj, keys) {
  var clone = Object.assign({}, obj);
  keys.forEach(function (key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function (item, index) {
    return arr.indexOf(item) === index;
  });
}
function getBasePlacement(placement) {
  return placement.split('-')[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function (acc, key) {
    if (obj[key] !== undefined) {
      acc[key] = obj[key];
    }

    return acc;
  }, {});
}

function div() {
  return document.createElement('div');
}
function isElement(value) {
  return ['Element', 'Fragment'].some(function (type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, 'NodeList');
}
function isMouseEvent(value) {
  return isType(value, 'MouseEvent');
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }

  if (isNodeList(value)) {
    return arrayFrom(value);
  }

  if (Array.isArray(value)) {
    return value;
  }

  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function (el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function (el) {
    if (el) {
      el.setAttribute('data-state', state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _normalizeToArray = normalizeToArray(elementOrElements),
      element = _normalizeToArray[0];

  return element ? element.ownerDocument || document : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX,
      clientY = event.clientY;
  return popperTreeData.every(function (_ref) {
    var popperRect = _ref.popperRect,
        popperState = _ref.popperState,
        props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;

    if (!offsetData) {
      return true;
    }

    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;
    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener"; // some browsers apparently support `transition` (unprefixed) but only fire
  // `webkitTransitionEnd`...

  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {
    box[method](event, listener);
  });
}

var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
/**
 * When a `touchstart` event is fired, it's assumed the user is using touch
 * input. We'll bind a `mousemove` event listener to listen for mouse input in
 * the future. This way, the `isTouch` property is fully dynamic and will handle
 * hybrid devices that use a mix of touch + mouse input.
 */

function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }

  currentInput.isTouch = true;

  if (window.performance) {
    document.addEventListener('mousemove', onDocumentMouseMove);
  }
}
/**
 * When two `mousemove` event are fired consecutively within 20ms, it's assumed
 * the user is using mouse input again. `mousemove` can fire on touch devices as
 * well, but very rarely that quickly.
 */

function onDocumentMouseMove() {
  var now = performance.now();

  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener('mousemove', onDocumentMouseMove);
  }

  lastMouseMoveTime = now;
}
/**
 * When an element is in focus and has a tippy, leaving the tab/window and
 * returning causes it to show again. For mouse users this is unexpected, but
 * for keyboard use it makes sense.
 * TODO: find a better technique to solve this problem
 */

function onWindowBlur() {
  var activeElement = document.activeElement;

  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;

    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener('blur', onWindowBlur);
}

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var ua = isBrowser ? navigator.userAgent : '';
var isIE = /MSIE |Trident\//.test(ua);

function createMemoryLeakWarning(method) {
  var txt = method === 'destroy' ? 'n already-' : ' ';
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", 'indicates a potential memory leak.'].join(' ');
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();
}

function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c\uD83D\uDC77\u200D This is a development-only message. It will be removed in production.\n  ");
}

function getFormattedMessage(message) {
  return [getDevMessage(message), // title
  'color: #00C584; font-size: 1.3em; font-weight: bold;', // message
  'line-height: 1.5', // footer
  'color: #a6a095;'];
} // Assume warnings and errors never have the same message

var visitedMessages;

if ("development" !== "production") {
  resetVisitedMessages();
}

function resetVisitedMessages() {
  visitedMessages = new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;

    visitedMessages.add(message);

    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;

    visitedMessages.add(message);

    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));
  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));
}

var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: 'fade',
  arrow: true,
  content: '',
  inertia: false,
  maxWidth: 350,
  role: 'tooltip',
  theme: '',
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: function appendTo() {
    return document.body;
  },
  aria: {
    content: 'auto',
    expanded: 'auto'
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: '',
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {},
  onBeforeUpdate: function onBeforeUpdate() {},
  onCreate: function onCreate() {},
  onDestroy: function onDestroy() {},
  onHidden: function onHidden() {},
  onHide: function onHide() {},
  onMount: function onMount() {},
  onShow: function onShow() {},
  onShown: function onShown() {},
  onTrigger: function onTrigger() {},
  onUntrigger: function onUntrigger() {},
  onClickOutside: function onClickOutside() {},
  placement: 'top',
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: 'mouseenter focus',
  triggerTarget: null
}, pluginProps, {}, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps(partialProps) {
  /* istanbul ignore else */
  if ("development" !== "production") {
    validateProps(partialProps, []);
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps = plugins.reduce(function (acc, plugin) {
    var name = plugin.name,
        defaultValue = plugin.defaultValue;

    if (name) {
      acc[name] = passedProps[name] !== undefined ? passedProps[name] : defaultValue;
    }

    return acc;
  }, {});
  return Object.assign({}, passedProps, {}, pluginProps);
}
function getDataAttributeProps(reference, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins: plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function (acc, key) {
    var valueAsString = (reference.getAttribute("data-tippy-" + key) || '').trim();

    if (!valueAsString) {
      return acc;
    }

    if (key === 'content') {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }

    return acc;
  }, {});
  return props;
}
function evaluateProps(reference, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, {}, out.aria);
  out.aria = {
    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,
    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }

  if (plugins === void 0) {
    plugins = [];
  }

  var keys = Object.keys(partialProps);
  keys.forEach(function (prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`

    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function (plugin) {
        return plugin.name === prop;
      }).length === 0;
    }

    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", 'a plugin, forgot to pass it in an array as props.plugins.', '\n\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));
  });
}

var innerHTML = function innerHTML() {
  return 'innerHTML';
};

function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}

function createArrowElement(value) {
  var arrow = div();

  if (value === true) {
    arrow.className = ARROW_CLASS;
  } else {
    arrow.className = SVG_ARROW_CLASS;

    if (isElement(value)) {
      arrow.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow, value);
    }
  }

  return arrow;
}

function setContent(content, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content, '');
    content.appendChild(props.content);
  } else if (typeof props.content !== 'function') {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper) {
  var box = popper.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box: box,
    content: boxChildren.find(function (node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function (node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function (node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute('data-state', 'hidden');
  box.setAttribute('tabindex', '-1');
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute('data-state', 'hidden');
  setContent(content, instance.props);
  popper.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);

  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper),
        box = _getChildren.box,
        content = _getChildren.content,
        arrow = _getChildren.arrow;

    if (nextProps.theme) {
      box.setAttribute('data-theme', nextProps.theme);
    } else {
      box.removeAttribute('data-theme');
    }

    if (typeof nextProps.animation === 'string') {
      box.setAttribute('data-animation', nextProps.animation);
    } else {
      box.removeAttribute('data-animation');
    }

    if (nextProps.inertia) {
      box.setAttribute('data-inertia', '');
    } else {
      box.removeAttribute('data-inertia');
    }

    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + "px" : nextProps.maxWidth;

    if (nextProps.role) {
      box.setAttribute('role', nextProps.role);
    } else {
      box.removeAttribute('role');
    }

    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content, instance.props);
    }

    if (nextProps.arrow) {
      if (!arrow) {
        box.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box.removeChild(arrow);
        box.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow) {
      box.removeChild(arrow);
    }
  }

  return {
    popper: popper,
    onUpdate: onUpdate
  };
} // Runtime check to identify if the render function is the default one; this
// way we can apply default CSS transitions logic and it can be tree-shaken away

render.$$tippy = true;

var idCounter = 1;
var mouseMoveListeners = []; // Used by `hideAll()`

var mountedInstances = [];
function createTippy(reference, passedProps) {
  var props = evaluateProps(reference, Object.assign({}, defaultProps, {}, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================
  //  Private members
  // ===========================================================================

  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget; // ===========================================================================
  //  Public members
  // ===========================================================================

  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id: id,
    reference: reference,
    popper: div(),
    popperInstance: popperInstance,
    props: props,
    state: state,
    plugins: plugins,
    // methods
    clearDelayTimeouts: clearDelayTimeouts,
    setProps: setProps,
    setContent: setContent,
    show: show,
    hide: hide,
    hideWithInteractivity: hideWithInteractivity,
    enable: enable,
    disable: disable,
    unmount: unmount,
    destroy: destroy
  }; // TODO: Investigate why this early return causes a TDZ error in the tests 
  // it doesn't seem to happen in the browser

  /* istanbul ignore if */

  if (!props.render) {
    if ("development" !== "production") {
      errorWhen(true, 'render() function has not been supplied.');
    }

    return instance;
  } // ===========================================================================
  // Initial mutations
  // ===========================================================================


  var _props$render = props.render(instance),
      popper = _props$render.popper,
      onUpdate = _props$render.onUpdate;

  popper.setAttribute('data-tippy-root', '');
  popper.id = "tippy-" + instance.id;
  instance.popper = popper;
  reference._tippy = instance;
  popper._tippy = instance;
  var pluginsHooks = plugins.map(function (plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference.hasAttribute('aria-expanded');
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook('onCreate', [instance]);

  if (props.showOnCreate) {
    scheduleShow();
  } // Prevent a tippy with a delay from hiding if the cursor left then returned
  // before it started hiding


  popper.addEventListener('mouseenter', function () {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper.addEventListener('mouseleave', function (event) {
    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {
      getDocument().addEventListener('mousemove', debouncedOnMouseMove);
      debouncedOnMouseMove(event);
    }
  });
  return instance; // ===========================================================================
  //  Private methods
  // ===========================================================================

  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }

  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === 'hold';
  }

  function getIsDefaultRenderFn() {
    var _instance$props$rende;

    // @ts-ignore
    return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
  }

  function getCurrentTarget() {
    return currentTarget || reference;
  }

  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }

  function getDefaultTemplateChildren() {
    return getChildren(popper);
  }

  function getDelay(isShow) {
    // For touch or keyboard input, force `0` delay for UX reasons
    // Also if the instance is mounted but not visible (transitioning out),
    // ignore delay
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {
      return 0;
    }

    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }

  function handleStyles() {
    popper.style.pointerEvents = instance.props.interactive && instance.state.isVisible ? '' : 'none';
    popper.style.zIndex = "" + instance.props.zIndex;
  }

  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }

    pluginsHooks.forEach(function (pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(void 0, args);
      }
    });

    if (shouldInvokePropsHook) {
      var _instance$props;

      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }

  function handleAriaContentAttribute() {
    var aria = instance.props.aria;

    if (!aria.content) {
      return;
    }

    var attr = "aria-" + aria.content;
    var id = popper.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      var currentValue = node.getAttribute(attr);

      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id : id);
      } else {
        var nextValue = currentValue && currentValue.replace(id, '').trim();

        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }

  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      if (instance.props.interactive) {
        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');
      } else {
        node.removeAttribute('aria-expanded');
      }
    });
  }

  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener('mousemove', debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {
      return listener !== debouncedOnMouseMove;
    });
  }

  function onDocumentPress(event) {
    // Moved finger to scroll instead of an intentional tap outside
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === 'mousedown') {
        return;
      }
    } // Clicked on interactive popper


    if (instance.props.interactive && popper.contains(event.target)) {
      return;
    } // Clicked on the event listeners target


    if (getCurrentTarget().contains(event.target)) {
      if (currentInput.isTouch) {
        return;
      }

      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {
        return;
      }
    } else {
      invokeHook('onClickOutside', [instance, event]);
    }

    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the
      // currentTarget. This lets a tippy with `focus` trigger know that it
      // should not show

      didHideDueToDocumentMouseDown = true;
      setTimeout(function () {
        didHideDueToDocumentMouseDown = false;
      }); // The listener gets added in `scheduleShow()`, but this may be hiding it
      // before it shows, and hide()'s early bail-out behavior can prevent it
      // from being cleaned up

      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }

  function onTouchMove() {
    didTouchMove = true;
  }

  function onTouchStart() {
    didTouchMove = false;
  }

  function addDocumentPress() {
    var doc = getDocument();
    doc.addEventListener('mousedown', onDocumentPress, true);
    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function removeDocumentPress() {
    var doc = getDocument();
    doc.removeEventListener('mousedown', onDocumentPress, true);
    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);
    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);
    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);
  }

  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function () {
      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {
        callback();
      }
    });
  }

  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }

  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;

    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, 'remove', listener);
        callback();
      }
    } // Make callback synchronous if duration is 0
    // `transitionend` won't fire otherwise


    if (duration === 0) {
      return callback();
    }

    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);
    updateTransitionEndListener(box, 'add', listener);
    currentTransitionEndListener = listener;
  }

  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    var nodes = normalizeToArray(instance.props.triggerTarget || reference);
    nodes.forEach(function (node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node: node,
        eventType: eventType,
        handler: handler,
        options: options
      });
    });
  }

  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on('touchstart', onTrigger, {
        passive: true
      });
      on('touchend', onMouseLeave, {
        passive: true
      });
    }

    splitBySpaces(instance.props.trigger).forEach(function (eventType) {
      if (eventType === 'manual') {
        return;
      }

      on(eventType, onTrigger);

      switch (eventType) {
        case 'mouseenter':
          on('mouseleave', onMouseLeave);
          break;

        case 'focus':
          on(isIE ? 'focusout' : 'blur', onBlurOrFocusOut);
          break;

        case 'focusin':
          on('focusout', onBlurOrFocusOut);
          break;
      }
    });
  }

  function removeListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function onTrigger(event) {
    var _lastTriggerEvent;

    var shouldScheduleClickHide = false;

    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }

    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();

    if (!instance.state.isVisible && isMouseEvent(event)) {
      // If scrolling, `mouseenter` events can be fired if the cursor lands
      // over a new target, but `mousemove` events don't get fired. This
      // causes interactive tooltips to get stuck open until the cursor is
      // moved
      mouseMoveListeners.forEach(function (listener) {
        return listener(event);
      });
    } // Toggle show/hide when clicking click-triggered tooltips


    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }

    if (event.type === 'click') {
      isVisibleFromClick = !shouldScheduleClickHide;
    }

    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }

  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);

    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {
      return;
    }

    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {
      var _instance$popperInsta;

      var instance = popper._tippy;
      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;

      if (state) {
        return {
          popperRect: popper.getBoundingClientRect(),
          popperState: state,
          props: props
        };
      }

      return null;
    }).filter(Boolean);

    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }

  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;

    if (shouldBail) {
      return;
    }

    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }

    scheduleHide(event);
  }

  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {
      return;
    } // If focus was moved to within the popper


    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {
      return;
    }

    scheduleHide(event);
  }

  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;
  }

  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props,
        popperOptions = _instance$props2.popperOptions,
        placement = _instance$props2.placement,
        offset = _instance$props2.offset,
        getReferenceClientRect = _instance$props2.getReferenceClientRect,
        moveTransition = _instance$props2.moveTransition;
    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference;
    var tippyModifier = {
      name: '$$tippy',
      enabled: true,
      phase: 'beforeWrite',
      requires: ['computeStyles'],
      fn: function fn(_ref2) {
        var state = _ref2.state;

        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(),
              box = _getDefaultTemplateCh.box;

          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {
            if (attr === 'placement') {
              box.setAttribute('data-placement', state.placement);
            } else {
              if (state.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, '');
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state.attributes.popper = {};
        }
      }
    };
    var modifiers = [{
      name: 'offset',
      options: {
        offset: offset
      }
    }, {
      name: 'preventOverflow',
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: 'flip',
      options: {
        padding: 5
      }
    }, {
      name: 'computeStyles',
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];

    if (getIsDefaultRenderFn() && arrow) {
      modifiers.push({
        name: 'arrow',
        options: {
          element: arrow,
          padding: 3
        }
      });
    }

    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = core.createPopper(computedReference, popper, Object.assign({}, popperOptions, {
      placement: placement,
      onFirstUpdate: onFirstUpdate,
      modifiers: modifiers
    }));
  }

  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }

  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so
    // it's directly after the reference element so the elements inside the
    // tippy can be tabbed to
    // If there are clipping issues, the user can specify a different appendTo
    // and ensure focus management is handled correctly manually

    var node = getCurrentTarget();

    if (instance.props.interactive && appendTo === defaultProps.appendTo || appendTo === 'parent') {
      parentNode = node.parentNode;
    } else {
      parentNode = invokeWithArgsOrReturn(appendTo, [node]);
    } // The popper element needs to exist on the DOM before its position can be
    // updated as Popper needs to read its dimensions


    if (!parentNode.contains(popper)) {
      parentNode.appendChild(popper);
    }

    createPopperInstance();
    /* istanbul ignore else */

    if ("development" !== "production") {
      // Accessibility check
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\n\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\n\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\n\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));
    }
  }

  function getNestedPopperTree() {
    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));
  }

  function scheduleShow(event) {
    instance.clearDelayTimeouts();

    if (event) {
      invokeHook('onTrigger', [instance, event]);
    }

    addDocumentPress();
    var delay = getDelay(true);

    var _getNormalizedTouchSe = getNormalizedTouchSettings(),
        touchValue = _getNormalizedTouchSe[0],
        touchDelay = _getNormalizedTouchSe[1];

    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {
      delay = touchDelay;
    }

    if (delay) {
      showTimeout = setTimeout(function () {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }

  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook('onUntrigger', [instance, event]);

    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    } // For interactive tippies, scheduleHide is added to a document.body handler
    // from onMouseLeave so must intercept scheduled hides from mousemove/leave
    // events when trigger contains mouseenter and click, and the tip is
    // currently shown as a result of a click.


    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }

    var delay = getDelay(false);

    if (delay) {
      hideTimeout = setTimeout(function () {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      // Fixes a `transitionend` problem when it fires 1 frame too
      // late sometimes, we don't want hide() to be called.
      scheduleHideAnimationFrame = requestAnimationFrame(function () {
        instance.hide();
      });
    }
  } // ===========================================================================
  //  Public methods
  // ===========================================================================


  function enable() {
    instance.state.isEnabled = true;
  }

  function disable() {
    // Disabling the instance should also hide it
    // https://github.com/atomiks/tippy.js-react/issues/106
    instance.hide();
    instance.state.isEnabled = false;
  }

  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }

  function setProps(partialProps) {
    /* istanbul ignore else */
    if ("development" !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    invokeHook('onBeforeUpdate', [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference, Object.assign({}, instance.props, {}, partialProps, {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();

    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    } // Ensure stale aria-expanded attributes are removed


    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {
        node.removeAttribute('aria-expanded');
      });
    } else if (nextProps.triggerTarget) {
      reference.removeAttribute('aria-expanded');
    }

    handleAriaExpandedAttribute();
    handleStyles();

    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }

    if (instance.popperInstance) {
      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,
      // and the nested ones get re-rendered first.
      // https://github.com/atomiks/tippyjs-react/issues/177
      // TODO: find a cleaner / more efficient solution(!)

      getNestedPopperTree().forEach(function (nestedPopper) {
        // React (and other UI libs likely) requires a rAF wrapper as it flushes
        // its work in one
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }

    invokeHook('onAfterUpdate', [instance, partialProps]);
  }

  function setContent(content) {
    instance.setProps({
      content: content
    });
  }

  function show() {
    /* istanbul ignore else */
    if ("development" !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));
    } // Early bail-out


    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);

    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    } // Normalize `disabled` behavior across browsers.
    // Firefox allows events on disabled elements, but Chrome doesn't.
    // Using a wrapper element (i.e. <span>) is recommended.


    if (getCurrentTarget().hasAttribute('disabled')) {
      return;
    }

    invokeHook('onShow', [instance], false);

    if (instance.props.onShow(instance) === false) {
      return;
    }

    instance.state.isVisible = true;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'visible';
    }

    handleStyles();
    addDocumentPress();

    if (!instance.state.isMounted) {
      popper.style.transition = 'none';
    } // If flipping to the opposite side after hiding at least once, the
    // animation will use the wrong placement without resetting the duration


    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh2.box,
          content = _getDefaultTemplateCh2.content;

      setTransitionDuration([box, content], 0);
    }

    onFirstUpdate = function onFirstUpdate() {
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }

      ignoreOnFirstUpdate = true; // reflow

      void popper.offsetHeight;
      popper.style.transition = instance.props.moveTransition;

      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),
            _box = _getDefaultTemplateCh3.box,
            _content = _getDefaultTemplateCh3.content;

        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], 'visible');
      }

      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      instance.state.isMounted = true;
      invokeHook('onMount', [instance]);

      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function () {
          instance.state.isShown = true;
          invokeHook('onShown', [instance]);
        });
      }
    };

    mount();
  }

  function hide() {
    /* istanbul ignore else */
    if ("development" !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));
    } // Early bail-out


    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);

    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }

    invokeHook('onHide', [instance], false);

    if (instance.props.onHide(instance) === false) {
      return;
    }

    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;

    if (getIsDefaultRenderFn()) {
      popper.style.visibility = 'hidden';
    }

    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles();

    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),
          box = _getDefaultTemplateCh4.box,
          content = _getDefaultTemplateCh4.content;

      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], 'hidden');
      }
    }

    handleAriaContentAttribute();
    handleAriaExpandedAttribute();

    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }

  function hideWithInteractivity(event) {
    /* istanbul ignore else */
    if ("development" !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));
    }

    getDocument().addEventListener('mousemove', debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }

  function unmount() {
    /* istanbul ignore else */
    if ("development" !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));
    }

    if (instance.state.isVisible) {
      instance.hide();
    }

    if (!instance.state.isMounted) {
      return;
    }

    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper
    // tree by default. This seems mainly for interactive tippies, but we should
    // find a workaround if possible

    getNestedPopperTree().forEach(function (nestedPopper) {
      nestedPopper._tippy.unmount();
    });

    if (popper.parentNode) {
      popper.parentNode.removeChild(popper);
    }

    mountedInstances = mountedInstances.filter(function (i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook('onHidden', [instance]);
  }

  function destroy() {
    /* istanbul ignore else */
    if ("development" !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));
    }

    if (instance.state.isDestroyed) {
      return;
    }

    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference._tippy;
    instance.state.isDestroyed = true;
    invokeHook('onDestroy', [instance]);
  }
}

function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  /* istanbul ignore else */

  if ("development" !== "production") {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }

  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins: plugins
  });
  var elements = getArrayOfElements(targets);
  /* istanbul ignore else */

  if ("development" !== "production") {
    var isSingleContentElement = isElement(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\n\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\n\n', '1) content: element.innerHTML\n', '2) content: () => element.cloneNode(true)'].join(' '));
  }

  var instances = elements.reduce(function (acc, reference) {
    var instance = reference && createTippy(reference, passedProps);

    if (instance) {
      acc.push(instance);
    }

    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}

tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
var hideAll = function hideAll(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      excludedReferenceOrInstance = _ref.exclude,
      duration = _ref.duration;

  mountedInstances.forEach(function (instance) {
    var isExcluded = false;

    if (excludedReferenceOrInstance) {
      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;
    }

    if (!isExcluded) {
      var originalDuration = instance.props.duration;
      instance.setProps({
        duration: duration
      });
      instance.hide();

      if (!instance.state.isDestroyed) {
        instance.setProps({
          duration: originalDuration
        });
      }
    }
  });
};

var createSingleton = function createSingleton(tippyInstances, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }

  /* istanbul ignore else */
  if ("development" !== "production") {
    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' '));
  }

  var individualInstances = tippyInstances;
  var references = [];
  var currentTarget;
  var overrides = optionalProps.overrides;
  var interceptSetPropsCleanups = [];

  function setReferences() {
    references = individualInstances.map(function (instance) {
      return instance.reference;
    });
  }

  function enableInstances(isEnabled) {
    individualInstances.forEach(function (instance) {
      if (isEnabled) {
        instance.enable();
      } else {
        instance.disable();
      }
    });
  }

  function interceptSetProps(singleton) {
    return individualInstances.map(function (instance) {
      var originalSetProps = instance.setProps;

      instance.setProps = function (props) {
        originalSetProps(props);

        if (instance.reference === currentTarget) {
          singleton.setProps(props);
        }
      };

      return function () {
        instance.setProps = originalSetProps;
      };
    });
  }

  enableInstances(false);
  setReferences();
  var plugin = {
    fn: function fn() {
      return {
        onDestroy: function onDestroy() {
          enableInstances(true);
        },
        onTrigger: function onTrigger(instance, event) {
          var target = event.currentTarget;
          var index = references.indexOf(target); // bail-out

          if (target === currentTarget) {
            return;
          }

          currentTarget = target;
          var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {
            acc[prop] = individualInstances[index].props[prop];
            return acc;
          }, {});
          instance.setProps(Object.assign({}, overrideProps, {
            getReferenceClientRect: typeof overrideProps.getReferenceClientRect === 'function' ? overrideProps.getReferenceClientRect : function () {
              return target.getBoundingClientRect();
            }
          }));
        }
      };
    }
  };
  var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {
    plugins: [plugin].concat(optionalProps.plugins || []),
    triggerTarget: references
  }));
  var originalSetProps = singleton.setProps;

  singleton.setProps = function (props) {
    overrides = props.overrides || overrides;
    originalSetProps(props);
  };

  singleton.setInstances = function (nextInstances) {
    enableInstances(true);
    interceptSetPropsCleanups.forEach(function (fn) {
      return fn();
    });
    individualInstances = nextInstances;
    enableInstances(false);
    setReferences();
    interceptSetProps(singleton);
    singleton.setProps({
      triggerTarget: references
    });
  };

  interceptSetPropsCleanups = interceptSetProps(singleton);
  return singleton;
};

var BUBBLING_EVENTS_MAP = {
  mouseover: 'mouseenter',
  focusin: 'focus',
  click: 'click'
};
/**
 * Creates a delegate instance that controls the creation of tippy instances
 * for child elements (`target` CSS selector).
 */

function delegate(targets, props) {
  /* istanbul ignore else */
  if ("development" !== "production") {
    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));
  }

  var listeners = [];
  var childTippyInstances = [];
  var disabled = false;
  var target = props.target;
  var nativeProps = removeProperties(props, ['target']);
  var parentProps = Object.assign({}, nativeProps, {
    trigger: 'manual',
    touch: false
  });
  var childProps = Object.assign({}, nativeProps, {
    showOnCreate: true
  });
  var returnValue = tippy(targets, parentProps);
  var normalizedReturnValue = normalizeToArray(returnValue);

  function onTrigger(event) {
    if (!event.target || disabled) {
      return;
    }

    var targetNode = event.target.closest(target);

    if (!targetNode) {
      return;
    } // Get relevant trigger with fallbacks:
    // 1. Check `data-tippy-trigger` attribute on target node
    // 2. Fallback to `trigger` passed to `delegate()`
    // 3. Fallback to `defaultProps.trigger`


    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore

    if (targetNode._tippy) {
      return;
    }

    if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {
      return;
    }

    if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {
      return;
    }

    var instance = tippy(targetNode, childProps);

    if (instance) {
      childTippyInstances = childTippyInstances.concat(instance);
    }
  }

  function on(node, eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }

    node.addEventListener(eventType, handler, options);
    listeners.push({
      node: node,
      eventType: eventType,
      handler: handler,
      options: options
    });
  }

  function addEventListeners(instance) {
    var reference = instance.reference;
    on(reference, 'touchstart', onTrigger);
    on(reference, 'mouseover', onTrigger);
    on(reference, 'focusin', onTrigger);
    on(reference, 'click', onTrigger);
  }

  function removeEventListeners() {
    listeners.forEach(function (_ref) {
      var node = _ref.node,
          eventType = _ref.eventType,
          handler = _ref.handler,
          options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }

  function applyMutations(instance) {
    var originalDestroy = instance.destroy;
    var originalEnable = instance.enable;
    var originalDisable = instance.disable;

    instance.destroy = function (shouldDestroyChildInstances) {
      if (shouldDestroyChildInstances === void 0) {
        shouldDestroyChildInstances = true;
      }

      if (shouldDestroyChildInstances) {
        childTippyInstances.forEach(function (instance) {
          instance.destroy();
        });
      }

      childTippyInstances = [];
      removeEventListeners();
      originalDestroy();
    };

    instance.enable = function () {
      originalEnable();
      childTippyInstances.forEach(function (instance) {
        return instance.enable();
      });
      disabled = false;
    };

    instance.disable = function () {
      originalDisable();
      childTippyInstances.forEach(function (instance) {
        return instance.disable();
      });
      disabled = true;
    };

    addEventListeners(instance);
  }

  normalizedReturnValue.forEach(applyMutations);
  return returnValue;
}

var animateFill = {
  name: 'animateFill',
  defaultValue: false,
  fn: function fn(instance) {
    var _instance$props$rende;

    // @ts-ignore
    if (!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy)) {
      if ("development" !== "production") {
        errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');
      }

      return {};
    }

    var _getChildren = getChildren(instance.popper),
        box = _getChildren.box,
        content = _getChildren.content;

    var backdrop = instance.props.animateFill ? createBackdropElement() : null;
    return {
      onCreate: function onCreate() {
        if (backdrop) {
          box.insertBefore(backdrop, box.firstElementChild);
          box.setAttribute('data-animatefill', '');
          box.style.overflow = 'hidden';
          instance.setProps({
            arrow: false,
            animation: 'shift-away'
          });
        }
      },
      onMount: function onMount() {
        if (backdrop) {
          var transitionDuration = box.style.transitionDuration;
          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the
          // tooltip element. `clip-path` is the other alternative but is not
          // well-supported and is buggy on some devices.

          content.style.transitionDelay = Math.round(duration / 10) + "ms";
          backdrop.style.transitionDuration = transitionDuration;
          setVisibilityState([backdrop], 'visible');
        }
      },
      onShow: function onShow() {
        if (backdrop) {
          backdrop.style.transitionDuration = '0ms';
        }
      },
      onHide: function onHide() {
        if (backdrop) {
          setVisibilityState([backdrop], 'hidden');
        }
      }
    };
  }
};

function createBackdropElement() {
  var backdrop = div();
  backdrop.className = BACKDROP_CLASS;
  setVisibilityState([backdrop], 'hidden');
  return backdrop;
}

var mouseCoords = {
  clientX: 0,
  clientY: 0
};
var activeInstances = [];

function storeMouseCoords(_ref) {
  var clientX = _ref.clientX,
      clientY = _ref.clientY;
  mouseCoords = {
    clientX: clientX,
    clientY: clientY
  };
}

function addMouseCoordsListener(doc) {
  doc.addEventListener('mousemove', storeMouseCoords);
}

function removeMouseCoordsListener(doc) {
  doc.removeEventListener('mousemove', storeMouseCoords);
}

var followCursor = {
  name: 'followCursor',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;
    var doc = getOwnerDocument(instance.props.triggerTarget || reference);
    var isInternalUpdate = false;
    var wasFocusEvent = false;
    var isUnmounted = true;
    var prevProps = instance.props;

    function getIsInitialBehavior() {
      return instance.props.followCursor === 'initial' && instance.state.isVisible;
    }

    function addListener() {
      doc.addEventListener('mousemove', onMouseMove);
    }

    function removeListener() {
      doc.removeEventListener('mousemove', onMouseMove);
    }

    function unsetGetReferenceClientRect() {
      isInternalUpdate = true;
      instance.setProps({
        getReferenceClientRect: null
      });
      isInternalUpdate = false;
    }

    function onMouseMove(event) {
      // If the instance is interactive, avoid updating the position unless it's
      // over the reference element
      var isCursorOverReference = event.target ? reference.contains(event.target) : true;
      var followCursor = instance.props.followCursor;
      var clientX = event.clientX,
          clientY = event.clientY;
      var rect = reference.getBoundingClientRect();
      var relativeX = clientX - rect.left;
      var relativeY = clientY - rect.top;

      if (isCursorOverReference || !instance.props.interactive) {
        instance.setProps({
          getReferenceClientRect: function getReferenceClientRect() {
            var rect = reference.getBoundingClientRect();
            var x = clientX;
            var y = clientY;

            if (followCursor === 'initial') {
              x = rect.left + relativeX;
              y = rect.top + relativeY;
            }

            var top = followCursor === 'horizontal' ? rect.top : y;
            var right = followCursor === 'vertical' ? rect.right : x;
            var bottom = followCursor === 'horizontal' ? rect.bottom : y;
            var left = followCursor === 'vertical' ? rect.left : x;
            return {
              width: right - left,
              height: bottom - top,
              top: top,
              right: right,
              bottom: bottom,
              left: left
            };
          }
        });
      }
    }

    function create() {
      if (instance.props.followCursor) {
        activeInstances.push({
          instance: instance,
          doc: doc
        });
        addMouseCoordsListener(doc);
      }
    }

    function destroy() {
      activeInstances = activeInstances.filter(function (data) {
        return data.instance !== instance;
      });

      if (activeInstances.filter(function (data) {
        return data.doc === doc;
      }).length === 0) {
        removeMouseCoordsListener(doc);
      }
    }

    return {
      onCreate: create,
      onDestroy: destroy,
      onBeforeUpdate: function onBeforeUpdate() {
        prevProps = instance.props;
      },
      onAfterUpdate: function onAfterUpdate(_, _ref2) {
        var followCursor = _ref2.followCursor;

        if (isInternalUpdate) {
          return;
        }

        if (followCursor !== undefined && prevProps.followCursor !== followCursor) {
          destroy();

          if (followCursor) {
            create();

            if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {
              addListener();
            }
          } else {
            removeListener();
            unsetGetReferenceClientRect();
          }
        }
      },
      onMount: function onMount() {
        if (instance.props.followCursor && !wasFocusEvent) {
          if (isUnmounted) {
            onMouseMove(mouseCoords);
            isUnmounted = false;
          }

          if (!getIsInitialBehavior()) {
            addListener();
          }
        }
      },
      onTrigger: function onTrigger(_, event) {
        if (isMouseEvent(event)) {
          mouseCoords = {
            clientX: event.clientX,
            clientY: event.clientY
          };
        }

        wasFocusEvent = event.type === 'focus';
      },
      onHidden: function onHidden() {
        if (instance.props.followCursor) {
          unsetGetReferenceClientRect();
          removeListener();
          isUnmounted = true;
        }
      }
    };
  }
};

function getProps(props, modifier) {
  var _props$popperOptions;

  return {
    popperOptions: Object.assign({}, props.popperOptions, {
      modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {
        var name = _ref.name;
        return name !== modifier.name;
      }), [modifier])
    })
  };
}

var inlinePositioning = {
  name: 'inlinePositioning',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference;

    function isEnabled() {
      return !!instance.props.inlinePositioning;
    }

    var placement;
    var cursorRectIndex = -1;
    var isInternalUpdate = false;
    var modifier = {
      name: 'tippyInlinePositioning',
      enabled: true,
      phase: 'afterWrite',
      fn: function fn(_ref2) {
        var state = _ref2.state;

        if (isEnabled()) {
          if (placement !== state.placement) {
            instance.setProps({
              getReferenceClientRect: function getReferenceClientRect() {
                return _getReferenceClientRect(state.placement);
              }
            });
          }

          placement = state.placement;
        }
      }
    };

    function _getReferenceClientRect(placement) {
      return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);
    }

    function setInternalProps(partialProps) {
      isInternalUpdate = true;
      instance.setProps(partialProps);
      isInternalUpdate = false;
    }

    function addModifier() {
      if (!isInternalUpdate) {
        setInternalProps(getProps(instance.props, modifier));
      }
    }

    return {
      onCreate: addModifier,
      onAfterUpdate: addModifier,
      onTrigger: function onTrigger(_, event) {
        if (isMouseEvent(event)) {
          var rects = arrayFrom(instance.reference.getClientRects());
          var cursorRect = rects.find(function (rect) {
            return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;
          });
          cursorRectIndex = rects.indexOf(cursorRect);
        }
      },
      onUntrigger: function onUntrigger() {
        cursorRectIndex = -1;
      }
    };
  }
};
function getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {
  // Not an inline element, or placement is not yet known
  if (clientRects.length < 2 || currentBasePlacement === null) {
    return boundingRect;
  } // There are two rects and they are disjoined


  if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {
    return clientRects[cursorRectIndex] || boundingRect;
  }

  switch (currentBasePlacement) {
    case 'top':
    case 'bottom':
      {
        var firstRect = clientRects[0];
        var lastRect = clientRects[clientRects.length - 1];
        var isTop = currentBasePlacement === 'top';
        var top = firstRect.top;
        var bottom = lastRect.bottom;
        var left = isTop ? firstRect.left : lastRect.left;
        var right = isTop ? firstRect.right : lastRect.right;
        var width = right - left;
        var height = bottom - top;
        return {
          top: top,
          bottom: bottom,
          left: left,
          right: right,
          width: width,
          height: height
        };
      }

    case 'left':
    case 'right':
      {
        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {
          return rects.left;
        }));
        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {
          return rects.right;
        }));
        var measureRects = clientRects.filter(function (rect) {
          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;
        });
        var _top = measureRects[0].top;
        var _bottom = measureRects[measureRects.length - 1].bottom;
        var _left = minLeft;
        var _right = maxRight;

        var _width = _right - _left;

        var _height = _bottom - _top;

        return {
          top: _top,
          bottom: _bottom,
          left: _left,
          right: _right,
          width: _width,
          height: _height
        };
      }

    default:
      {
        return boundingRect;
      }
  }
}

var sticky = {
  name: 'sticky',
  defaultValue: false,
  fn: function fn(instance) {
    var reference = instance.reference,
        popper = instance.popper;

    function getReference() {
      return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;
    }

    function shouldCheck(value) {
      return instance.props.sticky === true || instance.props.sticky === value;
    }

    var prevRefRect = null;
    var prevPopRect = null;

    function updatePosition() {
      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;
      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;

      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {
        if (instance.popperInstance) {
          instance.popperInstance.update();
        }
      }

      prevRefRect = currentRefRect;
      prevPopRect = currentPopRect;

      if (instance.state.isMounted) {
        requestAnimationFrame(updatePosition);
      }
    }

    return {
      onMount: function onMount() {
        if (instance.props.sticky) {
          updatePosition();
        }
      }
    };
  }
};

function areRectsDifferent(rectA, rectB) {
  if (rectA && rectB) {
    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;
  }

  return true;
}

tippy.setDefaultProps({
  render: render
});

exports.animateFill = animateFill;
exports.createSingleton = createSingleton;
exports.default = tippy;
exports.delegate = delegate;
exports.followCursor = followCursor;
exports.hideAll = hideAll;
exports.inlinePositioning = inlinePositioning;
exports.roundArrow = ROUND_ARROW;
exports.sticky = sticky;


},{"@popperjs/core":65}],233:[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports["vue-js-modal"]=e():t["vue-js-modal"]=e()}(window,function(){return i={},o.m=n=[function(t,e,n){var i=n(7);"string"==typeof i&&(i=[[t.i,i,""]]),i.locals&&(t.exports=i.locals);(0,n(4).default)("d763679c",i,!1,{})},function(t,e,n){var i=n(10);"string"==typeof i&&(i=[[t.i,i,""]]),i.locals&&(t.exports=i.locals);(0,n(4).default)("6b9cc0e0",i,!1,{})},function(t,e,n){var i=n(12);"string"==typeof i&&(i=[[t.i,i,""]]),i.locals&&(t.exports=i.locals);(0,n(4).default)("663c004e",i,!1,{})},function(t,e){t.exports=function(n){var a=[];return a.toString=function(){return this.map(function(t){var e=function(t,e){var n=t[1]||"",i=t[3];if(!i)return n;if(e&&"function"==typeof btoa){var o=function(t){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(t))))+" */"}(i),r=i.sources.map(function(t){return"/*# sourceURL="+i.sourceRoot+t+" */"});return[n].concat(r).concat([o]).join("\n")}return[n].join("\n")}(t,n);return t[2]?"@media "+t[2]+"{"+e+"}":e}).join("")},a.i=function(t,e){"string"==typeof t&&(t=[[null,t,""]]);for(var n={},i=0;i<this.length;i++){var o=this[i][0];"number"==typeof o&&(n[o]=!0)}for(i=0;i<t.length;i++){var r=t[i];"number"==typeof r[0]&&n[r[0]]||(e&&!r[2]?r[2]=e:e&&(r[2]="("+r[2]+") and ("+e+")"),a.push(r))}},a}},function(t,e,n){"use strict";function l(t,e){for(var n=[],i={},o=0;o<e.length;o++){var r=e[o],a=r[0],s={id:t+":"+o,css:r[1],media:r[2],sourceMap:r[3]};i[a]?i[a].parts.push(s):n.push(i[a]={id:a,parts:[s]})}return n}n.r(e),n.d(e,"default",function(){return p});var i="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var u={},o=i&&(document.head||document.getElementsByTagName("head")[0]),r=null,a=0,c=!1,s=function(){},d=null,h="data-vue-ssr-id",f="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function p(a,t,e,n){c=e,d=n||{};var s=l(a,t);return v(s),function(t){for(var e=[],n=0;n<s.length;n++){var i=s[n];(o=u[i.id]).refs--,e.push(o)}t?v(s=l(a,t)):s=[];for(n=0;n<e.length;n++){var o;if(0===(o=e[n]).refs){for(var r=0;r<o.parts.length;r++)o.parts[r]();delete u[o.id]}}}}function v(t){for(var e=0;e<t.length;e++){var n=t[e],i=u[n.id];if(i){i.refs++;for(var o=0;o<i.parts.length;o++)i.parts[o](n.parts[o]);for(;o<n.parts.length;o++)i.parts.push(b(n.parts[o]));i.parts.length>n.parts.length&&(i.parts.length=n.parts.length)}else{var r=[];for(o=0;o<n.parts.length;o++)r.push(b(n.parts[o]));u[n.id]={id:n.id,refs:1,parts:r}}}}function m(){var t=document.createElement("style");return t.type="text/css",o.appendChild(t),t}function b(e){var n,i,t=document.querySelector("style["+h+'~="'+e.id+'"]');if(t){if(c)return s;t.parentNode.removeChild(t)}if(f){var o=a++;t=r=r||m(),n=w.bind(null,t,o,!1),i=w.bind(null,t,o,!0)}else t=m(),n=function(t,e){var n=e.css,i=e.media,o=e.sourceMap;i&&t.setAttribute("media",i);d.ssrId&&t.setAttribute(h,e.id);o&&(n+="\n/*# sourceURL="+o.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(o))))+" */");if(t.styleSheet)t.styleSheet.cssText=n;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(n))}}.bind(null,t),i=function(){t.parentNode.removeChild(t)};return n(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;n(e=t)}else i()}}var y,g=(y=[],function(t,e){return y[t]=e,y.filter(Boolean).join("\n")});function w(t,e,n,i){var o=n?"":i.css;if(t.styleSheet)t.styleSheet.cssText=g(e,o);else{var r=document.createTextNode(o),a=t.childNodes;a[e]&&t.removeChild(a[e]),a.length?t.insertBefore(r,a[e]):t.appendChild(r)}}},function(t,M,e){"use strict";(function(t){var i=function(){if("undefined"!=typeof Map)return Map;function i(t,n){var i=-1;return t.some(function(t,e){return t[0]===n&&(i=e,!0)}),i}return Object.defineProperty(t.prototype,"size",{get:function(){return this.__entries__.length},enumerable:!0,configurable:!0}),t.prototype.get=function(t){var e=i(this.__entries__,t),n=this.__entries__[e];return n&&n[1]},t.prototype.set=function(t,e){var n=i(this.__entries__,t);~n?this.__entries__[n][1]=e:this.__entries__.push([t,e])},t.prototype.delete=function(t){var e=this.__entries__,n=i(e,t);~n&&e.splice(n,1)},t.prototype.has=function(t){return!!~i(this.__entries__,t)},t.prototype.clear=function(){this.__entries__.splice(0)},t.prototype.forEach=function(t,e){void 0===e&&(e=null);for(var n=0,i=this.__entries__;n<i.length;n++){var o=i[n];t.call(e,o[1],o[0])}},t;function t(){this.__entries__=[]}}(),n="undefined"!=typeof window&&"undefined"!=typeof document&&window.document===document,e=void 0!==t&&t.Math===Math?t:"undefined"!=typeof self&&self.Math===Math?self:"undefined"!=typeof window&&window.Math===Math?window:Function("return this")(),l="function"==typeof requestAnimationFrame?requestAnimationFrame.bind(e):function(t){return setTimeout(function(){return t(Date.now())},1e3/60)},u=2;var o=["top","right","bottom","left","width","height","size","weight"],r="undefined"!=typeof MutationObserver,a=(s.prototype.addObserver=function(t){~this.observers_.indexOf(t)||this.observers_.push(t),this.connected_||this.connect_()},s.prototype.removeObserver=function(t){var e=this.observers_,n=e.indexOf(t);~n&&e.splice(n,1),!e.length&&this.connected_&&this.disconnect_()},s.prototype.refresh=function(){this.updateObservers_()&&this.refresh()},s.prototype.updateObservers_=function(){var t=this.observers_.filter(function(t){return t.gatherActive(),t.hasActive()});return t.forEach(function(t){return t.broadcastActive()}),0<t.length},s.prototype.connect_=function(){n&&!this.connected_&&(document.addEventListener("transitionend",this.onTransitionEnd_),window.addEventListener("resize",this.refresh),r?(this.mutationsObserver_=new MutationObserver(this.refresh),this.mutationsObserver_.observe(document,{attributes:!0,childList:!0,characterData:!0,subtree:!0})):(document.addEventListener("DOMSubtreeModified",this.refresh),this.mutationEventsAdded_=!0),this.connected_=!0)},s.prototype.disconnect_=function(){n&&this.connected_&&(document.removeEventListener("transitionend",this.onTransitionEnd_),window.removeEventListener("resize",this.refresh),this.mutationsObserver_&&this.mutationsObserver_.disconnect(),this.mutationEventsAdded_&&document.removeEventListener("DOMSubtreeModified",this.refresh),this.mutationsObserver_=null,this.mutationEventsAdded_=!1,this.connected_=!1)},s.prototype.onTransitionEnd_=function(t){var e=t.propertyName,n=void 0===e?"":e;o.some(function(t){return!!~n.indexOf(t)})&&this.refresh()},s.getInstance=function(){return this.instance_||(this.instance_=new s),this.instance_},s.instance_=null,s);function s(){function t(){r&&(r=!1,i()),a&&n()}function e(){l(t)}function n(){var t=Date.now();if(r){if(t-s<u)return;a=!0}else a=!(r=!0),setTimeout(e,o);s=t}var i,o,r,a,s;this.connected_=!1,this.mutationEventsAdded_=!1,this.mutationsObserver_=null,this.observers_=[],this.onTransitionEnd_=this.onTransitionEnd_.bind(this),this.refresh=(i=this.refresh.bind(this),a=r=!(o=20),s=0,n)}var c=function(t,e){for(var n=0,i=Object.keys(e);n<i.length;n++){var o=i[n];Object.defineProperty(t,o,{value:e[o],enumerable:!1,writable:!1,configurable:!0})}return t},h=function(t){return t&&t.ownerDocument&&t.ownerDocument.defaultView||e},f=y(0,0,0,0);function p(t){return parseFloat(t)||0}function v(n){for(var t=[],e=1;e<arguments.length;e++)t[e-1]=arguments[e];return t.reduce(function(t,e){return t+p(n["border-"+e+"-width"])},0)}function d(t){var e=t.clientWidth,n=t.clientHeight;if(!e&&!n)return f;var i,o=h(t).getComputedStyle(t),r=function(t){for(var e={},n=0,i=["top","right","bottom","left"];n<i.length;n++){var o=i[n],r=t["padding-"+o];e[o]=p(r)}return e}(o),a=r.left+r.right,s=r.top+r.bottom,l=p(o.width),u=p(o.height);if("border-box"===o.boxSizing&&(Math.round(l+a)!==e&&(l-=v(o,"left","right")+a),Math.round(u+s)!==n&&(u-=v(o,"top","bottom")+s)),(i=t)!==h(i).document.documentElement){var c=Math.round(l+a)-e,d=Math.round(u+s)-n;1!==Math.abs(c)&&(l-=c),1!==Math.abs(d)&&(u-=d)}return y(r.left,r.top,l,u)}var m="undefined"!=typeof SVGGraphicsElement?function(t){return t instanceof h(t).SVGGraphicsElement}:function(t){return t instanceof h(t).SVGElement&&"function"==typeof t.getBBox};function b(t){return n?m(t)?y(0,0,(e=t.getBBox()).width,e.height):d(t):f;var e}function y(t,e,n,i){return{x:t,y:e,width:n,height:i}}var g=(w.prototype.isActive=function(){var t=b(this.target);return(this.contentRect_=t).width!==this.broadcastWidth||t.height!==this.broadcastHeight},w.prototype.broadcastRect=function(){var t=this.contentRect_;return this.broadcastWidth=t.width,this.broadcastHeight=t.height,t},w);function w(t){this.broadcastWidth=0,this.broadcastHeight=0,this.contentRect_=y(0,0,0,0),this.target=t}var _=function(t,e){var n,i,o,r,a,s,l,u=(i=(n=e).x,o=n.y,r=n.width,a=n.height,s="undefined"!=typeof DOMRectReadOnly?DOMRectReadOnly:Object,l=Object.create(s.prototype),c(l,{x:i,y:o,width:r,height:a,top:o,right:i+r,bottom:a+o,left:i}),l);c(this,{target:t,contentRect:u})},E=(x.prototype.observe=function(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!=typeof Element&&Element instanceof Object){if(!(t instanceof h(t).Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observations_;e.has(t)||(e.set(t,new g(t)),this.controller_.addObserver(this),this.controller_.refresh())}},x.prototype.unobserve=function(t){if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");if("undefined"!=typeof Element&&Element instanceof Object){if(!(t instanceof h(t).Element))throw new TypeError('parameter 1 is not of type "Element".');var e=this.observations_;e.has(t)&&(e.delete(t),e.size||this.controller_.removeObserver(this))}},x.prototype.disconnect=function(){this.clearActive(),this.observations_.clear(),this.controller_.removeObserver(this)},x.prototype.gatherActive=function(){var e=this;this.clearActive(),this.observations_.forEach(function(t){t.isActive()&&e.activeObservations_.push(t)})},x.prototype.broadcastActive=function(){if(this.hasActive()){var t=this.callbackCtx_,e=this.activeObservations_.map(function(t){return new _(t.target,t.broadcastRect())});this.callback_.call(t,e,t),this.clearActive()}},x.prototype.clearActive=function(){this.activeObservations_.splice(0)},x.prototype.hasActive=function(){return 0<this.activeObservations_.length},x);function x(t,e,n){if(this.activeObservations_=[],this.observations_=new i,"function"!=typeof t)throw new TypeError("The callback provided as parameter 1 is not a function.");this.callback_=t,this.controller_=e,this.callbackCtx_=n}var T=new("undefined"!=typeof WeakMap?WeakMap:i),O=function t(e){if(!(this instanceof t))throw new TypeError("Cannot call a class as a function.");if(!arguments.length)throw new TypeError("1 argument required, but only 0 present.");var n=a.getInstance(),i=new E(e,n,this);T.set(this,i)};["observe","unobserve","disconnect"].forEach(function(e){O.prototype[e]=function(){var t;return(t=T.get(this))[e].apply(t,arguments)}});var S=void 0!==e.ResizeObserver?e.ResizeObserver:O;M.a=S}).call(this,e(8))},function(t,e,n){"use strict";var i=n(0);n.n(i).a},function(t,e,n){(t.exports=n(3)(!1)).push([t.i,"\n.vue-modal-resizer {\n  display: block;\n  overflow: hidden;\n  position: absolute;\n  width: 12px;\n  height: 12px;\n  right: 0;\n  bottom: 0;\n  z-index: 9999999;\n  background: transparent;\n  cursor: se-resize;\n}\n.vue-modal-resizer::after {\n  display: block;\n  position: absolute;\n  content: '';\n  background: transparent;\n  left: 0;\n  top: 0;\n  width: 0;\n  height: 0;\n  border-bottom: 10px solid #ddd;\n  border-left: 10px solid transparent;\n}\n.vue-modal-resizer.clicked::after {\n  border-bottom: 10px solid #369be9;\n}\n",""])},function(t,e){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(t){"object"==typeof window&&(n=window)}t.exports=n},function(t,e,n){"use strict";var i=n(1);n.n(i).a},function(t,e,n){(t.exports=n(3)(!1)).push([t.i,"\n.vm--block-scroll {\n  overflow: hidden;\n  width: 100vw;\n}\n.vm--container {\n  position: fixed;\n  box-sizing: border-box;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100vh;\n  z-index: 999;\n}\n.vm--overlay {\n  position: fixed;\n  box-sizing: border-box;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100vh;\n  background: rgba(0, 0, 0, 0.2);\n  /* z-index: 999; */\n  opacity: 1;\n}\n.vm--container.scrollable {\n  height: 100%;\n  min-height: 100vh;\n  overflow-y: auto;\n  -webkit-overflow-scrolling: touch;\n}\n.vm--modal {\n  position: relative;\n  overflow: hidden;\n  box-sizing: border-box;\n\n  background-color: white;\n  border-radius: 3px;\n  box-shadow: 0 20px 60px -2px rgba(27, 33, 58, 0.4);\n}\n.vm--container.scrollable .vm--modal {\n  margin-bottom: 2px;\n}\n.vm--top-right-slot {\n  display: block;\n  position: absolute;\n  right: 0;\n  top: 0;\n}\n.vm-transition--overlay-enter-active,\n.vm-transition--overlay-leave-active {\n  transition: all 50ms;\n}\n.vm-transition--overlay-enter,\n.vm-transition--overlay-leave-active {\n  opacity: 0;\n}\n.vm-transition--modal-enter-active,\n.vm-transition--modal-leave-active {\n  transition: all 400ms;\n}\n.vm-transition--modal-enter,\n.vm-transition--modal-leave-active {\n  opacity: 0;\n  transform: translateY(-20px);\n}\n.vm-transition--default-enter-active,\n.vm-transition--default-leave-active {\n  transition: all 2ms;\n}\n.vm-transition--default-enter,\n.vm-transition--default-leave-active {\n  opacity: 0;\n}\n",""])},function(t,e,n){"use strict";var i=n(2);n.n(i).a},function(t,e,n){(t.exports=n(3)(!1)).push([t.i,"\n.vue-dialog {\n  font-size: 14px;\n}\n.vue-dialog div {\n  box-sizing: border-box;\n}\n.vue-dialog-content {\n  flex: 1 0 auto;\n  width: 100%;\n  padding: 14px;\n}\n.vue-dialog-content-title {\n  font-weight: 600;\n  padding-bottom: 14px;\n}\n.vue-dialog-buttons {\n  display: flex;\n  flex: 0 1 auto;\n  width: 100%;\n  border-top: 1px solid #eee;\n}\n.vue-dialog-buttons-none {\n  width: 100%;\n  padding-bottom: 14px;\n}\n.vue-dialog-button {\n  font-size: inherit;\n  background: transparent;\n  padding: 0;\n  margin: 0;\n  border: 0;\n  cursor: pointer;\n  box-sizing: border-box;\n  line-height: 40px;\n  height: 40px;\n  color: inherit;\n  font: inherit;\n  outline: none;\n}\n.vue-dialog-button:hover {\n  background: #f9f9f9;\n}\n.vue-dialog-button:active {\n  background: #f3f3f3;\n}\n.vue-dialog-button:not(:first-of-type) {\n  border-left: 1px solid #eee;\n}\n",""])},function(t,e,n){"use strict";n.r(e),n.d(e,"Modal",function(){return W}),n.d(e,"Dialog",function(){return U}),n.d(e,"version",function(){return J});function i(){var e=this,t=e.$createElement,n=e._self._c||t;return e.visible?n("div",{class:e.containerClass},[n("transition",{attrs:{name:e.guaranteedOverlayTransition},on:{"before-enter":e.beforeOverlayTransitionEnter,"after-enter":e.afterOverlayTransitionEnter,"before-leave":e.beforeOverlayTransitionLeave,"after-leave":e.afterOverlayTransitionLeave}},[e.visibility.overlay?n("div",{staticClass:"vm--overlay",attrs:{"data-modal":e.name,"aria-expanded":e.visibility.overlay.toString()},on:{click:function(t){return t.target!==t.currentTarget?null:(t.stopPropagation(),e.onOverlayClick(t))}}},[n("div",{staticClass:"vm--top-right-slot"},[e._t("top-right")],2)]):e._e()]),e._v(" "),n("transition",{attrs:{name:e.guaranteedModalTransition},on:{"before-enter":e.beforeModalTransitionEnter,"after-enter":e.afterModalTransitionEnter,"before-leave":e.beforeModalTransitionLeave,"after-leave":e.afterModalTransitionLeave}},[e.visibility.modal?n("div",{ref:"modal",class:e.modalClass,style:e.modalStyle,attrs:{"aria-expanded":e.visibility.modal.toString(),role:"dialog","aria-modal":"true"}},[e._t("default"),e._v(" "),e.resizable&&!e.isAutoHeight?n("resizer",{attrs:{"min-width":e.minWidth,"min-height":e.minHeight,"max-width":e.maxWidth,"max-height":e.maxHeight},on:{resize:e.onModalResize}}):e._e()],2):e._e()])],1):e._e()}function o(){var t=this.$createElement;return(this._self._c||t)("div",{class:this.className})}o._withStripped=i._withStripped=!0;function h(t,e,n){return n<t?t:e<n?e:n}function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function a(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=[],i=!0,o=!1,r=void 0;try{for(var a,s=t[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);i=!0);}catch(t){o=!0,r=t}finally{try{i||null==s.return||s.return()}finally{if(o)throw r}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}function s(){var t=window.innerWidth,e=document.documentElement.clientWidth;return t&&e?Math.min(t,e):e||t}function l(t){return t.split(";").map(function(t){return t.trim()}).filter(Boolean).map(function(t){return t.split(":")}).reduce(function(t,e){var n=a(e,2);return function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},i=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),i.forEach(function(t){r(e,t,n[t])})}return e}({},t,r({},n[0],n[1]))},{})}function f(t){return t.touches&&0<t.touches.length?t.touches[0]:t}var p=["INPUT","TEXTAREA","SELECT"],c=function(t){var e=0<arguments.length&&void 0!==t?t:0;return function(){return(e++).toString()}}(),u={name:"VueJsModalResizer",props:{minHeight:{type:Number,default:0},minWidth:{type:Number,default:0},maxWidth:{type:Number,default:Number.MAX_SAFE_INTEGER},maxHeight:{type:Number,default:Number.MAX_SAFE_INTEGER}},data:function(){return{clicked:!1,size:{}}},mounted:function(){this.$el.addEventListener("mousedown",this.start,!1)},computed:{className:function(){return["vue-modal-resizer",{clicked:this.clicked}]}},methods:{start:function(t){this.clicked=!0,window.addEventListener("mousemove",this.mousemove,!1),window.addEventListener("mouseup",this.stop,!1),t.stopPropagation(),t.preventDefault()},stop:function(){this.clicked=!1,window.removeEventListener("mousemove",this.mousemove,!1),window.removeEventListener("mouseup",this.stop,!1),this.$emit("resize-stop",{element:this.$el.parentElement,size:this.size})},mousemove:function(t){this.resize(t)},resize:function(t){var e=this.$el.parentElement;if(e){var n=t.clientX-e.offsetLeft,i=t.clientY-e.offsetTop,o=Math.min(s(),this.maxWidth),r=Math.min(window.innerHeight,this.maxHeight);n=h(this.minWidth,o,n),i=h(this.minHeight,r,i),this.size={width:n,height:i},e.style.width=n+"px",e.style.height=i+"px",this.$emit("resize",{element:e,size:this.size})}}}};n(6);function d(t,e,n,i,o,r,a,s){var l,u="function"==typeof t?t.options:t;if(e&&(u.render=e,u.staticRenderFns=n,u._compiled=!0),i&&(u.functional=!0),r&&(u._scopeId="data-v-"+r),a?(l=function(t){(t=t||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(t=__VUE_SSR_CONTEXT__),o&&o.call(this,t),t&&t._registeredComponents&&t._registeredComponents.add(a)},u._ssrRegister=l):o&&(l=s?function(){o.call(this,this.$root.$options.shadowRoot)}:o),l)if(u.functional){u._injectStyles=l;var c=u.render;u.render=function(t,e){return l.call(e),c(t,e)}}else{var d=u.beforeCreate;u.beforeCreate=d?[].concat(d,l):[l]}return{exports:t,options:u}}var v=d(u,o,[],!1,null,null,null);v.options.__file="src/components/Resizer.vue";var m=v.exports;function b(t){return(b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function y(t){switch(b(t)){case"number":return{type:"px",value:t};case"string":return function(e){if("auto"===e)return{type:e,value:0};var t=_.find(function(t){return t.regexp.test(e)});return t?{type:t.name,value:parseFloat(e)}:{type:"",value:e}}(t);default:return{type:"",value:t}}}function g(t){if("string"!=typeof t)return 0<=t;var e=y(t);return("%"===e.type||"px"===e.type)&&0<e.value}var w="[-+]?[0-9]*.?[0-9]+",_=[{name:"px",regexp:new RegExp("^".concat(w,"px$"))},{name:"%",regexp:new RegExp("^".concat(w,"%$"))},{name:"px",regexp:new RegExp("^".concat(w,"$"))}],E=n(5),x="undefined"!=typeof window&&window.ResizeObserver?ResizeObserver:E.a;function T(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function O(t){return function(t){if(Array.isArray(t)){for(var e=0,n=new Array(t.length);e<t.length;e++)n[e]=t[e];return n}}(t)||function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function S(t){return e='button:not([disabled]), select:not([disabled]), a[href]:not([disabled]), area[href]:not([disabled]), [contentEditable=""]:not([disabled]), [contentEditable="true"]:not([disabled]), [contentEditable="TRUE"]:not([disabled]), textarea:not([disabled]), iframe:not([disabled]), input:not([disabled]), summary:not([disabled]), [tabindex]:not([tabindex="-1"])',O(t.querySelectorAll(e)||[]);var e}function M(t){return t==document.activeElement}var k=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.root=null,this.elements=[],this.onKeyDown=this.onKeyDown.bind(this),this.enable=this.enable.bind(this),this.disable=this.disable.bind(this),this.firstElement=this.firstElement.bind(this),this.lastElement=this.lastElement.bind(this)}var e,n,i;return e=t,(n=[{key:"lastElement",value:function(){return this.elements[this.elements.length-1]||null}},{key:"firstElement",value:function(){return this.elements[0]||null}},{key:"onKeyDown",value:function(t){var e;if("Tab"===(e=t).key||9===e.keyCode)return t.shiftKey&&M(this.firstElement())?(this.lastElement().focus(),void t.preventDefault()):!document.activeElement||M(this.lastElement())?(this.firstElement().focus(),void t.preventDefault()):void 0}},{key:"enabled",value:function(){return!!this.root}},{key:"enable",value:function(t){if(t){this.root=t,this.elements=S(this.root);var e=this.firstElement();e&&e.focus(),this.root.addEventListener("keydown",this.onKeyDown)}}},{key:"disable",value:function(){this.root.removeEventListener("keydown",this.onKeyDown),this.root=null}}])&&T(e.prototype,n),i&&T(e,i),t}();function L(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function z(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var n=[],i=!0,o=!1,r=void 0;try{for(var a,s=t[Symbol.iterator]();!(i=(a=s.next()).done)&&(n.push(a.value),!e||n.length!==e);i=!0);}catch(t){o=!0,r=t}finally{try{i||null==s.return||s.return()}finally{if(o)throw r}}return n}(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}var $="vm-transition--default",A="enter",C="entering",j="leave",R="leavng",H={name:"VueJsModal",props:{name:{required:!0,type:String},resizable:{type:Boolean,default:!1},adaptive:{type:Boolean,default:!1},draggable:{type:[Boolean,String],default:!1},scrollable:{type:Boolean,default:!1},focusTrap:{type:Boolean,default:!1},reset:{type:Boolean,default:!1},overlayTransition:{type:String,default:"vm-transition--overlay"},transition:{type:String,default:"vm-transition--modal"},clickToClose:{type:Boolean,default:!0},classes:{type:[String,Array],default:function(){return[]}},styles:{type:[String,Array,Object]},minWidth:{type:Number,default:0,validator:function(t){return 0<=t}},minHeight:{type:Number,default:0,validator:function(t){return 0<=t}},maxWidth:{type:Number,default:Number.MAX_SAFE_INTEGER},maxHeight:{type:Number,default:Number.MAX_SAFE_INTEGER},width:{type:[Number,String],default:600,validator:g},height:{type:[Number,String],default:300,validator:function(t){return"auto"===t||g(t)}},shiftX:{type:Number,default:.5,validator:function(t){return 0<=t&&t<=1}},shiftY:{type:Number,default:.5,validator:function(t){return 0<=t&&t<=1}}},components:{Resizer:m},data:function(){return{visible:!1,visibility:{modal:!1,overlay:!1},overlayTransitionState:null,modalTransitionState:null,shiftLeft:0,shiftTop:0,modal:{width:0,widthType:"px",height:0,heightType:"px",renderedHeight:0},viewportHeight:0,viewportWidth:0}},created:function(){this.setInitialSize()},beforeMount:function(){this.$modal.subscription.$on("toggle",this.onToggle),window.addEventListener("resize",this.onWindowResize),window.addEventListener("orientationchange",this.onWindowResize),this.onWindowResize(),this.scrollable&&!this.isAutoHeight&&console.warn('Modal "'.concat(this.name,'" has scrollable flag set to true ')+'but height is not "auto" ('.concat(this.height,")")),this.clickToClose&&window.addEventListener("keyup",this.onEscapeKeyUp)},mounted:function(){var n=this;this.resizeObserver=new x(function(t){if(0<t.length){var e=z(t,1)[0];n.modal.renderedHeight=e.contentRect.height}}),this.$focusTrap=new k},beforeDestroy:function(){this.$modal.subscription.$off("toggle",this.onToggle),window.removeEventListener("resize",this.onWindowResize),window.removeEventListener("orientationchange",this.onWindowResize),this.clickToClose&&window.removeEventListener("keyup",this.onEscapeKeyUp),document.body.classList.remove("vm--block-scroll")},computed:{guaranteedOverlayTransition:function(){return this.overlayTransition||$},guaranteedModalTransition:function(){return this.transition||$},isAutoHeight:function(){return"auto"===this.modal.heightType},position:function(){var t=this.viewportHeight,e=this.viewportWidth,n=this.shiftLeft,i=this.shiftTop,o=this.shiftX,r=this.shiftY,a=this.trueModalWidth,s=this.trueModalHeight,l=e-a,u=Math.max(t-s,0),c=i+r*u;return{left:parseInt(h(0,l,n+o*l)),top:!s&&this.isAutoHeight?void 0:parseInt(h(0,u,c))}},trueModalWidth:function(){var t=this.viewportWidth,e=this.modal,n=this.adaptive,i=this.minWidth,o=this.maxWidth,r="%"===e.widthType?t/100*e.width:e.width;if(n){var a=Math.max(i,Math.min(t,o));return h(i,a,r)}return r},trueModalHeight:function(){var t=this.viewportHeight,e=this.modal,n=this.isAutoHeight,i=this.adaptive,o=this.minHeight,r=this.maxHeight,a="%"===e.heightType?t/100*e.height:e.height;if(n)return this.modal.renderedHeight;if(i){var s=Math.max(o,Math.min(t,r));return h(o,s,a)}return a},autoHeight:function(){return this.adaptive&&this.modal.renderedHeight>=this.viewportHeight?Math.max(this.minHeight,this.viewportHeight)+"px":"auto"},containerClass:function(){return["vm--container",this.scrollable&&this.isAutoHeight&&"scrollable"]},modalClass:function(){return["vm--modal",this.classes]},stylesProp:function(){return"string"==typeof this.styles?l(this.styles):this.styles},modalStyle:function(){return[this.stylesProp,{top:this.position.top+"px",left:this.position.left+"px",width:this.trueModalWidth+"px",height:this.isAutoHeight?this.autoHeight:this.trueModalHeight+"px"}]},isComponentReadyToBeDestroyed:function(){return this.overlayTransitionState===j&&this.modalTransitionState===j}},watch:{isComponentReadyToBeDestroyed:function(t){t&&(this.visible=!1)}},methods:{startTransitionEnter:function(){this.visibility.overlay=!0,this.visibility.modal=!0},startTransitionLeave:function(){this.visibility.overlay=!1,this.visibility.modal=!1},beforeOverlayTransitionEnter:function(){this.overlayTransitionState=C},afterOverlayTransitionEnter:function(){this.overlayTransitionState=A},beforeOverlayTransitionLeave:function(){this.overlayTransitionState=R},afterOverlayTransitionLeave:function(){this.overlayTransitionState=j},beforeModalTransitionEnter:function(){var t=this;this.modalTransitionState=C,this.$nextTick(function(){t.resizeObserver.observe(t.$refs.modal)})},afterModalTransitionEnter:function(){this.modalTransitionState=A,this.draggable&&this.addDraggableListeners(),this.focusTrap&&this.$focusTrap.enable(this.$refs.modal);var t=this.createModalEvent({state:"opened"});this.$emit("opened",t)},beforeModalTransitionLeave:function(){this.modalTransitionState=R,this.resizeObserver.unobserve(this.$refs.modal),this.$focusTrap.enabled()&&this.$focusTrap.disable()},afterModalTransitionLeave:function(){this.modalTransitionState=j;var t=this.createModalEvent({state:"closed"});this.$emit("closed",t)},onToggle:function(t,e,n){if(this.name===t){var i=void 0===e?!this.visible:e;this.toggle(i,n)}},setInitialSize:function(){var t=y(this.width),e=y(this.height);this.modal.width=t.value,this.modal.widthType=t.type,this.modal.height=e.value,this.modal.heightType=e.type},onEscapeKeyUp:function(t){27===t.which&&this.visible&&this.$modal.hide(this.name)},onWindowResize:function(){this.viewportWidth=s(),this.viewportHeight=window.innerHeight,this.ensureShiftInWindowBounds()},createModalEvent:function(t){var e=0<arguments.length&&void 0!==t?t:{};return function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},i=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),i.forEach(function(t){L(e,t,n[t])})}return e}({name:this.name,ref:this.$refs.modal||null},e)},onModalResize:function(t){this.modal.widthType="px",this.modal.width=t.size.width,this.modal.heightType="px",this.modal.height=t.size.height;var e=this.modal.size;this.$emit("resize",this.createModalEvent({size:e}))},open:function(t){var e=this;this.reset&&(this.setInitialSize(),this.shiftLeft=0,this.shiftTop=0),this.scrollable&&document.body.classList.add("vm--block-scroll");var n=!1,i=this.createModalEvent({cancel:function(){n=!0},state:"before-open",params:t});this.$emit("before-open",i),n?this.scrollable&&document.body.classList.remove("vm--block-scroll"):("undefined"!=typeof document&&document.activeElement&&"BODY"!==document.activeElement.tagName&&document.activeElement.blur&&document.activeElement.blur(),this.visible=!0,this.$nextTick(function(){e.startTransitionEnter()}))},close:function(t){this.scrollable&&document.body.classList.remove("vm--block-scroll");var e=!1,n=this.createModalEvent({cancel:function(){e=!0},state:"before-close",params:t});this.$emit("before-close",n),e||this.startTransitionLeave()},toggle:function(t,e){this.visible!==t&&(t?this.open(e):this.close(e))},getDraggableElement:function(){return!0===this.draggable?this.$refs.modal:"string"==typeof this.draggable?this.$refs.modal.querySelector(this.draggable):null},onOverlayClick:function(){this.clickToClose&&this.toggle(!1)},addDraggableListeners:function(){var a=this,t=this.getDraggableElement();if(t){var s=0,l=0,u=0,c=0,e=function(t){var e=t.target;if(!(n=e)||-1===p.indexOf(n.nodeName)){var n,i=f(t),o=i.clientX,r=i.clientY;document.addEventListener("mousemove",d),document.addEventListener("touchmove",d),document.addEventListener("mouseup",h),document.addEventListener("touchend",h),s=o,l=r,u=a.shiftLeft,c=a.shiftTop}},d=function(t){var e=f(t),n=e.clientX,i=e.clientY;a.shiftLeft=u+n-s,a.shiftTop=c+i-l,t.preventDefault()},h=function t(e){a.ensureShiftInWindowBounds(),document.removeEventListener("mousemove",d),document.removeEventListener("touchmove",d),document.removeEventListener("mouseup",t),document.removeEventListener("touchend",t),e.preventDefault()};t.addEventListener("mousedown",e),t.addEventListener("touchstart",e)}},ensureShiftInWindowBounds:function(){var t=this.viewportHeight,e=this.viewportWidth,n=this.shiftLeft,i=this.shiftTop,o=this.shiftX,r=this.shiftY,a=this.trueModalWidth,s=this.trueModalHeight,l=e-a,u=Math.max(t-s,0),c=n+o*l,d=i+r*u;this.shiftLeft-=c-h(0,l,c),this.shiftTop-=d-h(0,u,d)}}},N=(n(9),d(H,i,[],!1,null,null,null));N.options.__file="src/components/Modal.vue";function D(){var n=this,t=n.$createElement,i=n._self._c||t;return i(n.$modal.context.componentName,{tag:"component",attrs:{name:"dialog",height:"auto",classes:["vue-dialog",this.params.class],width:n.width,"shift-y":.3,adaptive:!0,"focus-trap":!0,clickToClose:n.clickToClose,transition:n.transition},on:{"before-open":n.beforeOpened,"before-close":n.beforeClosed,opened:function(t){return n.$emit("opened",t)},closed:function(t){return n.$emit("closed",t)}}},[i("div",{staticClass:"vue-dialog-content"},[n.params.title?i("div",{staticClass:"vue-dialog-content-title",domProps:{innerHTML:n._s(n.params.title||"")}}):n._e(),n._v(" "),n.params.component?i(n.params.component,n._b({tag:"component"},"component",n.params.props,!1)):i("div",{domProps:{innerHTML:n._s(n.params.text||"")}})],1),n._v(" "),n.buttons?i("div",{staticClass:"vue-dialog-buttons"},n._l(n.buttons,function(t,e){return i("button",{key:e,class:t.class||"vue-dialog-button",style:n.buttonStyle,attrs:{type:"button",tabindex:"0"},domProps:{innerHTML:n._s(t.title)},on:{click:function(t){return t.stopPropagation(),n.click(e,t)}}},[n._v(n._s(t.title))])}),0):i("div",{staticClass:"vue-dialog-buttons-none"})])}var W=N.exports;D._withStripped=!0;var P={name:"VueJsDialog",props:{width:{type:[Number,String],default:400},clickToClose:{type:Boolean,default:!0},transition:{type:String}},data:function(){return{params:{}}},computed:{buttons:function(){return this.params.buttons||[]},buttonStyle:function(){return{flex:"1 1 ".concat(100/this.buttons.length,"%")}}},methods:{beforeOpened:function(t){this.params=t.params||{},this.$emit("before-opened",t)},beforeClosed:function(t){this.params={},this.$emit("before-closed",t)},click:function(t,e,n){var i=2<arguments.length&&void 0!==n?n:"click",o=this.buttons[t],r=null==o?void 0:o.handler;"function"==typeof r&&r(t,e,{source:i})}}},B=(n(11),d(P,D,[],!1,null,null,null));B.options.__file="src/components/Dialog.vue";function I(){var n=this,t=n.$createElement,i=n._self._c||t;return i("div",{attrs:{id:"modals-container"}},n._l(n.modals,function(e){return i("modal",n._g(n._b({key:e.id,on:{closed:function(t){return n.remove(e.id)}}},"modal",e.modalAttrs,!1),e.modalListeners),[i(e.component,n._g(n._b({tag:"component",on:{close:function(t){return n.$modal.hide(e.modalAttrs.name,t)}}},"component",e.componentAttrs,!1),n.$listeners))],1)}),1)}var U=B.exports;function X(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}I._withStripped=!0;var F=d({data:function(){return{modals:[]}},created:function(){this.$root.__modalContainer=this},mounted:function(){var t=this;this.$modal.subscription.$on("hide-all",function(){t.modals=[]})},methods:{add:function(t,e,n,i){var o=this,r=1<arguments.length&&void 0!==e?e:{},a=2<arguments.length&&void 0!==n?n:{},s=3<arguments.length&&void 0!==i?i:{},l=c(),u=a.name||"dynamic_modal_"+l;this.modals.push({id:l,modalAttrs:function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},i=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),i.forEach(function(t){X(e,t,n[t])})}return e}({},a,{name:u}),modalListeners:s,component:t,componentAttrs:r}),this.$nextTick(function(){o.$modal.show(u)})},remove:function(e){var t=this.modals.findIndex(function(t){return t.id===e});-1!==t&&this.modals.splice(t,1)}}},I,[],!1,null,null,null);F.options.__file="src/components/ModalsContainer.vue";var G=F.exports;function V(t){return(V="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function q(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}var K=function(i,t){function o(t,e,n,i){var o,r=2<arguments.length&&void 0!==n?n:{},a=3<arguments.length?i:void 0,s=null===(o=c.root)||void 0===o?void 0:o.__modalContainer,l=u.dynamicDefaults||{};null!=s&&s.add(t,e,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},i=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(i=i.concat(Object.getOwnPropertySymbols(n).filter(function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),i.forEach(function(t){q(e,t,n[t])})}return e}({},l,r),a)}var u=1<arguments.length&&void 0!==t?t:{},r=new i,c={root:null,componentName:u.componentName||"Modal"};return{context:c,subscription:r,show:function(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];var i=e[0];switch(V(i)){case"string":(function(t,e){r.$emit("toggle",t,!0,e)}).apply(void 0,e);break;case"object":case"function":o.apply(void 0,e);break;default:console.warn("[vue-js-modal] $modal() received an unsupported argument as a first argument.",i)}},hide:function(t,e){r.$emit("toggle",t,!1,e)},hideAll:function(){r.$emit("hide-all")},toggle:function(t,e){r.$emit("toggle",t,void 0,e)},setDynamicModalContainer:function(t){c.root=t;var e,n=(e=document.createElement("div"),document.body.appendChild(e),e);new i({parent:t,render:function(t){return t(G)}}).$mount(n)}}},Y={install:function(e,t){var n=1<arguments.length&&void 0!==t?t:{};if(!e.prototype.$modal){var i=new K(e,n);Object.defineProperty(e.prototype,"$modal",{get:function(){if(this instanceof e){var t=this.$root;i.context.root||i.setDynamicModalContainer(t)}return i}}),e.component(i.context.componentName,W),n.dialog&&e.component("VDialog",U)}}},J="__VERSION__";e.default=Y}],o.c=i,o.d=function(t,e,n){o.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},o.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(o.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)o.d(n,i,function(t){return e[t]}.bind(null,i));return n},o.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return o.d(e,"a",e),e},o.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},o.p="/dist/",o(o.s=13);function o(t){if(i[t])return i[t].exports;var e=i[t]={i:t,l:!1,exports:{}};return n[t].call(e.exports,e,e.exports,o),e.l=!0,e.exports}var n,i});

},{}],234:[function(require,module,exports){
(function (global,setImmediate){(function (){
/*!
 * Vue.js v2.6.12
 * (c) 2014-2020 Evan You
 * Released under the MIT License.
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).Vue=t()}(this,function(){"use strict";var e=Object.freeze({});function t(e){return null==e}function n(e){return null!=e}function r(e){return!0===e}function i(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function o(e){return null!==e&&"object"==typeof e}var a=Object.prototype.toString;function s(e){return"[object Object]"===a.call(e)}function c(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function u(e){return n(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function l(e){return null==e?"":Array.isArray(e)||s(e)&&e.toString===a?JSON.stringify(e,null,2):String(e)}function f(e){var t=parseFloat(e);return isNaN(t)?e:t}function p(e,t){for(var n=Object.create(null),r=e.split(","),i=0;i<r.length;i++)n[r[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var d=p("slot,component",!0),v=p("key,ref,slot,slot-scope,is");function h(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}var m=Object.prototype.hasOwnProperty;function y(e,t){return m.call(e,t)}function g(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var _=/-(\w)/g,b=g(function(e){return e.replace(_,function(e,t){return t?t.toUpperCase():""})}),$=g(function(e){return e.charAt(0).toUpperCase()+e.slice(1)}),w=/\B([A-Z])/g,C=g(function(e){return e.replace(w,"-$1").toLowerCase()});var x=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var r=arguments.length;return r?r>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function k(e,t){t=t||0;for(var n=e.length-t,r=new Array(n);n--;)r[n]=e[n+t];return r}function A(e,t){for(var n in t)e[n]=t[n];return e}function O(e){for(var t={},n=0;n<e.length;n++)e[n]&&A(t,e[n]);return t}function S(e,t,n){}var T=function(e,t,n){return!1},E=function(e){return e};function N(e,t){if(e===t)return!0;var n=o(e),r=o(t);if(!n||!r)return!n&&!r&&String(e)===String(t);try{var i=Array.isArray(e),a=Array.isArray(t);if(i&&a)return e.length===t.length&&e.every(function(e,n){return N(e,t[n])});if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||a)return!1;var s=Object.keys(e),c=Object.keys(t);return s.length===c.length&&s.every(function(n){return N(e[n],t[n])})}catch(e){return!1}}function j(e,t){for(var n=0;n<e.length;n++)if(N(e[n],t))return n;return-1}function D(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}var L="data-server-rendered",M=["component","directive","filter"],I=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:T,isReservedAttr:T,isUnknownElement:T,getTagNamespace:S,parsePlatformTagName:E,mustUseProp:T,async:!0,_lifecycleHooks:I},P=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function R(e,t,n,r){Object.defineProperty(e,t,{value:n,enumerable:!!r,writable:!0,configurable:!0})}var H=new RegExp("[^"+P.source+".$_\\d]");var B,U="__proto__"in{},z="undefined"!=typeof window,V="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,K=V&&WXEnvironment.platform.toLowerCase(),J=z&&window.navigator.userAgent.toLowerCase(),q=J&&/msie|trident/.test(J),W=J&&J.indexOf("msie 9.0")>0,Z=J&&J.indexOf("edge/")>0,G=(J&&J.indexOf("android"),J&&/iphone|ipad|ipod|ios/.test(J)||"ios"===K),X=(J&&/chrome\/\d+/.test(J),J&&/phantomjs/.test(J),J&&J.match(/firefox\/(\d+)/)),Y={}.watch,Q=!1;if(z)try{var ee={};Object.defineProperty(ee,"passive",{get:function(){Q=!0}}),window.addEventListener("test-passive",null,ee)}catch(e){}var te=function(){return void 0===B&&(B=!z&&!V&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),B},ne=z&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function re(e){return"function"==typeof e&&/native code/.test(e.toString())}var ie,oe="undefined"!=typeof Symbol&&re(Symbol)&&"undefined"!=typeof Reflect&&re(Reflect.ownKeys);ie="undefined"!=typeof Set&&re(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var ae=S,se=0,ce=function(){this.id=se++,this.subs=[]};ce.prototype.addSub=function(e){this.subs.push(e)},ce.prototype.removeSub=function(e){h(this.subs,e)},ce.prototype.depend=function(){ce.target&&ce.target.addDep(this)},ce.prototype.notify=function(){for(var e=this.subs.slice(),t=0,n=e.length;t<n;t++)e[t].update()},ce.target=null;var ue=[];function le(e){ue.push(e),ce.target=e}function fe(){ue.pop(),ce.target=ue[ue.length-1]}var pe=function(e,t,n,r,i,o,a,s){this.tag=e,this.data=t,this.children=n,this.text=r,this.elm=i,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},de={child:{configurable:!0}};de.child.get=function(){return this.componentInstance},Object.defineProperties(pe.prototype,de);var ve=function(e){void 0===e&&(e="");var t=new pe;return t.text=e,t.isComment=!0,t};function he(e){return new pe(void 0,void 0,void 0,String(e))}function me(e){var t=new pe(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var ye=Array.prototype,ge=Object.create(ye);["push","pop","shift","unshift","splice","sort","reverse"].forEach(function(e){var t=ye[e];R(ge,e,function(){for(var n=[],r=arguments.length;r--;)n[r]=arguments[r];var i,o=t.apply(this,n),a=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&a.observeArray(i),a.dep.notify(),o})});var _e=Object.getOwnPropertyNames(ge),be=!0;function $e(e){be=e}var we=function(e){var t;this.value=e,this.dep=new ce,this.vmCount=0,R(e,"__ob__",this),Array.isArray(e)?(U?(t=ge,e.__proto__=t):function(e,t,n){for(var r=0,i=n.length;r<i;r++){var o=n[r];R(e,o,t[o])}}(e,ge,_e),this.observeArray(e)):this.walk(e)};function Ce(e,t){var n;if(o(e)&&!(e instanceof pe))return y(e,"__ob__")&&e.__ob__ instanceof we?n=e.__ob__:be&&!te()&&(Array.isArray(e)||s(e))&&Object.isExtensible(e)&&!e._isVue&&(n=new we(e)),t&&n&&n.vmCount++,n}function xe(e,t,n,r,i){var o=new ce,a=Object.getOwnPropertyDescriptor(e,t);if(!a||!1!==a.configurable){var s=a&&a.get,c=a&&a.set;s&&!c||2!==arguments.length||(n=e[t]);var u=!i&&Ce(n);Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var t=s?s.call(e):n;return ce.target&&(o.depend(),u&&(u.dep.depend(),Array.isArray(t)&&function e(t){for(var n=void 0,r=0,i=t.length;r<i;r++)(n=t[r])&&n.__ob__&&n.__ob__.dep.depend(),Array.isArray(n)&&e(n)}(t))),t},set:function(t){var r=s?s.call(e):n;t===r||t!=t&&r!=r||s&&!c||(c?c.call(e,t):n=t,u=!i&&Ce(t),o.notify())}})}}function ke(e,t,n){if(Array.isArray(e)&&c(t))return e.length=Math.max(e.length,t),e.splice(t,1,n),n;if(t in e&&!(t in Object.prototype))return e[t]=n,n;var r=e.__ob__;return e._isVue||r&&r.vmCount?n:r?(xe(r.value,t,n),r.dep.notify(),n):(e[t]=n,n)}function Ae(e,t){if(Array.isArray(e)&&c(t))e.splice(t,1);else{var n=e.__ob__;e._isVue||n&&n.vmCount||y(e,t)&&(delete e[t],n&&n.dep.notify())}}we.prototype.walk=function(e){for(var t=Object.keys(e),n=0;n<t.length;n++)xe(e,t[n])},we.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)Ce(e[t])};var Oe=F.optionMergeStrategies;function Se(e,t){if(!t)return e;for(var n,r,i,o=oe?Reflect.ownKeys(t):Object.keys(t),a=0;a<o.length;a++)"__ob__"!==(n=o[a])&&(r=e[n],i=t[n],y(e,n)?r!==i&&s(r)&&s(i)&&Se(r,i):ke(e,n,i));return e}function Te(e,t,n){return n?function(){var r="function"==typeof t?t.call(n,n):t,i="function"==typeof e?e.call(n,n):e;return r?Se(r,i):i}:t?e?function(){return Se("function"==typeof t?t.call(this,this):t,"function"==typeof e?e.call(this,this):e)}:t:e}function Ee(e,t){var n=t?e?e.concat(t):Array.isArray(t)?t:[t]:e;return n?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(n):n}function Ne(e,t,n,r){var i=Object.create(e||null);return t?A(i,t):i}Oe.data=function(e,t,n){return n?Te(e,t,n):t&&"function"!=typeof t?e:Te(e,t)},I.forEach(function(e){Oe[e]=Ee}),M.forEach(function(e){Oe[e+"s"]=Ne}),Oe.watch=function(e,t,n,r){if(e===Y&&(e=void 0),t===Y&&(t=void 0),!t)return Object.create(e||null);if(!e)return t;var i={};for(var o in A(i,e),t){var a=i[o],s=t[o];a&&!Array.isArray(a)&&(a=[a]),i[o]=a?a.concat(s):Array.isArray(s)?s:[s]}return i},Oe.props=Oe.methods=Oe.inject=Oe.computed=function(e,t,n,r){if(!e)return t;var i=Object.create(null);return A(i,e),t&&A(i,t),i},Oe.provide=Te;var je=function(e,t){return void 0===t?e:t};function De(e,t,n){if("function"==typeof t&&(t=t.options),function(e,t){var n=e.props;if(n){var r,i,o={};if(Array.isArray(n))for(r=n.length;r--;)"string"==typeof(i=n[r])&&(o[b(i)]={type:null});else if(s(n))for(var a in n)i=n[a],o[b(a)]=s(i)?i:{type:i};e.props=o}}(t),function(e,t){var n=e.inject;if(n){var r=e.inject={};if(Array.isArray(n))for(var i=0;i<n.length;i++)r[n[i]]={from:n[i]};else if(s(n))for(var o in n){var a=n[o];r[o]=s(a)?A({from:o},a):{from:a}}}}(t),function(e){var t=e.directives;if(t)for(var n in t){var r=t[n];"function"==typeof r&&(t[n]={bind:r,update:r})}}(t),!t._base&&(t.extends&&(e=De(e,t.extends,n)),t.mixins))for(var r=0,i=t.mixins.length;r<i;r++)e=De(e,t.mixins[r],n);var o,a={};for(o in e)c(o);for(o in t)y(e,o)||c(o);function c(r){var i=Oe[r]||je;a[r]=i(e[r],t[r],n,r)}return a}function Le(e,t,n,r){if("string"==typeof n){var i=e[t];if(y(i,n))return i[n];var o=b(n);if(y(i,o))return i[o];var a=$(o);return y(i,a)?i[a]:i[n]||i[o]||i[a]}}function Me(e,t,n,r){var i=t[e],o=!y(n,e),a=n[e],s=Pe(Boolean,i.type);if(s>-1)if(o&&!y(i,"default"))a=!1;else if(""===a||a===C(e)){var c=Pe(String,i.type);(c<0||s<c)&&(a=!0)}if(void 0===a){a=function(e,t,n){if(!y(t,"default"))return;var r=t.default;if(e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n])return e._props[n];return"function"==typeof r&&"Function"!==Ie(t.type)?r.call(e):r}(r,i,e);var u=be;$e(!0),Ce(a),$e(u)}return a}function Ie(e){var t=e&&e.toString().match(/^\s*function (\w+)/);return t?t[1]:""}function Fe(e,t){return Ie(e)===Ie(t)}function Pe(e,t){if(!Array.isArray(t))return Fe(t,e)?0:-1;for(var n=0,r=t.length;n<r;n++)if(Fe(t[n],e))return n;return-1}function Re(e,t,n){le();try{if(t)for(var r=t;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var o=0;o<i.length;o++)try{if(!1===i[o].call(r,e,t,n))return}catch(e){Be(e,r,"errorCaptured hook")}}Be(e,t,n)}finally{fe()}}function He(e,t,n,r,i){var o;try{(o=n?e.apply(t,n):e.call(t))&&!o._isVue&&u(o)&&!o._handled&&(o.catch(function(e){return Re(e,r,i+" (Promise/async)")}),o._handled=!0)}catch(e){Re(e,r,i)}return o}function Be(e,t,n){if(F.errorHandler)try{return F.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Ue(t,null,"config.errorHandler")}Ue(e,t,n)}function Ue(e,t,n){if(!z&&!V||"undefined"==typeof console)throw e;console.error(e)}var ze,Ve=!1,Ke=[],Je=!1;function qe(){Je=!1;var e=Ke.slice(0);Ke.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&re(Promise)){var We=Promise.resolve();ze=function(){We.then(qe),G&&setTimeout(S)},Ve=!0}else if(q||"undefined"==typeof MutationObserver||!re(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())ze="undefined"!=typeof setImmediate&&re(setImmediate)?function(){setImmediate(qe)}:function(){setTimeout(qe,0)};else{var Ze=1,Ge=new MutationObserver(qe),Xe=document.createTextNode(String(Ze));Ge.observe(Xe,{characterData:!0}),ze=function(){Ze=(Ze+1)%2,Xe.data=String(Ze)},Ve=!0}function Ye(e,t){var n;if(Ke.push(function(){if(e)try{e.call(t)}catch(e){Re(e,t,"nextTick")}else n&&n(t)}),Je||(Je=!0,ze()),!e&&"undefined"!=typeof Promise)return new Promise(function(e){n=e})}var Qe=new ie;function et(e){!function e(t,n){var r,i;var a=Array.isArray(t);if(!a&&!o(t)||Object.isFrozen(t)||t instanceof pe)return;if(t.__ob__){var s=t.__ob__.dep.id;if(n.has(s))return;n.add(s)}if(a)for(r=t.length;r--;)e(t[r],n);else for(i=Object.keys(t),r=i.length;r--;)e(t[i[r]],n)}(e,Qe),Qe.clear()}var tt=g(function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),r="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=r?e.slice(1):e,once:n,capture:r,passive:t}});function nt(e,t){function n(){var e=arguments,r=n.fns;if(!Array.isArray(r))return He(r,null,arguments,t,"v-on handler");for(var i=r.slice(),o=0;o<i.length;o++)He(i[o],null,e,t,"v-on handler")}return n.fns=e,n}function rt(e,n,i,o,a,s){var c,u,l,f;for(c in e)u=e[c],l=n[c],f=tt(c),t(u)||(t(l)?(t(u.fns)&&(u=e[c]=nt(u,s)),r(f.once)&&(u=e[c]=a(f.name,u,f.capture)),i(f.name,u,f.capture,f.passive,f.params)):u!==l&&(l.fns=u,e[c]=l));for(c in n)t(e[c])&&o((f=tt(c)).name,n[c],f.capture)}function it(e,i,o){var a;e instanceof pe&&(e=e.data.hook||(e.data.hook={}));var s=e[i];function c(){o.apply(this,arguments),h(a.fns,c)}t(s)?a=nt([c]):n(s.fns)&&r(s.merged)?(a=s).fns.push(c):a=nt([s,c]),a.merged=!0,e[i]=a}function ot(e,t,r,i,o){if(n(t)){if(y(t,r))return e[r]=t[r],o||delete t[r],!0;if(y(t,i))return e[r]=t[i],o||delete t[i],!0}return!1}function at(e){return i(e)?[he(e)]:Array.isArray(e)?function e(o,a){var s=[];var c,u,l,f;for(c=0;c<o.length;c++)t(u=o[c])||"boolean"==typeof u||(l=s.length-1,f=s[l],Array.isArray(u)?u.length>0&&(st((u=e(u,(a||"")+"_"+c))[0])&&st(f)&&(s[l]=he(f.text+u[0].text),u.shift()),s.push.apply(s,u)):i(u)?st(f)?s[l]=he(f.text+u):""!==u&&s.push(he(u)):st(u)&&st(f)?s[l]=he(f.text+u.text):(r(o._isVList)&&n(u.tag)&&t(u.key)&&n(a)&&(u.key="__vlist"+a+"_"+c+"__"),s.push(u)));return s}(e):void 0}function st(e){return n(e)&&n(e.text)&&!1===e.isComment}function ct(e,t){if(e){for(var n=Object.create(null),r=oe?Reflect.ownKeys(e):Object.keys(e),i=0;i<r.length;i++){var o=r[i];if("__ob__"!==o){for(var a=e[o].from,s=t;s;){if(s._provided&&y(s._provided,a)){n[o]=s._provided[a];break}s=s.$parent}if(!s&&"default"in e[o]){var c=e[o].default;n[o]="function"==typeof c?c.call(t):c}}}return n}}function ut(e,t){if(!e||!e.length)return{};for(var n={},r=0,i=e.length;r<i;r++){var o=e[r],a=o.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,o.context!==t&&o.fnContext!==t||!a||null==a.slot)(n.default||(n.default=[])).push(o);else{var s=a.slot,c=n[s]||(n[s]=[]);"template"===o.tag?c.push.apply(c,o.children||[]):c.push(o)}}for(var u in n)n[u].every(lt)&&delete n[u];return n}function lt(e){return e.isComment&&!e.asyncFactory||" "===e.text}function ft(t,n,r){var i,o=Object.keys(n).length>0,a=t?!!t.$stable:!o,s=t&&t.$key;if(t){if(t._normalized)return t._normalized;if(a&&r&&r!==e&&s===r.$key&&!o&&!r.$hasNormal)return r;for(var c in i={},t)t[c]&&"$"!==c[0]&&(i[c]=pt(n,c,t[c]))}else i={};for(var u in n)u in i||(i[u]=dt(n,u));return t&&Object.isExtensible(t)&&(t._normalized=i),R(i,"$stable",a),R(i,"$key",s),R(i,"$hasNormal",o),i}function pt(e,t,n){var r=function(){var e=arguments.length?n.apply(null,arguments):n({});return(e=e&&"object"==typeof e&&!Array.isArray(e)?[e]:at(e))&&(0===e.length||1===e.length&&e[0].isComment)?void 0:e};return n.proxy&&Object.defineProperty(e,t,{get:r,enumerable:!0,configurable:!0}),r}function dt(e,t){return function(){return e[t]}}function vt(e,t){var r,i,a,s,c;if(Array.isArray(e)||"string"==typeof e)for(r=new Array(e.length),i=0,a=e.length;i<a;i++)r[i]=t(e[i],i);else if("number"==typeof e)for(r=new Array(e),i=0;i<e;i++)r[i]=t(i+1,i);else if(o(e))if(oe&&e[Symbol.iterator]){r=[];for(var u=e[Symbol.iterator](),l=u.next();!l.done;)r.push(t(l.value,r.length)),l=u.next()}else for(s=Object.keys(e),r=new Array(s.length),i=0,a=s.length;i<a;i++)c=s[i],r[i]=t(e[c],c,i);return n(r)||(r=[]),r._isVList=!0,r}function ht(e,t,n,r){var i,o=this.$scopedSlots[e];o?(n=n||{},r&&(n=A(A({},r),n)),i=o(n)||t):i=this.$slots[e]||t;var a=n&&n.slot;return a?this.$createElement("template",{slot:a},i):i}function mt(e){return Le(this.$options,"filters",e)||E}function yt(e,t){return Array.isArray(e)?-1===e.indexOf(t):e!==t}function gt(e,t,n,r,i){var o=F.keyCodes[t]||n;return i&&r&&!F.keyCodes[t]?yt(i,r):o?yt(o,e):r?C(r)!==t:void 0}function _t(e,t,n,r,i){if(n)if(o(n)){var a;Array.isArray(n)&&(n=O(n));var s=function(o){if("class"===o||"style"===o||v(o))a=e;else{var s=e.attrs&&e.attrs.type;a=r||F.mustUseProp(t,s,o)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var c=b(o),u=C(o);c in a||u in a||(a[o]=n[o],i&&((e.on||(e.on={}))["update:"+o]=function(e){n[o]=e}))};for(var c in n)s(c)}else;return e}function bt(e,t){var n=this._staticTrees||(this._staticTrees=[]),r=n[e];return r&&!t?r:(wt(r=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,null,this),"__static__"+e,!1),r)}function $t(e,t,n){return wt(e,"__once__"+t+(n?"_"+n:""),!0),e}function wt(e,t,n){if(Array.isArray(e))for(var r=0;r<e.length;r++)e[r]&&"string"!=typeof e[r]&&Ct(e[r],t+"_"+r,n);else Ct(e,t,n)}function Ct(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function xt(e,t){if(t)if(s(t)){var n=e.on=e.on?A({},e.on):{};for(var r in t){var i=n[r],o=t[r];n[r]=i?[].concat(i,o):o}}else;return e}function kt(e,t,n,r){t=t||{$stable:!n};for(var i=0;i<e.length;i++){var o=e[i];Array.isArray(o)?kt(o,t,n):o&&(o.proxy&&(o.fn.proxy=!0),t[o.key]=o.fn)}return r&&(t.$key=r),t}function At(e,t){for(var n=0;n<t.length;n+=2){var r=t[n];"string"==typeof r&&r&&(e[t[n]]=t[n+1])}return e}function Ot(e,t){return"string"==typeof e?t+e:e}function St(e){e._o=$t,e._n=f,e._s=l,e._l=vt,e._t=ht,e._q=N,e._i=j,e._m=bt,e._f=mt,e._k=gt,e._b=_t,e._v=he,e._e=ve,e._u=kt,e._g=xt,e._d=At,e._p=Ot}function Tt(t,n,i,o,a){var s,c=this,u=a.options;y(o,"_uid")?(s=Object.create(o))._original=o:(s=o,o=o._original);var l=r(u._compiled),f=!l;this.data=t,this.props=n,this.children=i,this.parent=o,this.listeners=t.on||e,this.injections=ct(u.inject,o),this.slots=function(){return c.$slots||ft(t.scopedSlots,c.$slots=ut(i,o)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ft(t.scopedSlots,this.slots())}}),l&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=ft(t.scopedSlots,this.$slots)),u._scopeId?this._c=function(e,t,n,r){var i=Pt(s,e,t,n,r,f);return i&&!Array.isArray(i)&&(i.fnScopeId=u._scopeId,i.fnContext=o),i}:this._c=function(e,t,n,r){return Pt(s,e,t,n,r,f)}}function Et(e,t,n,r,i){var o=me(e);return o.fnContext=n,o.fnOptions=r,t.slot&&((o.data||(o.data={})).slot=t.slot),o}function Nt(e,t){for(var n in t)e[b(n)]=t[n]}St(Tt.prototype);var jt={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var r=e;jt.prepatch(r,r)}else{(e.componentInstance=function(e,t){var r={_isComponent:!0,_parentVnode:e,parent:t},i=e.data.inlineTemplate;n(i)&&(r.render=i.render,r.staticRenderFns=i.staticRenderFns);return new e.componentOptions.Ctor(r)}(e,Wt)).$mount(t?e.elm:void 0,t)}},prepatch:function(t,n){var r=n.componentOptions;!function(t,n,r,i,o){var a=i.data.scopedSlots,s=t.$scopedSlots,c=!!(a&&!a.$stable||s!==e&&!s.$stable||a&&t.$scopedSlots.$key!==a.$key),u=!!(o||t.$options._renderChildren||c);t.$options._parentVnode=i,t.$vnode=i,t._vnode&&(t._vnode.parent=i);if(t.$options._renderChildren=o,t.$attrs=i.data.attrs||e,t.$listeners=r||e,n&&t.$options.props){$e(!1);for(var l=t._props,f=t.$options._propKeys||[],p=0;p<f.length;p++){var d=f[p],v=t.$options.props;l[d]=Me(d,v,n,t)}$e(!0),t.$options.propsData=n}r=r||e;var h=t.$options._parentListeners;t.$options._parentListeners=r,qt(t,r,h),u&&(t.$slots=ut(o,i.context),t.$forceUpdate())}(n.componentInstance=t.componentInstance,r.propsData,r.listeners,n,r.children)},insert:function(e){var t,n=e.context,r=e.componentInstance;r._isMounted||(r._isMounted=!0,Yt(r,"mounted")),e.data.keepAlive&&(n._isMounted?((t=r)._inactive=!1,en.push(t)):Xt(r,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?function e(t,n){if(n&&(t._directInactive=!0,Gt(t)))return;if(!t._inactive){t._inactive=!0;for(var r=0;r<t.$children.length;r++)e(t.$children[r]);Yt(t,"deactivated")}}(t,!0):t.$destroy())}},Dt=Object.keys(jt);function Lt(i,a,s,c,l){if(!t(i)){var f=s.$options._base;if(o(i)&&(i=f.extend(i)),"function"==typeof i){var p;if(t(i.cid)&&void 0===(i=function(e,i){if(r(e.error)&&n(e.errorComp))return e.errorComp;if(n(e.resolved))return e.resolved;var a=Ht;a&&n(e.owners)&&-1===e.owners.indexOf(a)&&e.owners.push(a);if(r(e.loading)&&n(e.loadingComp))return e.loadingComp;if(a&&!n(e.owners)){var s=e.owners=[a],c=!0,l=null,f=null;a.$on("hook:destroyed",function(){return h(s,a)});var p=function(e){for(var t=0,n=s.length;t<n;t++)s[t].$forceUpdate();e&&(s.length=0,null!==l&&(clearTimeout(l),l=null),null!==f&&(clearTimeout(f),f=null))},d=D(function(t){e.resolved=Bt(t,i),c?s.length=0:p(!0)}),v=D(function(t){n(e.errorComp)&&(e.error=!0,p(!0))}),m=e(d,v);return o(m)&&(u(m)?t(e.resolved)&&m.then(d,v):u(m.component)&&(m.component.then(d,v),n(m.error)&&(e.errorComp=Bt(m.error,i)),n(m.loading)&&(e.loadingComp=Bt(m.loading,i),0===m.delay?e.loading=!0:l=setTimeout(function(){l=null,t(e.resolved)&&t(e.error)&&(e.loading=!0,p(!1))},m.delay||200)),n(m.timeout)&&(f=setTimeout(function(){f=null,t(e.resolved)&&v(null)},m.timeout)))),c=!1,e.loading?e.loadingComp:e.resolved}}(p=i,f)))return function(e,t,n,r,i){var o=ve();return o.asyncFactory=e,o.asyncMeta={data:t,context:n,children:r,tag:i},o}(p,a,s,c,l);a=a||{},$n(i),n(a.model)&&function(e,t){var r=e.model&&e.model.prop||"value",i=e.model&&e.model.event||"input";(t.attrs||(t.attrs={}))[r]=t.model.value;var o=t.on||(t.on={}),a=o[i],s=t.model.callback;n(a)?(Array.isArray(a)?-1===a.indexOf(s):a!==s)&&(o[i]=[s].concat(a)):o[i]=s}(i.options,a);var d=function(e,r,i){var o=r.options.props;if(!t(o)){var a={},s=e.attrs,c=e.props;if(n(s)||n(c))for(var u in o){var l=C(u);ot(a,c,u,l,!0)||ot(a,s,u,l,!1)}return a}}(a,i);if(r(i.options.functional))return function(t,r,i,o,a){var s=t.options,c={},u=s.props;if(n(u))for(var l in u)c[l]=Me(l,u,r||e);else n(i.attrs)&&Nt(c,i.attrs),n(i.props)&&Nt(c,i.props);var f=new Tt(i,c,a,o,t),p=s.render.call(null,f._c,f);if(p instanceof pe)return Et(p,i,f.parent,s);if(Array.isArray(p)){for(var d=at(p)||[],v=new Array(d.length),h=0;h<d.length;h++)v[h]=Et(d[h],i,f.parent,s);return v}}(i,d,a,s,c);var v=a.on;if(a.on=a.nativeOn,r(i.options.abstract)){var m=a.slot;a={},m&&(a.slot=m)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<Dt.length;n++){var r=Dt[n],i=t[r],o=jt[r];i===o||i&&i._merged||(t[r]=i?Mt(o,i):o)}}(a);var y=i.options.name||l;return new pe("vue-component-"+i.cid+(y?"-"+y:""),a,void 0,void 0,void 0,s,{Ctor:i,propsData:d,listeners:v,tag:l,children:c},p)}}}function Mt(e,t){var n=function(n,r){e(n,r),t(n,r)};return n._merged=!0,n}var It=1,Ft=2;function Pt(e,a,s,c,u,l){return(Array.isArray(s)||i(s))&&(u=c,c=s,s=void 0),r(l)&&(u=Ft),function(e,i,a,s,c){if(n(a)&&n(a.__ob__))return ve();n(a)&&n(a.is)&&(i=a.is);if(!i)return ve();Array.isArray(s)&&"function"==typeof s[0]&&((a=a||{}).scopedSlots={default:s[0]},s.length=0);c===Ft?s=at(s):c===It&&(s=function(e){for(var t=0;t<e.length;t++)if(Array.isArray(e[t]))return Array.prototype.concat.apply([],e);return e}(s));var u,l;if("string"==typeof i){var f;l=e.$vnode&&e.$vnode.ns||F.getTagNamespace(i),u=F.isReservedTag(i)?new pe(F.parsePlatformTagName(i),a,s,void 0,void 0,e):a&&a.pre||!n(f=Le(e.$options,"components",i))?new pe(i,a,s,void 0,void 0,e):Lt(f,a,e,s,i)}else u=Lt(i,a,e,s);return Array.isArray(u)?u:n(u)?(n(l)&&function e(i,o,a){i.ns=o;"foreignObject"===i.tag&&(o=void 0,a=!0);if(n(i.children))for(var s=0,c=i.children.length;s<c;s++){var u=i.children[s];n(u.tag)&&(t(u.ns)||r(a)&&"svg"!==u.tag)&&e(u,o,a)}}(u,l),n(a)&&function(e){o(e.style)&&et(e.style);o(e.class)&&et(e.class)}(a),u):ve()}(e,a,s,c,u)}var Rt,Ht=null;function Bt(e,t){return(e.__esModule||oe&&"Module"===e[Symbol.toStringTag])&&(e=e.default),o(e)?t.extend(e):e}function Ut(e){return e.isComment&&e.asyncFactory}function zt(e){if(Array.isArray(e))for(var t=0;t<e.length;t++){var r=e[t];if(n(r)&&(n(r.componentOptions)||Ut(r)))return r}}function Vt(e,t){Rt.$on(e,t)}function Kt(e,t){Rt.$off(e,t)}function Jt(e,t){var n=Rt;return function r(){null!==t.apply(null,arguments)&&n.$off(e,r)}}function qt(e,t,n){Rt=e,rt(t,n||{},Vt,Kt,Jt,e),Rt=void 0}var Wt=null;function Zt(e){var t=Wt;return Wt=e,function(){Wt=t}}function Gt(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function Xt(e,t){if(t){if(e._directInactive=!1,Gt(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)Xt(e.$children[n]);Yt(e,"activated")}}function Yt(e,t){le();var n=e.$options[t],r=t+" hook";if(n)for(var i=0,o=n.length;i<o;i++)He(n[i],e,null,e,r);e._hasHookEvent&&e.$emit("hook:"+t),fe()}var Qt=[],en=[],tn={},nn=!1,rn=!1,on=0;var an=0,sn=Date.now;if(z&&!q){var cn=window.performance;cn&&"function"==typeof cn.now&&sn()>document.createEvent("Event").timeStamp&&(sn=function(){return cn.now()})}function un(){var e,t;for(an=sn(),rn=!0,Qt.sort(function(e,t){return e.id-t.id}),on=0;on<Qt.length;on++)(e=Qt[on]).before&&e.before(),t=e.id,tn[t]=null,e.run();var n=en.slice(),r=Qt.slice();on=Qt.length=en.length=0,tn={},nn=rn=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,Xt(e[t],!0)}(n),function(e){var t=e.length;for(;t--;){var n=e[t],r=n.vm;r._watcher===n&&r._isMounted&&!r._isDestroyed&&Yt(r,"updated")}}(r),ne&&F.devtools&&ne.emit("flush")}var ln=0,fn=function(e,t,n,r,i){this.vm=e,i&&(e._watcher=this),e._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++ln,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ie,this.newDepIds=new ie,this.expression="","function"==typeof t?this.getter=t:(this.getter=function(e){if(!H.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=S)),this.value=this.lazy?void 0:this.get()};fn.prototype.get=function(){var e;le(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;Re(e,t,'getter for watcher "'+this.expression+'"')}finally{this.deep&&et(e),fe(),this.cleanupDeps()}return e},fn.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},fn.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},fn.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==tn[t]){if(tn[t]=!0,rn){for(var n=Qt.length-1;n>on&&Qt[n].id>e.id;)n--;Qt.splice(n+1,0,e)}else Qt.push(e);nn||(nn=!0,Ye(un))}}(this)},fn.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||o(e)||this.deep){var t=this.value;if(this.value=e,this.user)try{this.cb.call(this.vm,e,t)}catch(e){Re(e,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,e,t)}}},fn.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},fn.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},fn.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||h(this.vm._watchers,this);for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1}};var pn={enumerable:!0,configurable:!0,get:S,set:S};function dn(e,t,n){pn.get=function(){return this[t][n]},pn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,pn)}function vn(e){e._watchers=[];var t=e.$options;t.props&&function(e,t){var n=e.$options.propsData||{},r=e._props={},i=e.$options._propKeys=[];e.$parent&&$e(!1);var o=function(o){i.push(o);var a=Me(o,t,n,e);xe(r,o,a),o in e||dn(e,"_props",o)};for(var a in t)o(a);$e(!0)}(e,t.props),t.methods&&function(e,t){e.$options.props;for(var n in t)e[n]="function"!=typeof t[n]?S:x(t[n],e)}(e,t.methods),t.data?function(e){var t=e.$options.data;s(t=e._data="function"==typeof t?function(e,t){le();try{return e.call(t,t)}catch(e){return Re(e,t,"data()"),{}}finally{fe()}}(t,e):t||{})||(t={});var n=Object.keys(t),r=e.$options.props,i=(e.$options.methods,n.length);for(;i--;){var o=n[i];r&&y(r,o)||(a=void 0,36!==(a=(o+"").charCodeAt(0))&&95!==a&&dn(e,"_data",o))}var a;Ce(t,!0)}(e):Ce(e._data={},!0),t.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),r=te();for(var i in t){var o=t[i],a="function"==typeof o?o:o.get;r||(n[i]=new fn(e,a||S,S,hn)),i in e||mn(e,i,o)}}(e,t.computed),t.watch&&t.watch!==Y&&function(e,t){for(var n in t){var r=t[n];if(Array.isArray(r))for(var i=0;i<r.length;i++)_n(e,n,r[i]);else _n(e,n,r)}}(e,t.watch)}var hn={lazy:!0};function mn(e,t,n){var r=!te();"function"==typeof n?(pn.get=r?yn(t):gn(n),pn.set=S):(pn.get=n.get?r&&!1!==n.cache?yn(t):gn(n.get):S,pn.set=n.set||S),Object.defineProperty(e,t,pn)}function yn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),ce.target&&t.depend(),t.value}}function gn(e){return function(){return e.call(this,this)}}function _n(e,t,n,r){return s(n)&&(r=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,r)}var bn=0;function $n(e){var t=e.options;if(e.super){var n=$n(e.super);if(n!==e.superOptions){e.superOptions=n;var r=function(e){var t,n=e.options,r=e.sealedOptions;for(var i in n)n[i]!==r[i]&&(t||(t={}),t[i]=n[i]);return t}(e);r&&A(e.extendOptions,r),(t=e.options=De(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function wn(e){this._init(e)}function Cn(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,r=n.cid,i=e._Ctor||(e._Ctor={});if(i[r])return i[r];var o=e.name||n.options.name,a=function(e){this._init(e)};return(a.prototype=Object.create(n.prototype)).constructor=a,a.cid=t++,a.options=De(n.options,e),a.super=n,a.options.props&&function(e){var t=e.options.props;for(var n in t)dn(e.prototype,"_props",n)}(a),a.options.computed&&function(e){var t=e.options.computed;for(var n in t)mn(e.prototype,n,t[n])}(a),a.extend=n.extend,a.mixin=n.mixin,a.use=n.use,M.forEach(function(e){a[e]=n[e]}),o&&(a.options.components[o]=a),a.superOptions=n.options,a.extendOptions=e,a.sealedOptions=A({},a.options),i[r]=a,a}}function xn(e){return e&&(e.Ctor.options.name||e.tag)}function kn(e,t){return Array.isArray(e)?e.indexOf(t)>-1:"string"==typeof e?e.split(",").indexOf(t)>-1:(n=e,"[object RegExp]"===a.call(n)&&e.test(t));var n}function An(e,t){var n=e.cache,r=e.keys,i=e._vnode;for(var o in n){var a=n[o];if(a){var s=xn(a.componentOptions);s&&!t(s)&&On(n,o,r,i)}}}function On(e,t,n,r){var i=e[t];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),e[t]=null,h(n,t)}!function(t){t.prototype._init=function(t){var n=this;n._uid=bn++,n._isVue=!0,t&&t._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),r=t._parentVnode;n.parent=t.parent,n._parentVnode=r;var i=r.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(n,t):n.$options=De($n(n.constructor),t||{},n),n._renderProxy=n,n._self=n,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&qt(e,t)}(n),function(t){t._vnode=null,t._staticTrees=null;var n=t.$options,r=t.$vnode=n._parentVnode,i=r&&r.context;t.$slots=ut(n._renderChildren,i),t.$scopedSlots=e,t._c=function(e,n,r,i){return Pt(t,e,n,r,i,!1)},t.$createElement=function(e,n,r,i){return Pt(t,e,n,r,i,!0)};var o=r&&r.data;xe(t,"$attrs",o&&o.attrs||e,null,!0),xe(t,"$listeners",n._parentListeners||e,null,!0)}(n),Yt(n,"beforeCreate"),function(e){var t=ct(e.$options.inject,e);t&&($e(!1),Object.keys(t).forEach(function(n){xe(e,n,t[n])}),$e(!0))}(n),vn(n),function(e){var t=e.$options.provide;t&&(e._provided="function"==typeof t?t.call(e):t)}(n),Yt(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(wn),function(e){var t={get:function(){return this._data}},n={get:function(){return this._props}};Object.defineProperty(e.prototype,"$data",t),Object.defineProperty(e.prototype,"$props",n),e.prototype.$set=ke,e.prototype.$delete=Ae,e.prototype.$watch=function(e,t,n){if(s(t))return _n(this,e,t,n);(n=n||{}).user=!0;var r=new fn(this,e,t,n);if(n.immediate)try{t.call(this,r.value)}catch(e){Re(e,this,'callback for immediate watcher "'+r.expression+'"')}return function(){r.teardown()}}}(wn),function(e){var t=/^hook:/;e.prototype.$on=function(e,n){var r=this;if(Array.isArray(e))for(var i=0,o=e.length;i<o;i++)r.$on(e[i],n);else(r._events[e]||(r._events[e]=[])).push(n),t.test(e)&&(r._hasHookEvent=!0);return r},e.prototype.$once=function(e,t){var n=this;function r(){n.$off(e,r),t.apply(n,arguments)}return r.fn=t,n.$on(e,r),n},e.prototype.$off=function(e,t){var n=this;if(!arguments.length)return n._events=Object.create(null),n;if(Array.isArray(e)){for(var r=0,i=e.length;r<i;r++)n.$off(e[r],t);return n}var o,a=n._events[e];if(!a)return n;if(!t)return n._events[e]=null,n;for(var s=a.length;s--;)if((o=a[s])===t||o.fn===t){a.splice(s,1);break}return n},e.prototype.$emit=function(e){var t=this._events[e];if(t){t=t.length>1?k(t):t;for(var n=k(arguments,1),r='event handler for "'+e+'"',i=0,o=t.length;i<o;i++)He(t[i],this,n,this,r)}return this}}(wn),function(e){e.prototype._update=function(e,t){var n=this,r=n.$el,i=n._vnode,o=Zt(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),o(),r&&(r.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){Yt(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||h(t.$children,e),e._watcher&&e._watcher.teardown();for(var n=e._watchers.length;n--;)e._watchers[n].teardown();e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),Yt(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(wn),function(e){St(e.prototype),e.prototype.$nextTick=function(e){return Ye(e,this)},e.prototype._render=function(){var e,t=this,n=t.$options,r=n.render,i=n._parentVnode;i&&(t.$scopedSlots=ft(i.data.scopedSlots,t.$slots,t.$scopedSlots)),t.$vnode=i;try{Ht=t,e=r.call(t._renderProxy,t.$createElement)}catch(n){Re(n,t,"render"),e=t._vnode}finally{Ht=null}return Array.isArray(e)&&1===e.length&&(e=e[0]),e instanceof pe||(e=ve()),e.parent=i,e}}(wn);var Sn=[String,RegExp,Array],Tn={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Sn,exclude:Sn,max:[String,Number]},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)On(this.cache,e,this.keys)},mounted:function(){var e=this;this.$watch("include",function(t){An(e,function(e){return kn(t,e)})}),this.$watch("exclude",function(t){An(e,function(e){return!kn(t,e)})})},render:function(){var e=this.$slots.default,t=zt(e),n=t&&t.componentOptions;if(n){var r=xn(n),i=this.include,o=this.exclude;if(i&&(!r||!kn(i,r))||o&&r&&kn(o,r))return t;var a=this.cache,s=this.keys,c=null==t.key?n.Ctor.cid+(n.tag?"::"+n.tag:""):t.key;a[c]?(t.componentInstance=a[c].componentInstance,h(s,c),s.push(c)):(a[c]=t,s.push(c),this.max&&s.length>parseInt(this.max)&&On(a,s[0],s,this._vnode)),t.data.keepAlive=!0}return t||e&&e[0]}}};!function(e){var t={get:function(){return F}};Object.defineProperty(e,"config",t),e.util={warn:ae,extend:A,mergeOptions:De,defineReactive:xe},e.set=ke,e.delete=Ae,e.nextTick=Ye,e.observable=function(e){return Ce(e),e},e.options=Object.create(null),M.forEach(function(t){e.options[t+"s"]=Object.create(null)}),e.options._base=e,A(e.options.components,Tn),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=k(arguments,1);return n.unshift(this),"function"==typeof e.install?e.install.apply(e,n):"function"==typeof e&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=De(this.options,e),this}}(e),Cn(e),function(e){M.forEach(function(t){e[t]=function(e,n){return n?("component"===t&&s(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&"function"==typeof n&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}})}(e)}(wn),Object.defineProperty(wn.prototype,"$isServer",{get:te}),Object.defineProperty(wn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(wn,"FunctionalRenderContext",{value:Tt}),wn.version="2.6.12";var En=p("style,class"),Nn=p("input,textarea,option,select,progress"),jn=function(e,t,n){return"value"===n&&Nn(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},Dn=p("contenteditable,draggable,spellcheck"),Ln=p("events,caret,typing,plaintext-only"),Mn=function(e,t){return Hn(t)||"false"===t?"false":"contenteditable"===e&&Ln(t)?t:"true"},In=p("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),Fn="http://www.w3.org/1999/xlink",Pn=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},Rn=function(e){return Pn(e)?e.slice(6,e.length):""},Hn=function(e){return null==e||!1===e};function Bn(e){for(var t=e.data,r=e,i=e;n(i.componentInstance);)(i=i.componentInstance._vnode)&&i.data&&(t=Un(i.data,t));for(;n(r=r.parent);)r&&r.data&&(t=Un(t,r.data));return function(e,t){if(n(e)||n(t))return zn(e,Vn(t));return""}(t.staticClass,t.class)}function Un(e,t){return{staticClass:zn(e.staticClass,t.staticClass),class:n(e.class)?[e.class,t.class]:t.class}}function zn(e,t){return e?t?e+" "+t:e:t||""}function Vn(e){return Array.isArray(e)?function(e){for(var t,r="",i=0,o=e.length;i<o;i++)n(t=Vn(e[i]))&&""!==t&&(r&&(r+=" "),r+=t);return r}(e):o(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var Kn={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Jn=p("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),qn=p("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Wn=function(e){return Jn(e)||qn(e)};function Zn(e){return qn(e)?"svg":"math"===e?"math":void 0}var Gn=Object.create(null);var Xn=p("text,number,password,search,email,tel,url");function Yn(e){if("string"==typeof e){var t=document.querySelector(e);return t||document.createElement("div")}return e}var Qn=Object.freeze({createElement:function(e,t){var n=document.createElement(e);return"select"!==e?n:(t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n)},createElementNS:function(e,t){return document.createElementNS(Kn[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),er={create:function(e,t){tr(t)},update:function(e,t){e.data.ref!==t.data.ref&&(tr(e,!0),tr(t))},destroy:function(e){tr(e,!0)}};function tr(e,t){var r=e.data.ref;if(n(r)){var i=e.context,o=e.componentInstance||e.elm,a=i.$refs;t?Array.isArray(a[r])?h(a[r],o):a[r]===o&&(a[r]=void 0):e.data.refInFor?Array.isArray(a[r])?a[r].indexOf(o)<0&&a[r].push(o):a[r]=[o]:a[r]=o}}var nr=new pe("",{},[]),rr=["create","activate","update","remove","destroy"];function ir(e,i){return e.key===i.key&&(e.tag===i.tag&&e.isComment===i.isComment&&n(e.data)===n(i.data)&&function(e,t){if("input"!==e.tag)return!0;var r,i=n(r=e.data)&&n(r=r.attrs)&&r.type,o=n(r=t.data)&&n(r=r.attrs)&&r.type;return i===o||Xn(i)&&Xn(o)}(e,i)||r(e.isAsyncPlaceholder)&&e.asyncFactory===i.asyncFactory&&t(i.asyncFactory.error))}function or(e,t,r){var i,o,a={};for(i=t;i<=r;++i)n(o=e[i].key)&&(a[o]=i);return a}var ar={create:sr,update:sr,destroy:function(e){sr(e,nr)}};function sr(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,r,i,o=e===nr,a=t===nr,s=ur(e.data.directives,e.context),c=ur(t.data.directives,t.context),u=[],l=[];for(n in c)r=s[n],i=c[n],r?(i.oldValue=r.value,i.oldArg=r.arg,fr(i,"update",t,e),i.def&&i.def.componentUpdated&&l.push(i)):(fr(i,"bind",t,e),i.def&&i.def.inserted&&u.push(i));if(u.length){var f=function(){for(var n=0;n<u.length;n++)fr(u[n],"inserted",t,e)};o?it(t,"insert",f):f()}l.length&&it(t,"postpatch",function(){for(var n=0;n<l.length;n++)fr(l[n],"componentUpdated",t,e)});if(!o)for(n in s)c[n]||fr(s[n],"unbind",e,e,a)}(e,t)}var cr=Object.create(null);function ur(e,t){var n,r,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++)(r=e[n]).modifiers||(r.modifiers=cr),i[lr(r)]=r,r.def=Le(t.$options,"directives",r.name);return i}function lr(e){return e.rawName||e.name+"."+Object.keys(e.modifiers||{}).join(".")}function fr(e,t,n,r,i){var o=e.def&&e.def[t];if(o)try{o(n.elm,e,n,r,i)}catch(r){Re(r,n.context,"directive "+e.name+" "+t+" hook")}}var pr=[er,ar];function dr(e,r){var i=r.componentOptions;if(!(n(i)&&!1===i.Ctor.options.inheritAttrs||t(e.data.attrs)&&t(r.data.attrs))){var o,a,s=r.elm,c=e.data.attrs||{},u=r.data.attrs||{};for(o in n(u.__ob__)&&(u=r.data.attrs=A({},u)),u)a=u[o],c[o]!==a&&vr(s,o,a);for(o in(q||Z)&&u.value!==c.value&&vr(s,"value",u.value),c)t(u[o])&&(Pn(o)?s.removeAttributeNS(Fn,Rn(o)):Dn(o)||s.removeAttribute(o))}}function vr(e,t,n){e.tagName.indexOf("-")>-1?hr(e,t,n):In(t)?Hn(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):Dn(t)?e.setAttribute(t,Mn(t,n)):Pn(t)?Hn(n)?e.removeAttributeNS(Fn,Rn(t)):e.setAttributeNS(Fn,t,n):hr(e,t,n)}function hr(e,t,n){if(Hn(n))e.removeAttribute(t);else{if(q&&!W&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var r=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",r)};e.addEventListener("input",r),e.__ieph=!0}e.setAttribute(t,n)}}var mr={create:dr,update:dr};function yr(e,r){var i=r.elm,o=r.data,a=e.data;if(!(t(o.staticClass)&&t(o.class)&&(t(a)||t(a.staticClass)&&t(a.class)))){var s=Bn(r),c=i._transitionClasses;n(c)&&(s=zn(s,Vn(c))),s!==i._prevClass&&(i.setAttribute("class",s),i._prevClass=s)}}var gr,_r,br,$r,wr,Cr,xr={create:yr,update:yr},kr=/[\w).+\-_$\]]/;function Ar(e){var t,n,r,i,o,a=!1,s=!1,c=!1,u=!1,l=0,f=0,p=0,d=0;for(r=0;r<e.length;r++)if(n=t,t=e.charCodeAt(r),a)39===t&&92!==n&&(a=!1);else if(s)34===t&&92!==n&&(s=!1);else if(c)96===t&&92!==n&&(c=!1);else if(u)47===t&&92!==n&&(u=!1);else if(124!==t||124===e.charCodeAt(r+1)||124===e.charCodeAt(r-1)||l||f||p){switch(t){case 34:s=!0;break;case 39:a=!0;break;case 96:c=!0;break;case 40:p++;break;case 41:p--;break;case 91:f++;break;case 93:f--;break;case 123:l++;break;case 125:l--}if(47===t){for(var v=r-1,h=void 0;v>=0&&" "===(h=e.charAt(v));v--);h&&kr.test(h)||(u=!0)}}else void 0===i?(d=r+1,i=e.slice(0,r).trim()):m();function m(){(o||(o=[])).push(e.slice(d,r).trim()),d=r+1}if(void 0===i?i=e.slice(0,r).trim():0!==d&&m(),o)for(r=0;r<o.length;r++)i=Or(i,o[r]);return i}function Or(e,t){var n=t.indexOf("(");if(n<0)return'_f("'+t+'")('+e+")";var r=t.slice(0,n),i=t.slice(n+1);return'_f("'+r+'")('+e+(")"!==i?","+i:i)}function Sr(e,t){console.error("[Vue compiler]: "+e)}function Tr(e,t){return e?e.map(function(e){return e[t]}).filter(function(e){return e}):[]}function Er(e,t,n,r,i){(e.props||(e.props=[])).push(Rr({name:t,value:n,dynamic:i},r)),e.plain=!1}function Nr(e,t,n,r,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(Rr({name:t,value:n,dynamic:i},r)),e.plain=!1}function jr(e,t,n,r){e.attrsMap[t]=n,e.attrsList.push(Rr({name:t,value:n},r))}function Dr(e,t,n,r,i,o,a,s){(e.directives||(e.directives=[])).push(Rr({name:t,rawName:n,value:r,arg:i,isDynamicArg:o,modifiers:a},s)),e.plain=!1}function Lr(e,t,n){return n?"_p("+t+',"'+e+'")':e+t}function Mr(t,n,r,i,o,a,s,c){var u;(i=i||e).right?c?n="("+n+")==='click'?'contextmenu':("+n+")":"click"===n&&(n="contextmenu",delete i.right):i.middle&&(c?n="("+n+")==='click'?'mouseup':("+n+")":"click"===n&&(n="mouseup")),i.capture&&(delete i.capture,n=Lr("!",n,c)),i.once&&(delete i.once,n=Lr("~",n,c)),i.passive&&(delete i.passive,n=Lr("&",n,c)),i.native?(delete i.native,u=t.nativeEvents||(t.nativeEvents={})):u=t.events||(t.events={});var l=Rr({value:r.trim(),dynamic:c},s);i!==e&&(l.modifiers=i);var f=u[n];Array.isArray(f)?o?f.unshift(l):f.push(l):u[n]=f?o?[l,f]:[f,l]:l,t.plain=!1}function Ir(e,t,n){var r=Fr(e,":"+t)||Fr(e,"v-bind:"+t);if(null!=r)return Ar(r);if(!1!==n){var i=Fr(e,t);if(null!=i)return JSON.stringify(i)}}function Fr(e,t,n){var r;if(null!=(r=e.attrsMap[t]))for(var i=e.attrsList,o=0,a=i.length;o<a;o++)if(i[o].name===t){i.splice(o,1);break}return n&&delete e.attrsMap[t],r}function Pr(e,t){for(var n=e.attrsList,r=0,i=n.length;r<i;r++){var o=n[r];if(t.test(o.name))return n.splice(r,1),o}}function Rr(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function Hr(e,t,n){var r=n||{},i=r.number,o="$$v";r.trim&&(o="(typeof $$v === 'string'? $$v.trim(): $$v)"),i&&(o="_n("+o+")");var a=Br(t,o);e.model={value:"("+t+")",expression:JSON.stringify(t),callback:"function ($$v) {"+a+"}"}}function Br(e,t){var n=function(e){if(e=e.trim(),gr=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<gr-1)return($r=e.lastIndexOf("."))>-1?{exp:e.slice(0,$r),key:'"'+e.slice($r+1)+'"'}:{exp:e,key:null};_r=e,$r=wr=Cr=0;for(;!zr();)Vr(br=Ur())?Jr(br):91===br&&Kr(br);return{exp:e.slice(0,wr),key:e.slice(wr+1,Cr)}}(e);return null===n.key?e+"="+t:"$set("+n.exp+", "+n.key+", "+t+")"}function Ur(){return _r.charCodeAt(++$r)}function zr(){return $r>=gr}function Vr(e){return 34===e||39===e}function Kr(e){var t=1;for(wr=$r;!zr();)if(Vr(e=Ur()))Jr(e);else if(91===e&&t++,93===e&&t--,0===t){Cr=$r;break}}function Jr(e){for(var t=e;!zr()&&(e=Ur())!==t;);}var qr,Wr="__r",Zr="__c";function Gr(e,t,n){var r=qr;return function i(){null!==t.apply(null,arguments)&&Qr(e,i,n,r)}}var Xr=Ve&&!(X&&Number(X[1])<=53);function Yr(e,t,n,r){if(Xr){var i=an,o=t;t=o._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return o.apply(this,arguments)}}qr.addEventListener(e,t,Q?{capture:n,passive:r}:n)}function Qr(e,t,n,r){(r||qr).removeEventListener(e,t._wrapper||t,n)}function ei(e,r){if(!t(e.data.on)||!t(r.data.on)){var i=r.data.on||{},o=e.data.on||{};qr=r.elm,function(e){if(n(e[Wr])){var t=q?"change":"input";e[t]=[].concat(e[Wr],e[t]||[]),delete e[Wr]}n(e[Zr])&&(e.change=[].concat(e[Zr],e.change||[]),delete e[Zr])}(i),rt(i,o,Yr,Qr,Gr,r.context),qr=void 0}}var ti,ni={create:ei,update:ei};function ri(e,r){if(!t(e.data.domProps)||!t(r.data.domProps)){var i,o,a=r.elm,s=e.data.domProps||{},c=r.data.domProps||{};for(i in n(c.__ob__)&&(c=r.data.domProps=A({},c)),s)i in c||(a[i]="");for(i in c){if(o=c[i],"textContent"===i||"innerHTML"===i){if(r.children&&(r.children.length=0),o===s[i])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===i&&"PROGRESS"!==a.tagName){a._value=o;var u=t(o)?"":String(o);ii(a,u)&&(a.value=u)}else if("innerHTML"===i&&qn(a.tagName)&&t(a.innerHTML)){(ti=ti||document.createElement("div")).innerHTML="<svg>"+o+"</svg>";for(var l=ti.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;l.firstChild;)a.appendChild(l.firstChild)}else if(o!==s[i])try{a[i]=o}catch(e){}}}}function ii(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var r=e.value,i=e._vModifiers;if(n(i)){if(i.number)return f(r)!==f(t);if(i.trim)return r.trim()!==t.trim()}return r!==t}(e,t))}var oi={create:ri,update:ri},ai=g(function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach(function(e){if(e){var r=e.split(n);r.length>1&&(t[r[0].trim()]=r[1].trim())}}),t});function si(e){var t=ci(e.style);return e.staticStyle?A(e.staticStyle,t):t}function ci(e){return Array.isArray(e)?O(e):"string"==typeof e?ai(e):e}var ui,li=/^--/,fi=/\s*!important$/,pi=function(e,t,n){if(li.test(t))e.style.setProperty(t,n);else if(fi.test(n))e.style.setProperty(C(t),n.replace(fi,""),"important");else{var r=vi(t);if(Array.isArray(n))for(var i=0,o=n.length;i<o;i++)e.style[r]=n[i];else e.style[r]=n}},di=["Webkit","Moz","ms"],vi=g(function(e){if(ui=ui||document.createElement("div").style,"filter"!==(e=b(e))&&e in ui)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<di.length;n++){var r=di[n]+t;if(r in ui)return r}});function hi(e,r){var i=r.data,o=e.data;if(!(t(i.staticStyle)&&t(i.style)&&t(o.staticStyle)&&t(o.style))){var a,s,c=r.elm,u=o.staticStyle,l=o.normalizedStyle||o.style||{},f=u||l,p=ci(r.data.style)||{};r.data.normalizedStyle=n(p.__ob__)?A({},p):p;var d=function(e,t){var n,r={};if(t)for(var i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=si(i.data))&&A(r,n);(n=si(e.data))&&A(r,n);for(var o=e;o=o.parent;)o.data&&(n=si(o.data))&&A(r,n);return r}(r,!0);for(s in f)t(d[s])&&pi(c,s,"");for(s in d)(a=d[s])!==f[s]&&pi(c,s,null==a?"":a)}}var mi={create:hi,update:hi},yi=/\s+/;function gi(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(yi).forEach(function(t){return e.classList.add(t)}):e.classList.add(t);else{var n=" "+(e.getAttribute("class")||"")+" ";n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function _i(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(yi).forEach(function(t){return e.classList.remove(t)}):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" "+(e.getAttribute("class")||"")+" ",r=" "+t+" ";n.indexOf(r)>=0;)n=n.replace(r," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function bi(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&A(t,$i(e.name||"v")),A(t,e),t}return"string"==typeof e?$i(e):void 0}}var $i=g(function(e){return{enterClass:e+"-enter",enterToClass:e+"-enter-to",enterActiveClass:e+"-enter-active",leaveClass:e+"-leave",leaveToClass:e+"-leave-to",leaveActiveClass:e+"-leave-active"}}),wi=z&&!W,Ci="transition",xi="animation",ki="transition",Ai="transitionend",Oi="animation",Si="animationend";wi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(ki="WebkitTransition",Ai="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Oi="WebkitAnimation",Si="webkitAnimationEnd"));var Ti=z?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function Ei(e){Ti(function(){Ti(e)})}function Ni(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),gi(e,t))}function ji(e,t){e._transitionClasses&&h(e._transitionClasses,t),_i(e,t)}function Di(e,t,n){var r=Mi(e,t),i=r.type,o=r.timeout,a=r.propCount;if(!i)return n();var s=i===Ci?Ai:Si,c=0,u=function(){e.removeEventListener(s,l),n()},l=function(t){t.target===e&&++c>=a&&u()};setTimeout(function(){c<a&&u()},o+1),e.addEventListener(s,l)}var Li=/\b(transform|all)(,|$)/;function Mi(e,t){var n,r=window.getComputedStyle(e),i=(r[ki+"Delay"]||"").split(", "),o=(r[ki+"Duration"]||"").split(", "),a=Ii(i,o),s=(r[Oi+"Delay"]||"").split(", "),c=(r[Oi+"Duration"]||"").split(", "),u=Ii(s,c),l=0,f=0;return t===Ci?a>0&&(n=Ci,l=a,f=o.length):t===xi?u>0&&(n=xi,l=u,f=c.length):f=(n=(l=Math.max(a,u))>0?a>u?Ci:xi:null)?n===Ci?o.length:c.length:0,{type:n,timeout:l,propCount:f,hasTransform:n===Ci&&Li.test(r[ki+"Property"])}}function Ii(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map(function(t,n){return Fi(t)+Fi(e[n])}))}function Fi(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function Pi(e,r){var i=e.elm;n(i._leaveCb)&&(i._leaveCb.cancelled=!0,i._leaveCb());var a=bi(e.data.transition);if(!t(a)&&!n(i._enterCb)&&1===i.nodeType){for(var s=a.css,c=a.type,u=a.enterClass,l=a.enterToClass,p=a.enterActiveClass,d=a.appearClass,v=a.appearToClass,h=a.appearActiveClass,m=a.beforeEnter,y=a.enter,g=a.afterEnter,_=a.enterCancelled,b=a.beforeAppear,$=a.appear,w=a.afterAppear,C=a.appearCancelled,x=a.duration,k=Wt,A=Wt.$vnode;A&&A.parent;)k=A.context,A=A.parent;var O=!k._isMounted||!e.isRootInsert;if(!O||$||""===$){var S=O&&d?d:u,T=O&&h?h:p,E=O&&v?v:l,N=O&&b||m,j=O&&"function"==typeof $?$:y,L=O&&w||g,M=O&&C||_,I=f(o(x)?x.enter:x),F=!1!==s&&!W,P=Bi(j),R=i._enterCb=D(function(){F&&(ji(i,E),ji(i,T)),R.cancelled?(F&&ji(i,S),M&&M(i)):L&&L(i),i._enterCb=null});e.data.show||it(e,"insert",function(){var t=i.parentNode,n=t&&t._pending&&t._pending[e.key];n&&n.tag===e.tag&&n.elm._leaveCb&&n.elm._leaveCb(),j&&j(i,R)}),N&&N(i),F&&(Ni(i,S),Ni(i,T),Ei(function(){ji(i,S),R.cancelled||(Ni(i,E),P||(Hi(I)?setTimeout(R,I):Di(i,c,R)))})),e.data.show&&(r&&r(),j&&j(i,R)),F||P||R()}}}function Ri(e,r){var i=e.elm;n(i._enterCb)&&(i._enterCb.cancelled=!0,i._enterCb());var a=bi(e.data.transition);if(t(a)||1!==i.nodeType)return r();if(!n(i._leaveCb)){var s=a.css,c=a.type,u=a.leaveClass,l=a.leaveToClass,p=a.leaveActiveClass,d=a.beforeLeave,v=a.leave,h=a.afterLeave,m=a.leaveCancelled,y=a.delayLeave,g=a.duration,_=!1!==s&&!W,b=Bi(v),$=f(o(g)?g.leave:g),w=i._leaveCb=D(function(){i.parentNode&&i.parentNode._pending&&(i.parentNode._pending[e.key]=null),_&&(ji(i,l),ji(i,p)),w.cancelled?(_&&ji(i,u),m&&m(i)):(r(),h&&h(i)),i._leaveCb=null});y?y(C):C()}function C(){w.cancelled||(!e.data.show&&i.parentNode&&((i.parentNode._pending||(i.parentNode._pending={}))[e.key]=e),d&&d(i),_&&(Ni(i,u),Ni(i,p),Ei(function(){ji(i,u),w.cancelled||(Ni(i,l),b||(Hi($)?setTimeout(w,$):Di(i,c,w)))})),v&&v(i,w),_||b||w())}}function Hi(e){return"number"==typeof e&&!isNaN(e)}function Bi(e){if(t(e))return!1;var r=e.fns;return n(r)?Bi(Array.isArray(r)?r[0]:r):(e._length||e.length)>1}function Ui(e,t){!0!==t.data.show&&Pi(t)}var zi=function(e){var o,a,s={},c=e.modules,u=e.nodeOps;for(o=0;o<rr.length;++o)for(s[rr[o]]=[],a=0;a<c.length;++a)n(c[a][rr[o]])&&s[rr[o]].push(c[a][rr[o]]);function l(e){var t=u.parentNode(e);n(t)&&u.removeChild(t,e)}function f(e,t,i,o,a,c,l){if(n(e.elm)&&n(c)&&(e=c[l]=me(e)),e.isRootInsert=!a,!function(e,t,i,o){var a=e.data;if(n(a)){var c=n(e.componentInstance)&&a.keepAlive;if(n(a=a.hook)&&n(a=a.init)&&a(e,!1),n(e.componentInstance))return d(e,t),v(i,e.elm,o),r(c)&&function(e,t,r,i){for(var o,a=e;a.componentInstance;)if(a=a.componentInstance._vnode,n(o=a.data)&&n(o=o.transition)){for(o=0;o<s.activate.length;++o)s.activate[o](nr,a);t.push(a);break}v(r,e.elm,i)}(e,t,i,o),!0}}(e,t,i,o)){var f=e.data,p=e.children,m=e.tag;n(m)?(e.elm=e.ns?u.createElementNS(e.ns,m):u.createElement(m,e),g(e),h(e,p,t),n(f)&&y(e,t),v(i,e.elm,o)):r(e.isComment)?(e.elm=u.createComment(e.text),v(i,e.elm,o)):(e.elm=u.createTextNode(e.text),v(i,e.elm,o))}}function d(e,t){n(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,m(e)?(y(e,t),g(e)):(tr(e),t.push(e))}function v(e,t,r){n(e)&&(n(r)?u.parentNode(r)===e&&u.insertBefore(e,t,r):u.appendChild(e,t))}function h(e,t,n){if(Array.isArray(t))for(var r=0;r<t.length;++r)f(t[r],n,e.elm,null,!0,t,r);else i(e.text)&&u.appendChild(e.elm,u.createTextNode(String(e.text)))}function m(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return n(e.tag)}function y(e,t){for(var r=0;r<s.create.length;++r)s.create[r](nr,e);n(o=e.data.hook)&&(n(o.create)&&o.create(nr,e),n(o.insert)&&t.push(e))}function g(e){var t;if(n(t=e.fnScopeId))u.setStyleScope(e.elm,t);else for(var r=e;r;)n(t=r.context)&&n(t=t.$options._scopeId)&&u.setStyleScope(e.elm,t),r=r.parent;n(t=Wt)&&t!==e.context&&t!==e.fnContext&&n(t=t.$options._scopeId)&&u.setStyleScope(e.elm,t)}function _(e,t,n,r,i,o){for(;r<=i;++r)f(n[r],o,e,t,!1,n,r)}function b(e){var t,r,i=e.data;if(n(i))for(n(t=i.hook)&&n(t=t.destroy)&&t(e),t=0;t<s.destroy.length;++t)s.destroy[t](e);if(n(t=e.children))for(r=0;r<e.children.length;++r)b(e.children[r])}function $(e,t,r){for(;t<=r;++t){var i=e[t];n(i)&&(n(i.tag)?(w(i),b(i)):l(i.elm))}}function w(e,t){if(n(t)||n(e.data)){var r,i=s.remove.length+1;for(n(t)?t.listeners+=i:t=function(e,t){function n(){0==--n.listeners&&l(e)}return n.listeners=t,n}(e.elm,i),n(r=e.componentInstance)&&n(r=r._vnode)&&n(r.data)&&w(r,t),r=0;r<s.remove.length;++r)s.remove[r](e,t);n(r=e.data.hook)&&n(r=r.remove)?r(e,t):t()}else l(e.elm)}function C(e,t,r,i){for(var o=r;o<i;o++){var a=t[o];if(n(a)&&ir(e,a))return o}}function x(e,i,o,a,c,l){if(e!==i){n(i.elm)&&n(a)&&(i=a[c]=me(i));var p=i.elm=e.elm;if(r(e.isAsyncPlaceholder))n(i.asyncFactory.resolved)?O(e.elm,i,o):i.isAsyncPlaceholder=!0;else if(r(i.isStatic)&&r(e.isStatic)&&i.key===e.key&&(r(i.isCloned)||r(i.isOnce)))i.componentInstance=e.componentInstance;else{var d,v=i.data;n(v)&&n(d=v.hook)&&n(d=d.prepatch)&&d(e,i);var h=e.children,y=i.children;if(n(v)&&m(i)){for(d=0;d<s.update.length;++d)s.update[d](e,i);n(d=v.hook)&&n(d=d.update)&&d(e,i)}t(i.text)?n(h)&&n(y)?h!==y&&function(e,r,i,o,a){for(var s,c,l,p=0,d=0,v=r.length-1,h=r[0],m=r[v],y=i.length-1,g=i[0],b=i[y],w=!a;p<=v&&d<=y;)t(h)?h=r[++p]:t(m)?m=r[--v]:ir(h,g)?(x(h,g,o,i,d),h=r[++p],g=i[++d]):ir(m,b)?(x(m,b,o,i,y),m=r[--v],b=i[--y]):ir(h,b)?(x(h,b,o,i,y),w&&u.insertBefore(e,h.elm,u.nextSibling(m.elm)),h=r[++p],b=i[--y]):ir(m,g)?(x(m,g,o,i,d),w&&u.insertBefore(e,m.elm,h.elm),m=r[--v],g=i[++d]):(t(s)&&(s=or(r,p,v)),t(c=n(g.key)?s[g.key]:C(g,r,p,v))?f(g,o,e,h.elm,!1,i,d):ir(l=r[c],g)?(x(l,g,o,i,d),r[c]=void 0,w&&u.insertBefore(e,l.elm,h.elm)):f(g,o,e,h.elm,!1,i,d),g=i[++d]);p>v?_(e,t(i[y+1])?null:i[y+1].elm,i,d,y,o):d>y&&$(r,p,v)}(p,h,y,o,l):n(y)?(n(e.text)&&u.setTextContent(p,""),_(p,null,y,0,y.length-1,o)):n(h)?$(h,0,h.length-1):n(e.text)&&u.setTextContent(p,""):e.text!==i.text&&u.setTextContent(p,i.text),n(v)&&n(d=v.hook)&&n(d=d.postpatch)&&d(e,i)}}}function k(e,t,i){if(r(i)&&n(e.parent))e.parent.data.pendingInsert=t;else for(var o=0;o<t.length;++o)t[o].data.hook.insert(t[o])}var A=p("attrs,class,staticClass,staticStyle,key");function O(e,t,i,o){var a,s=t.tag,c=t.data,u=t.children;if(o=o||c&&c.pre,t.elm=e,r(t.isComment)&&n(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(n(c)&&(n(a=c.hook)&&n(a=a.init)&&a(t,!0),n(a=t.componentInstance)))return d(t,i),!0;if(n(s)){if(n(u))if(e.hasChildNodes())if(n(a=c)&&n(a=a.domProps)&&n(a=a.innerHTML)){if(a!==e.innerHTML)return!1}else{for(var l=!0,f=e.firstChild,p=0;p<u.length;p++){if(!f||!O(f,u[p],i,o)){l=!1;break}f=f.nextSibling}if(!l||f)return!1}else h(t,u,i);if(n(c)){var v=!1;for(var m in c)if(!A(m)){v=!0,y(t,i);break}!v&&c.class&&et(c.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,i,o,a){if(!t(i)){var c,l=!1,p=[];if(t(e))l=!0,f(i,p);else{var d=n(e.nodeType);if(!d&&ir(e,i))x(e,i,p,null,null,a);else{if(d){if(1===e.nodeType&&e.hasAttribute(L)&&(e.removeAttribute(L),o=!0),r(o)&&O(e,i,p))return k(i,p,!0),e;c=e,e=new pe(u.tagName(c).toLowerCase(),{},[],void 0,c)}var v=e.elm,h=u.parentNode(v);if(f(i,p,v._leaveCb?null:h,u.nextSibling(v)),n(i.parent))for(var y=i.parent,g=m(i);y;){for(var _=0;_<s.destroy.length;++_)s.destroy[_](y);if(y.elm=i.elm,g){for(var w=0;w<s.create.length;++w)s.create[w](nr,y);var C=y.data.hook.insert;if(C.merged)for(var A=1;A<C.fns.length;A++)C.fns[A]()}else tr(y);y=y.parent}n(h)?$([e],0,0):n(e.tag)&&b(e)}}return k(i,p,l),i.elm}n(e)&&b(e)}}({nodeOps:Qn,modules:[mr,xr,ni,oi,mi,z?{create:Ui,activate:Ui,remove:function(e,t){!0!==e.data.show?Ri(e,t):t()}}:{}].concat(pr)});W&&document.addEventListener("selectionchange",function(){var e=document.activeElement;e&&e.vmodel&&Xi(e,"input")});var Vi={inserted:function(e,t,n,r){"select"===n.tag?(r.elm&&!r.elm._vOptions?it(n,"postpatch",function(){Vi.componentUpdated(e,t,n)}):Ki(e,t,n.context),e._vOptions=[].map.call(e.options,Wi)):("textarea"===n.tag||Xn(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",Zi),e.addEventListener("compositionend",Gi),e.addEventListener("change",Gi),W&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){Ki(e,t,n.context);var r=e._vOptions,i=e._vOptions=[].map.call(e.options,Wi);if(i.some(function(e,t){return!N(e,r[t])}))(e.multiple?t.value.some(function(e){return qi(e,i)}):t.value!==t.oldValue&&qi(t.value,i))&&Xi(e,"change")}}};function Ki(e,t,n){Ji(e,t,n),(q||Z)&&setTimeout(function(){Ji(e,t,n)},0)}function Ji(e,t,n){var r=t.value,i=e.multiple;if(!i||Array.isArray(r)){for(var o,a,s=0,c=e.options.length;s<c;s++)if(a=e.options[s],i)o=j(r,Wi(a))>-1,a.selected!==o&&(a.selected=o);else if(N(Wi(a),r))return void(e.selectedIndex!==s&&(e.selectedIndex=s));i||(e.selectedIndex=-1)}}function qi(e,t){return t.every(function(t){return!N(t,e)})}function Wi(e){return"_value"in e?e._value:e.value}function Zi(e){e.target.composing=!0}function Gi(e){e.target.composing&&(e.target.composing=!1,Xi(e.target,"input"))}function Xi(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function Yi(e){return!e.componentInstance||e.data&&e.data.transition?e:Yi(e.componentInstance._vnode)}var Qi={model:Vi,show:{bind:function(e,t,n){var r=t.value,i=(n=Yi(n)).data&&n.data.transition,o=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;r&&i?(n.data.show=!0,Pi(n,function(){e.style.display=o})):e.style.display=r?o:"none"},update:function(e,t,n){var r=t.value;!r!=!t.oldValue&&((n=Yi(n)).data&&n.data.transition?(n.data.show=!0,r?Pi(n,function(){e.style.display=e.__vOriginalDisplay}):Ri(n,function(){e.style.display="none"})):e.style.display=r?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,r,i){i||(e.style.display=e.__vOriginalDisplay)}}},eo={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function to(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?to(zt(t.children)):e}function no(e){var t={},n=e.$options;for(var r in n.propsData)t[r]=e[r];var i=n._parentListeners;for(var o in i)t[b(o)]=i[o];return t}function ro(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var io=function(e){return e.tag||Ut(e)},oo=function(e){return"show"===e.name},ao={name:"transition",props:eo,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(io)).length){var r=this.mode,o=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return o;var a=to(o);if(!a)return o;if(this._leaving)return ro(e,o);var s="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?s+"comment":s+a.tag:i(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var c=(a.data||(a.data={})).transition=no(this),u=this._vnode,l=to(u);if(a.data.directives&&a.data.directives.some(oo)&&(a.data.show=!0),l&&l.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(a,l)&&!Ut(l)&&(!l.componentInstance||!l.componentInstance._vnode.isComment)){var f=l.data.transition=A({},c);if("out-in"===r)return this._leaving=!0,it(f,"afterLeave",function(){t._leaving=!1,t.$forceUpdate()}),ro(e,o);if("in-out"===r){if(Ut(a))return u;var p,d=function(){p()};it(c,"afterEnter",d),it(c,"enterCancelled",d),it(f,"delayLeave",function(e){p=e})}}return o}}},so=A({tag:String,moveClass:String},eo);function co(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function uo(e){e.data.newPos=e.elm.getBoundingClientRect()}function lo(e){var t=e.data.pos,n=e.data.newPos,r=t.left-n.left,i=t.top-n.top;if(r||i){e.data.moved=!0;var o=e.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+i+"px)",o.transitionDuration="0s"}}delete so.mode;var fo={Transition:ao,TransitionGroup:{props:so,beforeMount:function(){var e=this,t=this._update;this._update=function(n,r){var i=Zt(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,r)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],a=no(this),s=0;s<i.length;s++){var c=i[s];c.tag&&null!=c.key&&0!==String(c.key).indexOf("__vlist")&&(o.push(c),n[c.key]=c,(c.data||(c.data={})).transition=a)}if(r){for(var u=[],l=[],f=0;f<r.length;f++){var p=r[f];p.data.transition=a,p.data.pos=p.elm.getBoundingClientRect(),n[p.key]?u.push(p):l.push(p)}this.kept=e(t,null,u),this.removed=l}return e(t,null,o)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(co),e.forEach(uo),e.forEach(lo),this._reflow=document.body.offsetHeight,e.forEach(function(e){if(e.data.moved){var n=e.elm,r=n.style;Ni(n,t),r.transform=r.WebkitTransform=r.transitionDuration="",n.addEventListener(Ai,n._moveCb=function e(r){r&&r.target!==n||r&&!/transform$/.test(r.propertyName)||(n.removeEventListener(Ai,e),n._moveCb=null,ji(n,t))})}}))},methods:{hasMove:function(e,t){if(!wi)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach(function(e){_i(n,e)}),gi(n,t),n.style.display="none",this.$el.appendChild(n);var r=Mi(n);return this.$el.removeChild(n),this._hasMove=r.hasTransform}}}};wn.config.mustUseProp=jn,wn.config.isReservedTag=Wn,wn.config.isReservedAttr=En,wn.config.getTagNamespace=Zn,wn.config.isUnknownElement=function(e){if(!z)return!0;if(Wn(e))return!1;if(e=e.toLowerCase(),null!=Gn[e])return Gn[e];var t=document.createElement(e);return e.indexOf("-")>-1?Gn[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:Gn[e]=/HTMLUnknownElement/.test(t.toString())},A(wn.options.directives,Qi),A(wn.options.components,fo),wn.prototype.__patch__=z?zi:S,wn.prototype.$mount=function(e,t){return function(e,t,n){var r;return e.$el=t,e.$options.render||(e.$options.render=ve),Yt(e,"beforeMount"),r=function(){e._update(e._render(),n)},new fn(e,r,S,{before:function(){e._isMounted&&!e._isDestroyed&&Yt(e,"beforeUpdate")}},!0),n=!1,null==e.$vnode&&(e._isMounted=!0,Yt(e,"mounted")),e}(this,e=e&&z?Yn(e):void 0,t)},z&&setTimeout(function(){F.devtools&&ne&&ne.emit("init",wn)},0);var po=/\{\{((?:.|\r?\n)+?)\}\}/g,vo=/[-.*+?^${}()|[\]\/\\]/g,ho=g(function(e){var t=e[0].replace(vo,"\\$&"),n=e[1].replace(vo,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")});var mo={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=Fr(e,"class");n&&(e.staticClass=JSON.stringify(n));var r=Ir(e,"class",!1);r&&(e.classBinding=r)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:"+e.staticClass+","),e.classBinding&&(t+="class:"+e.classBinding+","),t}};var yo,go={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=Fr(e,"style");n&&(e.staticStyle=JSON.stringify(ai(n)));var r=Ir(e,"style",!1);r&&(e.styleBinding=r)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:"+e.staticStyle+","),e.styleBinding&&(t+="style:("+e.styleBinding+"),"),t}},_o=function(e){return(yo=yo||document.createElement("div")).innerHTML=e,yo.textContent},bo=p("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),$o=p("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),wo=p("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),Co=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,xo=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,ko="[a-zA-Z_][\\-\\.0-9_a-zA-Z"+P.source+"]*",Ao="((?:"+ko+"\\:)?"+ko+")",Oo=new RegExp("^<"+Ao),So=/^\s*(\/?)>/,To=new RegExp("^<\\/"+Ao+"[^>]*>"),Eo=/^<!DOCTYPE [^>]+>/i,No=/^<!\--/,jo=/^<!\[/,Do=p("script,style,textarea",!0),Lo={},Mo={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},Io=/&(?:lt|gt|quot|amp|#39);/g,Fo=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,Po=p("pre,textarea",!0),Ro=function(e,t){return e&&Po(e)&&"\n"===t[0]};function Ho(e,t){var n=t?Fo:Io;return e.replace(n,function(e){return Mo[e]})}var Bo,Uo,zo,Vo,Ko,Jo,qo,Wo,Zo=/^@|^v-on:/,Go=/^v-|^@|^:|^#/,Xo=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,Yo=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,Qo=/^\(|\)$/g,ea=/^\[.*\]$/,ta=/:(.*)$/,na=/^:|^\.|^v-bind:/,ra=/\.[^.\]]+(?=[^\]]*$)/g,ia=/^v-slot(:|$)|^#/,oa=/[\r\n]/,aa=/\s+/g,sa=g(_o),ca="_empty_";function ua(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:ma(t),rawAttrsMap:{},parent:n,children:[]}}function la(e,t){Bo=t.warn||Sr,Jo=t.isPreTag||T,qo=t.mustUseProp||T,Wo=t.getTagNamespace||T;t.isReservedTag;zo=Tr(t.modules,"transformNode"),Vo=Tr(t.modules,"preTransformNode"),Ko=Tr(t.modules,"postTransformNode"),Uo=t.delimiters;var n,r,i=[],o=!1!==t.preserveWhitespace,a=t.whitespace,s=!1,c=!1;function u(e){if(l(e),s||e.processed||(e=fa(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&da(n,{exp:e.elseif,block:e}),r&&!e.forbidden)if(e.elseif||e.else)a=e,(u=function(e){var t=e.length;for(;t--;){if(1===e[t].type)return e[t];e.pop()}}(r.children))&&u.if&&da(u,{exp:a.elseif,block:a});else{if(e.slotScope){var o=e.slotTarget||'"default"';(r.scopedSlots||(r.scopedSlots={}))[o]=e}r.children.push(e),e.parent=r}var a,u;e.children=e.children.filter(function(e){return!e.slotScope}),l(e),e.pre&&(s=!1),Jo(e.tag)&&(c=!1);for(var f=0;f<Ko.length;f++)Ko[f](e,t)}function l(e){if(!c)for(var t;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,r,i=[],o=t.expectHTML,a=t.isUnaryTag||T,s=t.canBeLeftOpenTag||T,c=0;e;){if(n=e,r&&Do(r)){var u=0,l=r.toLowerCase(),f=Lo[l]||(Lo[l]=new RegExp("([\\s\\S]*?)(</"+l+"[^>]*>)","i")),p=e.replace(f,function(e,n,r){return u=r.length,Do(l)||"noscript"===l||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),Ro(l,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""});c+=e.length-p.length,e=p,A(l,c-u,c)}else{var d=e.indexOf("<");if(0===d){if(No.test(e)){var v=e.indexOf("--\x3e");if(v>=0){t.shouldKeepComment&&t.comment(e.substring(4,v),c,c+v+3),C(v+3);continue}}if(jo.test(e)){var h=e.indexOf("]>");if(h>=0){C(h+2);continue}}var m=e.match(Eo);if(m){C(m[0].length);continue}var y=e.match(To);if(y){var g=c;C(y[0].length),A(y[1],g,c);continue}var _=x();if(_){k(_),Ro(_.tagName,e)&&C(1);continue}}var b=void 0,$=void 0,w=void 0;if(d>=0){for($=e.slice(d);!(To.test($)||Oo.test($)||No.test($)||jo.test($)||(w=$.indexOf("<",1))<0);)d+=w,$=e.slice(d);b=e.substring(0,d)}d<0&&(b=e),b&&C(b.length),t.chars&&b&&t.chars(b,c-b.length,c)}if(e===n){t.chars&&t.chars(e);break}}function C(t){c+=t,e=e.substring(t)}function x(){var t=e.match(Oo);if(t){var n,r,i={tagName:t[1],attrs:[],start:c};for(C(t[0].length);!(n=e.match(So))&&(r=e.match(xo)||e.match(Co));)r.start=c,C(r[0].length),r.end=c,i.attrs.push(r);if(n)return i.unarySlash=n[1],C(n[0].length),i.end=c,i}}function k(e){var n=e.tagName,c=e.unarySlash;o&&("p"===r&&wo(n)&&A(r),s(n)&&r===n&&A(n));for(var u=a(n)||!!c,l=e.attrs.length,f=new Array(l),p=0;p<l;p++){var d=e.attrs[p],v=d[3]||d[4]||d[5]||"",h="a"===n&&"href"===d[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;f[p]={name:d[1],value:Ho(v,h)}}u||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:f,start:e.start,end:e.end}),r=n),t.start&&t.start(n,f,u,e.start,e.end)}function A(e,n,o){var a,s;if(null==n&&(n=c),null==o&&(o=c),e)for(s=e.toLowerCase(),a=i.length-1;a>=0&&i[a].lowerCasedTag!==s;a--);else a=0;if(a>=0){for(var u=i.length-1;u>=a;u--)t.end&&t.end(i[u].tag,n,o);i.length=a,r=a&&i[a-1].tag}else"br"===s?t.start&&t.start(e,[],!0,n,o):"p"===s&&(t.start&&t.start(e,[],!1,n,o),t.end&&t.end(e,n,o))}A()}(e,{warn:Bo,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,o,a,l,f){var p=r&&r.ns||Wo(e);q&&"svg"===p&&(o=function(e){for(var t=[],n=0;n<e.length;n++){var r=e[n];ya.test(r.name)||(r.name=r.name.replace(ga,""),t.push(r))}return t}(o));var d,v=ua(e,o,r);p&&(v.ns=p),"style"!==(d=v).tag&&("script"!==d.tag||d.attrsMap.type&&"text/javascript"!==d.attrsMap.type)||te()||(v.forbidden=!0);for(var h=0;h<Vo.length;h++)v=Vo[h](v,t)||v;s||(!function(e){null!=Fr(e,"v-pre")&&(e.pre=!0)}(v),v.pre&&(s=!0)),Jo(v.tag)&&(c=!0),s?function(e){var t=e.attrsList,n=t.length;if(n)for(var r=e.attrs=new Array(n),i=0;i<n;i++)r[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(r[i].start=t[i].start,r[i].end=t[i].end);else e.pre||(e.plain=!0)}(v):v.processed||(pa(v),function(e){var t=Fr(e,"v-if");if(t)e.if=t,da(e,{exp:t,block:e});else{null!=Fr(e,"v-else")&&(e.else=!0);var n=Fr(e,"v-else-if");n&&(e.elseif=n)}}(v),function(e){null!=Fr(e,"v-once")&&(e.once=!0)}(v)),n||(n=v),a?u(v):(r=v,i.push(v))},end:function(e,t,n){var o=i[i.length-1];i.length-=1,r=i[i.length-1],u(o)},chars:function(e,t,n){if(r&&(!q||"textarea"!==r.tag||r.attrsMap.placeholder!==e)){var i,u,l,f=r.children;if(e=c||e.trim()?"script"===(i=r).tag||"style"===i.tag?e:sa(e):f.length?a?"condense"===a&&oa.test(e)?"":" ":o?" ":"":"")c||"condense"!==a||(e=e.replace(aa," ")),!s&&" "!==e&&(u=function(e,t){var n=t?ho(t):po;if(n.test(e)){for(var r,i,o,a=[],s=[],c=n.lastIndex=0;r=n.exec(e);){(i=r.index)>c&&(s.push(o=e.slice(c,i)),a.push(JSON.stringify(o)));var u=Ar(r[1].trim());a.push("_s("+u+")"),s.push({"@binding":u}),c=i+r[0].length}return c<e.length&&(s.push(o=e.slice(c)),a.push(JSON.stringify(o))),{expression:a.join("+"),tokens:s}}}(e,Uo))?l={type:2,expression:u.expression,tokens:u.tokens,text:e}:" "===e&&f.length&&" "===f[f.length-1].text||(l={type:3,text:e}),l&&f.push(l)}},comment:function(e,t,n){if(r){var i={type:3,text:e,isComment:!0};r.children.push(i)}}}),n}function fa(e,t){var n,r;(r=Ir(n=e,"key"))&&(n.key=r),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=Ir(e,"ref");t&&(e.ref=t,e.refInFor=function(e){var t=e;for(;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=Fr(e,"scope"),e.slotScope=t||Fr(e,"slot-scope")):(t=Fr(e,"slot-scope"))&&(e.slotScope=t);var n=Ir(e,"slot");n&&(e.slotTarget='""'===n?'"default"':n,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||Nr(e,"slot",n,function(e,t){return e.rawAttrsMap[":"+t]||e.rawAttrsMap["v-bind:"+t]||e.rawAttrsMap[t]}(e,"slot")));if("template"===e.tag){var r=Pr(e,ia);if(r){var i=va(r),o=i.name,a=i.dynamic;e.slotTarget=o,e.slotTargetDynamic=a,e.slotScope=r.value||ca}}else{var s=Pr(e,ia);if(s){var c=e.scopedSlots||(e.scopedSlots={}),u=va(s),l=u.name,f=u.dynamic,p=c[l]=ua("template",[],e);p.slotTarget=l,p.slotTargetDynamic=f,p.children=e.children.filter(function(e){if(!e.slotScope)return e.parent=p,!0}),p.slotScope=s.value||ca,e.children=[],e.plain=!1}}}(e),function(e){"slot"===e.tag&&(e.slotName=Ir(e,"name"))}(e),function(e){var t;(t=Ir(e,"is"))&&(e.component=t);null!=Fr(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var i=0;i<zo.length;i++)e=zo[i](e,t)||e;return function(e){var t,n,r,i,o,a,s,c,u=e.attrsList;for(t=0,n=u.length;t<n;t++)if(r=i=u[t].name,o=u[t].value,Go.test(r))if(e.hasBindings=!0,(a=ha(r.replace(Go,"")))&&(r=r.replace(ra,"")),na.test(r))r=r.replace(na,""),o=Ar(o),(c=ea.test(r))&&(r=r.slice(1,-1)),a&&(a.prop&&!c&&"innerHtml"===(r=b(r))&&(r="innerHTML"),a.camel&&!c&&(r=b(r)),a.sync&&(s=Br(o,"$event"),c?Mr(e,'"update:"+('+r+")",s,null,!1,0,u[t],!0):(Mr(e,"update:"+b(r),s,null,!1,0,u[t]),C(r)!==b(r)&&Mr(e,"update:"+C(r),s,null,!1,0,u[t])))),a&&a.prop||!e.component&&qo(e.tag,e.attrsMap.type,r)?Er(e,r,o,u[t],c):Nr(e,r,o,u[t],c);else if(Zo.test(r))r=r.replace(Zo,""),(c=ea.test(r))&&(r=r.slice(1,-1)),Mr(e,r,o,a,!1,0,u[t],c);else{var l=(r=r.replace(Go,"")).match(ta),f=l&&l[1];c=!1,f&&(r=r.slice(0,-(f.length+1)),ea.test(f)&&(f=f.slice(1,-1),c=!0)),Dr(e,r,i,o,f,c,a,u[t])}else Nr(e,r,JSON.stringify(o),u[t]),!e.component&&"muted"===r&&qo(e.tag,e.attrsMap.type,r)&&Er(e,r,"true",u[t])}(e),e}function pa(e){var t;if(t=Fr(e,"v-for")){var n=function(e){var t=e.match(Xo);if(!t)return;var n={};n.for=t[2].trim();var r=t[1].trim().replace(Qo,""),i=r.match(Yo);i?(n.alias=r.replace(Yo,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=r;return n}(t);n&&A(e,n)}}function da(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function va(e){var t=e.name.replace(ia,"");return t||"#"!==e.name[0]&&(t="default"),ea.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'+t+'"',dynamic:!1}}function ha(e){var t=e.match(ra);if(t){var n={};return t.forEach(function(e){n[e.slice(1)]=!0}),n}}function ma(e){for(var t={},n=0,r=e.length;n<r;n++)t[e[n].name]=e[n].value;return t}var ya=/^xmlns:NS\d+/,ga=/^NS\d+:/;function _a(e){return ua(e.tag,e.attrsList.slice(),e.parent)}var ba=[mo,go,{preTransformNode:function(e,t){if("input"===e.tag){var n,r=e.attrsMap;if(!r["v-model"])return;if((r[":type"]||r["v-bind:type"])&&(n=Ir(e,"type")),r.type||n||!r["v-bind"]||(n="("+r["v-bind"]+").type"),n){var i=Fr(e,"v-if",!0),o=i?"&&("+i+")":"",a=null!=Fr(e,"v-else",!0),s=Fr(e,"v-else-if",!0),c=_a(e);pa(c),jr(c,"type","checkbox"),fa(c,t),c.processed=!0,c.if="("+n+")==='checkbox'"+o,da(c,{exp:c.if,block:c});var u=_a(e);Fr(u,"v-for",!0),jr(u,"type","radio"),fa(u,t),da(c,{exp:"("+n+")==='radio'"+o,block:u});var l=_a(e);return Fr(l,"v-for",!0),jr(l,":type",n),fa(l,t),da(c,{exp:i,block:l}),a?c.else=!0:s&&(c.elseif=s),c}}}}];var $a,wa,Ca={expectHTML:!0,modules:ba,directives:{model:function(e,t,n){var r=t.value,i=t.modifiers,o=e.tag,a=e.attrsMap.type;if(e.component)return Hr(e,r,i),!1;if("select"===o)!function(e,t,n){var r='var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return '+(n&&n.number?"_n(val)":"val")+"});";r=r+" "+Br(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]"),Mr(e,"change",r,null,!0)}(e,r,i);else if("input"===o&&"checkbox"===a)!function(e,t,n){var r=n&&n.number,i=Ir(e,"value")||"null",o=Ir(e,"true-value")||"true",a=Ir(e,"false-value")||"false";Er(e,"checked","Array.isArray("+t+")?_i("+t+","+i+")>-1"+("true"===o?":("+t+")":":_q("+t+","+o+")")),Mr(e,"change","var $$a="+t+",$$el=$event.target,$$c=$$el.checked?("+o+"):("+a+");if(Array.isArray($$a)){var $$v="+(r?"_n("+i+")":i)+",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&("+Br(t,"$$a.concat([$$v])")+")}else{$$i>-1&&("+Br(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))")+")}}else{"+Br(t,"$$c")+"}",null,!0)}(e,r,i);else if("input"===o&&"radio"===a)!function(e,t,n){var r=n&&n.number,i=Ir(e,"value")||"null";Er(e,"checked","_q("+t+","+(i=r?"_n("+i+")":i)+")"),Mr(e,"change",Br(t,i),null,!0)}(e,r,i);else if("input"===o||"textarea"===o)!function(e,t,n){var r=e.attrsMap.type,i=n||{},o=i.lazy,a=i.number,s=i.trim,c=!o&&"range"!==r,u=o?"change":"range"===r?Wr:"input",l="$event.target.value";s&&(l="$event.target.value.trim()"),a&&(l="_n("+l+")");var f=Br(t,l);c&&(f="if($event.target.composing)return;"+f),Er(e,"value","("+t+")"),Mr(e,u,f,null,!0),(s||a)&&Mr(e,"blur","$forceUpdate()")}(e,r,i);else if(!F.isReservedTag(o))return Hr(e,r,i),!1;return!0},text:function(e,t){t.value&&Er(e,"textContent","_s("+t.value+")",t)},html:function(e,t){t.value&&Er(e,"innerHTML","_s("+t.value+")",t)}},isPreTag:function(e){return"pre"===e},isUnaryTag:bo,mustUseProp:jn,canBeLeftOpenTag:$o,isReservedTag:Wn,getTagNamespace:Zn,staticKeys:function(e){return e.reduce(function(e,t){return e.concat(t.staticKeys||[])},[]).join(",")}(ba)},xa=g(function(e){return p("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))});function ka(e,t){e&&($a=xa(t.staticKeys||""),wa=t.isReservedTag||T,function e(t){t.static=function(e){if(2===e.type)return!1;if(3===e.type)return!0;return!(!e.pre&&(e.hasBindings||e.if||e.for||d(e.tag)||!wa(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every($a)))}(t);if(1===t.type){if(!wa(t.tag)&&"slot"!==t.tag&&null==t.attrsMap["inline-template"])return;for(var n=0,r=t.children.length;n<r;n++){var i=t.children[n];e(i),i.static||(t.static=!1)}if(t.ifConditions)for(var o=1,a=t.ifConditions.length;o<a;o++){var s=t.ifConditions[o].block;e(s),s.static||(t.static=!1)}}}(e),function e(t,n){if(1===t.type){if((t.static||t.once)&&(t.staticInFor=n),t.static&&t.children.length&&(1!==t.children.length||3!==t.children[0].type))return void(t.staticRoot=!0);if(t.staticRoot=!1,t.children)for(var r=0,i=t.children.length;r<i;r++)e(t.children[r],n||!!t.for);if(t.ifConditions)for(var o=1,a=t.ifConditions.length;o<a;o++)e(t.ifConditions[o].block,n)}}(e,!1))}var Aa=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Oa=/\([^)]*?\);*$/,Sa=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Ta={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Ea={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},Na=function(e){return"if("+e+")return null;"},ja={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Na("$event.target !== $event.currentTarget"),ctrl:Na("!$event.ctrlKey"),shift:Na("!$event.shiftKey"),alt:Na("!$event.altKey"),meta:Na("!$event.metaKey"),left:Na("'button' in $event && $event.button !== 0"),middle:Na("'button' in $event && $event.button !== 1"),right:Na("'button' in $event && $event.button !== 2")};function Da(e,t){var n=t?"nativeOn:":"on:",r="",i="";for(var o in e){var a=La(e[o]);e[o]&&e[o].dynamic?i+=o+","+a+",":r+='"'+o+'":'+a+","}return r="{"+r.slice(0,-1)+"}",i?n+"_d("+r+",["+i.slice(0,-1)+"])":n+r}function La(e){if(!e)return"function(){}";if(Array.isArray(e))return"["+e.map(function(e){return La(e)}).join(",")+"]";var t=Sa.test(e.value),n=Aa.test(e.value),r=Sa.test(e.value.replace(Oa,""));if(e.modifiers){var i="",o="",a=[];for(var s in e.modifiers)if(ja[s])o+=ja[s],Ta[s]&&a.push(s);else if("exact"===s){var c=e.modifiers;o+=Na(["ctrl","shift","alt","meta"].filter(function(e){return!c[e]}).map(function(e){return"$event."+e+"Key"}).join("||"))}else a.push(s);return a.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+e.map(Ma).join("&&")+")return null;"}(a)),o&&(i+=o),"function($event){"+i+(t?"return "+e.value+"($event)":n?"return ("+e.value+")($event)":r?"return "+e.value:e.value)+"}"}return t||n?e.value:"function($event){"+(r?"return "+e.value:e.value)+"}"}function Ma(e){var t=parseInt(e,10);if(t)return"$event.keyCode!=="+t;var n=Ta[e],r=Ea[e];return"_k($event.keyCode,"+JSON.stringify(e)+","+JSON.stringify(n)+",$event.key,"+JSON.stringify(r)+")"}var Ia={on:function(e,t){e.wrapListeners=function(e){return"_g("+e+","+t.value+")"}},bind:function(e,t){e.wrapData=function(n){return"_b("+n+",'"+e.tag+"',"+t.value+","+(t.modifiers&&t.modifiers.prop?"true":"false")+(t.modifiers&&t.modifiers.sync?",true":"")+")"}},cloak:S},Fa=function(e){this.options=e,this.warn=e.warn||Sr,this.transforms=Tr(e.modules,"transformCode"),this.dataGenFns=Tr(e.modules,"genData"),this.directives=A(A({},Ia),e.directives);var t=e.isReservedTag||T;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function Pa(e,t){var n=new Fa(t);return{render:"with(this){return "+(e?Ra(e,n):'_c("div")')+"}",staticRenderFns:n.staticRenderFns}}function Ra(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return Ha(e,t);if(e.once&&!e.onceProcessed)return Ba(e,t);if(e.for&&!e.forProcessed)return za(e,t);if(e.if&&!e.ifProcessed)return Ua(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',r=qa(e,t),i="_t("+n+(r?","+r:""),o=e.attrs||e.dynamicAttrs?Ga((e.attrs||[]).concat(e.dynamicAttrs||[]).map(function(e){return{name:b(e.name),value:e.value,dynamic:e.dynamic}})):null,a=e.attrsMap["v-bind"];!o&&!a||r||(i+=",null");o&&(i+=","+o);a&&(i+=(o?"":",null")+","+a);return i+")"}(e,t);var n;if(e.component)n=function(e,t,n){var r=t.inlineTemplate?null:qa(t,n,!0);return"_c("+e+","+Va(t,n)+(r?","+r:"")+")"}(e.component,e,t);else{var r;(!e.plain||e.pre&&t.maybeComponent(e))&&(r=Va(e,t));var i=e.inlineTemplate?null:qa(e,t,!0);n="_c('"+e.tag+"'"+(r?","+r:"")+(i?","+i:"")+")"}for(var o=0;o<t.transforms.length;o++)n=t.transforms[o](e,n);return n}return qa(e,t)||"void 0"}function Ha(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return "+Ra(e,t)+"}"),t.pre=n,"_m("+(t.staticRenderFns.length-1)+(e.staticInFor?",true":"")+")"}function Ba(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return Ua(e,t);if(e.staticInFor){for(var n="",r=e.parent;r;){if(r.for){n=r.key;break}r=r.parent}return n?"_o("+Ra(e,t)+","+t.onceId+++","+n+")":Ra(e,t)}return Ha(e,t)}function Ua(e,t,n,r){return e.ifProcessed=!0,function e(t,n,r,i){if(!t.length)return i||"_e()";var o=t.shift();return o.exp?"("+o.exp+")?"+a(o.block)+":"+e(t,n,r,i):""+a(o.block);function a(e){return r?r(e,n):e.once?Ba(e,n):Ra(e,n)}}(e.ifConditions.slice(),t,n,r)}function za(e,t,n,r){var i=e.for,o=e.alias,a=e.iterator1?","+e.iterator1:"",s=e.iterator2?","+e.iterator2:"";return e.forProcessed=!0,(r||"_l")+"(("+i+"),function("+o+a+s+"){return "+(n||Ra)(e,t)+"})"}function Va(e,t){var n="{",r=function(e,t){var n=e.directives;if(!n)return;var r,i,o,a,s="directives:[",c=!1;for(r=0,i=n.length;r<i;r++){o=n[r],a=!0;var u=t.directives[o.name];u&&(a=!!u(e,o,t.warn)),a&&(c=!0,s+='{name:"'+o.name+'",rawName:"'+o.rawName+'"'+(o.value?",value:("+o.value+"),expression:"+JSON.stringify(o.value):"")+(o.arg?",arg:"+(o.isDynamicArg?o.arg:'"'+o.arg+'"'):"")+(o.modifiers?",modifiers:"+JSON.stringify(o.modifiers):"")+"},")}if(c)return s.slice(0,-1)+"]"}(e,t);r&&(n+=r+","),e.key&&(n+="key:"+e.key+","),e.ref&&(n+="ref:"+e.ref+","),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'+e.tag+'",');for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:"+Ga(e.attrs)+","),e.props&&(n+="domProps:"+Ga(e.props)+","),e.events&&(n+=Da(e.events,!1)+","),e.nativeEvents&&(n+=Da(e.nativeEvents,!0)+","),e.slotTarget&&!e.slotScope&&(n+="slot:"+e.slotTarget+","),e.scopedSlots&&(n+=function(e,t,n){var r=e.for||Object.keys(t).some(function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||Ka(n)}),i=!!e.if;if(!r)for(var o=e.parent;o;){if(o.slotScope&&o.slotScope!==ca||o.for){r=!0;break}o.if&&(i=!0),o=o.parent}var a=Object.keys(t).map(function(e){return Ja(t[e],n)}).join(",");return"scopedSlots:_u(["+a+"]"+(r?",null,true":"")+(!r&&i?",null,false,"+function(e){var t=5381,n=e.length;for(;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(a):"")+")"}(e,e.scopedSlots,t)+","),e.model&&(n+="model:{value:"+e.model.value+",callback:"+e.model.callback+",expression:"+e.model.expression+"},"),e.inlineTemplate){var o=function(e,t){var n=e.children[0];if(n&&1===n.type){var r=Pa(n,t.options);return"inlineTemplate:{render:function(){"+r.render+"},staticRenderFns:["+r.staticRenderFns.map(function(e){return"function(){"+e+"}"}).join(",")+"]}"}}(e,t);o&&(n+=o+",")}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b("+n+',"'+e.tag+'",'+Ga(e.dynamicAttrs)+")"),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function Ka(e){return 1===e.type&&("slot"===e.tag||e.children.some(Ka))}function Ja(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return Ua(e,t,Ja,"null");if(e.for&&!e.forProcessed)return za(e,t,Ja);var r=e.slotScope===ca?"":String(e.slotScope),i="function("+r+"){return "+("template"===e.tag?e.if&&n?"("+e.if+")?"+(qa(e,t)||"undefined")+":undefined":qa(e,t)||"undefined":Ra(e,t))+"}",o=r?"":",proxy:true";return"{key:"+(e.slotTarget||'"default"')+",fn:"+i+o+"}"}function qa(e,t,n,r,i){var o=e.children;if(o.length){var a=o[0];if(1===o.length&&a.for&&"template"!==a.tag&&"slot"!==a.tag){var s=n?t.maybeComponent(a)?",1":",0":"";return""+(r||Ra)(a,t)+s}var c=n?function(e,t){for(var n=0,r=0;r<e.length;r++){var i=e[r];if(1===i.type){if(Wa(i)||i.ifConditions&&i.ifConditions.some(function(e){return Wa(e.block)})){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some(function(e){return t(e.block)}))&&(n=1)}}return n}(o,t.maybeComponent):0,u=i||Za;return"["+o.map(function(e){return u(e,t)}).join(",")+"]"+(c?","+c:"")}}function Wa(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function Za(e,t){return 1===e.type?Ra(e,t):3===e.type&&e.isComment?(r=e,"_e("+JSON.stringify(r.text)+")"):"_v("+(2===(n=e).type?n.expression:Xa(JSON.stringify(n.text)))+")";var n,r}function Ga(e){for(var t="",n="",r=0;r<e.length;r++){var i=e[r],o=Xa(i.value);i.dynamic?n+=i.name+","+o+",":t+='"'+i.name+'":'+o+","}return t="{"+t.slice(0,-1)+"}",n?"_d("+t+",["+n.slice(0,-1)+"])":t}function Xa(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b");function Ya(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),S}}function Qa(e){var t=Object.create(null);return function(n,r,i){(r=A({},r)).warn;delete r.warn;var o=r.delimiters?String(r.delimiters)+n:n;if(t[o])return t[o];var a=e(n,r),s={},c=[];return s.render=Ya(a.render,c),s.staticRenderFns=a.staticRenderFns.map(function(e){return Ya(e,c)}),t[o]=s}}var es,ts,ns=(es=function(e,t){var n=la(e.trim(),t);!1!==t.optimize&&ka(n,t);var r=Pa(n,t);return{ast:n,render:r.render,staticRenderFns:r.staticRenderFns}},function(e){function t(t,n){var r=Object.create(e),i=[],o=[];if(n)for(var a in n.modules&&(r.modules=(e.modules||[]).concat(n.modules)),n.directives&&(r.directives=A(Object.create(e.directives||null),n.directives)),n)"modules"!==a&&"directives"!==a&&(r[a]=n[a]);r.warn=function(e,t,n){(n?o:i).push(e)};var s=es(t.trim(),r);return s.errors=i,s.tips=o,s}return{compile:t,compileToFunctions:Qa(t)}})(Ca),rs=(ns.compile,ns.compileToFunctions);function is(e){return(ts=ts||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',ts.innerHTML.indexOf("&#10;")>0}var os=!!z&&is(!1),as=!!z&&is(!0),ss=g(function(e){var t=Yn(e);return t&&t.innerHTML}),cs=wn.prototype.$mount;return wn.prototype.$mount=function(e,t){if((e=e&&Yn(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var r=n.template;if(r)if("string"==typeof r)"#"===r.charAt(0)&&(r=ss(r));else{if(!r.nodeType)return this;r=r.innerHTML}else e&&(r=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(r){var i=rs(r,{outputSourceRange:!1,shouldDecodeNewlines:os,shouldDecodeNewlinesForHref:as,delimiters:n.delimiters,comments:n.comments},this),o=i.render,a=i.staticRenderFns;n.render=o,n.staticRenderFns=a}}return cs.call(this,e,t)},wn.compile=rs,wn});
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"timers":231}],235:[function(require,module,exports){
(function (global){(function (){
/*!
 * vuex v3.6.2
 * (c) 2021 Evan You
 * @license MIT
 */
'use strict';

function applyMixin (Vue) {
  var version = Number(Vue.version.split('.')[0]);

  if (version >= 2) {
    Vue.mixin({ beforeCreate: vuexInit });
  } else {
    // override init and inject vuex init procedure
    // for 1.x backwards compatibility.
    var _init = Vue.prototype._init;
    Vue.prototype._init = function (options) {
      if ( options === void 0 ) options = {};

      options.init = options.init
        ? [vuexInit].concat(options.init)
        : vuexInit;
      _init.call(this, options);
    };
  }

  /**
   * Vuex init hook, injected into each instances init hooks list.
   */

  function vuexInit () {
    var options = this.$options;
    // store injection
    if (options.store) {
      this.$store = typeof options.store === 'function'
        ? options.store()
        : options.store;
    } else if (options.parent && options.parent.$store) {
      this.$store = options.parent.$store;
    }
  }
}

var target = typeof window !== 'undefined'
  ? window
  : typeof global !== 'undefined'
    ? global
    : {};
var devtoolHook = target.__VUE_DEVTOOLS_GLOBAL_HOOK__;

function devtoolPlugin (store) {
  if (!devtoolHook) { return }

  store._devtoolHook = devtoolHook;

  devtoolHook.emit('vuex:init', store);

  devtoolHook.on('vuex:travel-to-state', function (targetState) {
    store.replaceState(targetState);
  });

  store.subscribe(function (mutation, state) {
    devtoolHook.emit('vuex:mutation', mutation, state);
  }, { prepend: true });

  store.subscribeAction(function (action, state) {
    devtoolHook.emit('vuex:action', action, state);
  }, { prepend: true });
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
function find (list, f) {
  return list.filter(f)[0]
}

/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */
function deepCopy (obj, cache) {
  if ( cache === void 0 ) cache = [];

  // just return if obj is immutable value
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // if obj is hit, it is in circular structure
  var hit = find(cache, function (c) { return c.original === obj; });
  if (hit) {
    return hit.copy
  }

  var copy = Array.isArray(obj) ? [] : {};
  // put the copy into cache at first
  // because we want to refer it in recursive deepCopy
  cache.push({
    original: obj,
    copy: copy
  });

  Object.keys(obj).forEach(function (key) {
    copy[key] = deepCopy(obj[key], cache);
  });

  return copy
}

/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

function partial (fn, arg) {
  return function () {
    return fn(arg)
  }
}

// Base data struct for store's module, package with some attribute and method
var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  // Store some children item
  this._children = Object.create(null);
  // Store the origin module object which passed by programmer
  this._rawModule = rawModule;
  var rawState = rawModule.state;

  // Store the origin module's state
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors = { namespaced: { configurable: true } };

prototypeAccessors.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.hasChild = function hasChild (key) {
  return key in this._children
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if (("development" !== 'production')) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);

  if (!child) {
    if (("development" !== 'production')) {
      console.warn(
        "[vuex] trying to unregister module '" + key + "', which is " +
        "not registered"
      );
    }
    return
  }

  if (!child.runtime) {
    return
  }

  parent.removeChild(key);
};

ModuleCollection.prototype.isRegistered = function isRegistered (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (parent) {
    return parent.hasChild(key)
  }

  return false
};

function update (path, targetModule, newModule) {
  if (("development" !== 'production')) {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if (("development" !== 'production')) {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
            'manual reload is needed'
          );
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

var functionAssert = {
  assert: function (value) { return typeof value === 'function'; },
  expected: 'function'
};

var objectAssert = {
  assert: function (value) { return typeof value === 'function' ||
    (typeof value === 'object' && typeof value.handler === 'function'); },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule (path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) { return }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";
  return buf
}

var Vue; // bind on install

var Store = function Store (options) {
  var this$1 = this;
  if ( options === void 0 ) options = {};

  // Auto install if it is not done yet and `window` has `Vue`.
  // To allow users to avoid auto-installation in some cases,
  // this code should be placed here. See #731
  if (!Vue && typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
  }

  if (("development" !== 'production')) {
    assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "store must be called with the new operator.");
  }

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._watcherVM = new Vue();
  this._makeLocalGettersCache = Object.create(null);

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  var state = this._modules.root.state;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store vm, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreVM(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1); });

  var useDevtools = options.devtools !== undefined ? options.devtools : Vue.config.devtools;
  if (useDevtools) {
    devtoolPlugin(this);
  }
};

var prototypeAccessors$1 = { state: { configurable: true } };

prototypeAccessors$1.state.get = function () {
  return this._vm._data.$$state
};

prototypeAccessors$1.state.set = function (v) {
  if (("development" !== 'production')) {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if (("development" !== 'production')) {
      console.error(("[vuex] unknown mutation type: " + type));
    }
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });

  this._subscribers
    .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
    .forEach(function (sub) { return sub(mutation, this$1.state); });

  if (
    ("development" !== 'production') &&
    options && options.silent
  ) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if (("development" !== 'production')) {
      console.error(("[vuex] unknown action type: " + type));
    }
    return
  }

  try {
    this._actionSubscribers
      .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
      .filter(function (sub) { return sub.before; })
      .forEach(function (sub) { return sub.before(action, this$1.state); });
  } catch (e) {
    if (("development" !== 'production')) {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e);
    }
  }

  var result = entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload);

  return new Promise(function (resolve, reject) {
    result.then(function (res) {
      try {
        this$1._actionSubscribers
          .filter(function (sub) { return sub.after; })
          .forEach(function (sub) { return sub.after(action, this$1.state); });
      } catch (e) {
        if (("development" !== 'production')) {
          console.warn("[vuex] error in after action subscribers: ");
          console.error(e);
        }
      }
      resolve(res);
    }, function (error) {
      try {
        this$1._actionSubscribers
          .filter(function (sub) { return sub.error; })
          .forEach(function (sub) { return sub.error(action, this$1.state, error); });
      } catch (e) {
        if (("development" !== 'production')) {
          console.warn("[vuex] error in error action subscribers: ");
          console.error(e);
        }
      }
      reject(error);
    });
  })
};

Store.prototype.subscribe = function subscribe (fn, options) {
  return genericSubscribe(fn, this._subscribers, options)
};

Store.prototype.subscribeAction = function subscribeAction (fn, options) {
  var subs = typeof fn === 'function' ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options)
};

Store.prototype.watch = function watch (getter, cb, options) {
    var this$1 = this;

  if (("development" !== 'production')) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1 = this;

  this._withCommit(function () {
    this$1._vm._data.$$state = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

  if (typeof path === 'string') { path = [path]; }

  if (("development" !== 'production')) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreVM(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if (("development" !== 'production')) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1.state, path.slice(0, -1));
    Vue.delete(parentState, path[path.length - 1]);
  });
  resetStore(this);
};

Store.prototype.hasModule = function hasModule (path) {
  if (typeof path === 'string') { path = [path]; }

  if (("development" !== 'production')) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  return this._modules.isRegistered(path)
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors$1 );

function genericSubscribe (fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend
      ? subs.unshift(fn)
      : subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
}

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset vm
  resetStoreVM(store, state, hot);
}

function resetStoreVM (store, state, hot) {
  var oldVm = store._vm;

  // bind store public getters
  store.getters = {};
  // reset local getters cache
  store._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computed = {};
  forEachValue(wrappedGetters, function (fn, key) {
    // use computed to leverage its lazy-caching mechanism
    // direct inline function use will lead to closure preserving oldVm.
    // using partial to return function with only arguments preserved in closure environment.
    computed[key] = partial(fn, store);
    Object.defineProperty(store.getters, key, {
      get: function () { return store._vm[key]; },
      enumerable: true // for local getters
    });
  });

  // use a Vue instance to store the state tree
  // suppress warnings just in case the user has added
  // some funky global mixins
  var silent = Vue.config.silent;
  Vue.config.silent = true;
  store._vm = new Vue({
    data: {
      $$state: state
    },
    computed: computed
  });
  Vue.config.silent = silent;

  // enable strict mode for new vm
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldVm) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldVm._data.$$state = null;
      });
    }
    Vue.nextTick(function () { return oldVm.$destroy(); });
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && ("development" !== 'production')) {
      console.error(("[vuex] duplicate namespace " + namespace + " for the namespaced module " + (path.join('/'))));
    }
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      if (("development" !== 'production')) {
        if (moduleName in parentState) {
          console.warn(
            ("[vuex] state field \"" + moduleName + "\" was overridden by a module with the same name at \"" + (path.join('.')) + "\"")
          );
        }
      }
      Vue.set(parentState, moduleName, module.state);
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (("development" !== 'production') && !store._actions[type]) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (("development" !== 'production') && !store._mutations[type]) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by vm update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function (type) {
      // skip if the target getter is not match this namespace
      if (type.slice(0, splitPos) !== namespace) { return }

      // extract local getter type
      var localType = type.slice(splitPos);

      // Add a port to the getters proxy.
      // Define as getter property because
      // we do not want to evaluate the getters in this time.
      Object.defineProperty(gettersProxy, localType, {
        get: function () { return store.getters[type]; },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }

  return store._makeLocalGettersCache[namespace]
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if (("development" !== 'production')) {
      console.error(("[vuex] duplicate getter key: " + type));
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  store._vm.$watch(function () { return this._data.$$state }, function () {
    if (("development" !== 'production')) {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, sync: true });
}

function getNestedState (state, path) {
  return path.reduce(function (state, key) { return state[key]; }, state)
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if (("development" !== 'production')) {
    assert(typeof type === 'string', ("expects string as the type, but found " + (typeof type) + "."));
  }

  return { type: type, payload: payload, options: options }
}

function install (_Vue) {
  if (Vue && _Vue === Vue) {
    if (("development" !== 'production')) {
      console.error(
        '[vuex] already installed. Vue.use(Vuex) should be called only once.'
      );
    }
    return
  }
  Vue = _Vue;
  applyMixin(Vue);
}

/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */
var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  if (("development" !== 'production') && !isValidMap(states)) {
    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  if (("development" !== 'production') && !isValidMap(mutations)) {
    console.error('[vuex] mapMutations: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // Get the commit method from store
      var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return
        }
        commit = module.context.commit;
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */
var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  if (("development" !== 'production') && !isValidMap(getters)) {
    console.error('[vuex] mapGetters: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    // The namespace has been mutated by normalizeNamespace
    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (("development" !== 'production') && !(val in this.$store.getters)) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  if (("development" !== 'production') && !isValidMap(actions)) {
    console.error('[vuex] mapActions: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // get dispatch function from store
      var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */
var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */
function normalizeMap (map) {
  if (!isValidMap(map)) {
    return []
  }
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

/**
 * Validate whether given map is valid or not
 * @param {*} map
 * @return {Boolean}
 */
function isValidMap (map) {
  return Array.isArray(map) || isObject(map)
}

/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */
function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */
function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (("development" !== 'production') && !module) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

// Credits: borrowed code from fcomb/redux-logger

function createLogger (ref) {
  if ( ref === void 0 ) ref = {};
  var collapsed = ref.collapsed; if ( collapsed === void 0 ) collapsed = true;
  var filter = ref.filter; if ( filter === void 0 ) filter = function (mutation, stateBefore, stateAfter) { return true; };
  var transformer = ref.transformer; if ( transformer === void 0 ) transformer = function (state) { return state; };
  var mutationTransformer = ref.mutationTransformer; if ( mutationTransformer === void 0 ) mutationTransformer = function (mut) { return mut; };
  var actionFilter = ref.actionFilter; if ( actionFilter === void 0 ) actionFilter = function (action, state) { return true; };
  var actionTransformer = ref.actionTransformer; if ( actionTransformer === void 0 ) actionTransformer = function (act) { return act; };
  var logMutations = ref.logMutations; if ( logMutations === void 0 ) logMutations = true;
  var logActions = ref.logActions; if ( logActions === void 0 ) logActions = true;
  var logger = ref.logger; if ( logger === void 0 ) logger = console;

  return function (store) {
    var prevState = deepCopy(store.state);

    if (typeof logger === 'undefined') {
      return
    }

    if (logMutations) {
      store.subscribe(function (mutation, state) {
        var nextState = deepCopy(state);

        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + (mutation.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
          endMessage(logger);
        }

        prevState = nextState;
      });
    }

    if (logActions) {
      store.subscribeAction(function (action, state) {
        if (actionFilter(action, state)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + (action.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
          endMessage(logger);
        }
      });
    }
  }
}

function startMessage (logger, message, collapsed) {
  var startMessage = collapsed
    ? logger.groupCollapsed
    : logger.group;

  // render
  try {
    startMessage.call(logger, message);
  } catch (e) {
    logger.log(message);
  }
}

function endMessage (logger) {
  try {
    logger.groupEnd();
  } catch (e) {
    logger.log(' log end ');
  }
}

function getFormattedTime () {
  var time = new Date();
  return (" @ " + (pad(time.getHours(), 2)) + ":" + (pad(time.getMinutes(), 2)) + ":" + (pad(time.getSeconds(), 2)) + "." + (pad(time.getMilliseconds(), 3)))
}

function repeat (str, times) {
  return (new Array(times + 1)).join(str)
}

function pad (num, maxLength) {
  return repeat('0', maxLength - num.toString().length) + num
}

var index_cjs = {
  Store: Store,
  install: install,
  version: '3.6.2',
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers,
  createLogger: createLogger
};

module.exports = index_cjs;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],236:[function(require,module,exports){
module.exports = "<div class=ms-button-set :class=\"{'ms-button-set--oval': ovalButton}\"><div v-for=\"(b, i) in buttons\" class=ms-button-set_button-container :class=\"{'ms-button-set_button-container--icon': b.icon}\"><input type=checkbox class=ms-button-set_button-checkbox v-model=values[i] @change=change(i) :disabled=b.disabled><div class=ms-button-set_button-content><span v-if=b.icon class=ms-button-set_button-icon :class=\"'ms-button-set_button-icon--'+b.icon\"></span> <span class=ms-button-set_button-text>{{b.label}}</span> <span v-if=b.mobileLabel class=ms-button-set_button-mobile-text>{{b.mobileLabel}}</span><div v-if=b.disabled class=ms-button-set_button-notice>{{disabledMessage}}</div></div></div></div>";

},{}],237:[function(require,module,exports){
module.exports = "<div v-if=data.loadingMessage class=ms-loading_container><div class=ms-loading_text>{{data.loadingMessage}}</div></div><div v-else-if=data.searchResults><component :is=component v-for=\"item in data.searchResults.Results\" :item=item :selected-unit=selectedUnit :key=item.id :view-product-label=viewProductLabel></div>";

},{}],238:[function(require,module,exports){
module.exports = "<div><ms-frame-separator v-if=showTitle :title=options.question></ms-frame-separator><ms-button-set v-if=options.button :key=key :buttons=options.button :multiple=options.multiple :oval-button=options.ovalButton :disabled-message=options.disabledMessage :on-change=onChange :default-value=defaultValues :on-trigger-event=onTriggerAnswerEvent></ms-button-set><ms-input-box v-else :key=key :title=options.filterName :description=options.question :switcher=options.options :dropdown-options=dropdownOptions :input=input :on-change=onChange :default-value=defaultValues :on-trigger-event=onTriggerAnswerEvent></ms-input-box></div>";

},{}],239:[function(require,module,exports){
module.exports = "<div class=ms-frame_separator><div v-if=title class=ms-frame_separator-title-container><h3 class=ms-frame_separator-title>{{title}}</h3></div></div>";

},{}],240:[function(require,module,exports){
module.exports = "<div class=ms-frame :class=\"{'ms-frame--lateral-bar': isLateralBar, 'ms-frame--transparent': transparent}\"><div v-if=isLateralBar class=ms-frame_mobile-header><a class=ms-frame_mobile-close-button @click=open>{{mobileButtonLabel}}</a></div><div v-if=title class=ms-frame_title-container><h4 class=ms-frame_title>{{title}}</h4></div><div class=ms-frame_container><div v-if=message v-html=message class=ms-frame_message></div><div v-else class=ms-frame_content><slot></slot></div><div v-if=notice v-html=notice class=ms-frame_notice></div><div v-if=hasButtons class=ms-frame_button-container><a v-if=hasContactButton href=#meterselector class=\"ms-frame_button ms-frame_button--contact\">{{contactButton.label}}</a> <button v-if=hasButton class=ms-frame_button :class=\"{'ms-frame_button--parameters': hasParametersButton}\" :disabled=disableButton @click=clickButton>{{buttonLabel}}</button></div></div><a v-if=cancelButtonLabel class=ms-frame_cancel-button @click=cancel>{{cancelButtonLabel}}</a></div>";

},{}],241:[function(require,module,exports){
module.exports = "<div class=ms-input-box><div class=ms-input-box_top-content><div class=ms-input-box_title-container><h4 class=ms-input-box_title>{{title}}</h4></div><div v-if=switcherField class=ms-input-box_switcher-container><input v-model=switcherValue type=checkbox class=ms-input-box_switcher-input><div class=ms-input-box_switcher-label-container><span>{{switcherField.left.label}}</span> <span>{{switcherField.right.label}}</span></div></div><div v-if=description class=ms-input-box_description-container>{{description}}</div></div><div class=ms-input-box_bottom-content><div v-if=dropdownField class=ms-input-box_dropdown-container><select v-model=dropdownValue><option v-for=\"o in dropdownField.options\" :value=o.value>{{ o.label }}</option></select></div><div v-if=inputField class=ms-input-box_input-container><div class=ms-input-box_input-title><span :is=inputTitle :option=option></span></div><div class=ms-input-box_text-input-container :class=\"{ 'ms-input-box_text-input-container--error': inputErrorMessage }\"><input v-model=inputValue type=text class=ms-input-box_text-input :placeholder=inputField.placeholder @blur=onBlurInput></div><div v-if=inputErrorMessage class=ms-input-box_text-input-error>{{inputErrorMessage}}</div></div></div></div>";

},{}],242:[function(require,module,exports){
module.exports = "<div v-if=\"(data.firstLoad && isShow) || data.nextPage\"><slot></slot></div>";

},{}],243:[function(require,module,exports){
module.exports = "<div class=\"product-card-hor meter-selector__product-card-hor\"><div class=product-card-hor__wrapper><div class=product-card-hor__row><div class=\"product-card-hor__area product-card-hor__area-utils\"><bookmark inline-template :item=item><div class=\"product-card-hor__util product-card-hor__util-bookmark\" v-on:click=handleBookmark()><span class=product-card-hor__bookmark :data-product-id=item.id ref=bookmark :class=\"{active: isBookmarked}\"></span></div></bookmark></div><div class=\"product-card-hor__area product-card-hor__area-image\"><div class=product-card-hor__image-container :style=\"{'background-image': 'url('+item.productImageUrl+')'}\"></div></div><div class=\"product-card-hor__area product-card-hor__area-content\"><div><span class=product-card-hor__eyebrow><img :src=item.brandImageUrl :alt=item.brandImageUrlAltText class=product-card-hor__eyebrow-image></span><p class=product-card-hor__title v-html=item.productName></p><div class=product-card-hor__copy v-html=item.productDescription></div><div class=product-card-hor__cta><a :href=item.url class=\"button tertiary-button\"><span class=button-text>{{viewProductLabel}}</span> <span class=button-icon></span></a></div></div></div></div></div></div>";

},{}],244:[function(require,module,exports){
module.exports = "<div class=catalog-card><div class=catalog-card__row><div class=\"catalog-card__area catalog-card__area-util\"><bookmark inline-template :item=item><div class=catalog-card__util-bookmark><span class=catalog-card__bookmark :data-product-id=item.id ref=bookmark v-on:click=handleBookmark() :class=\"{active: isBookmarked}\"></span></div></bookmark></div><div class=\"catalog-card__area catalog-card__area-header\"><div class=catalog-card__image-container><a :href=item.url class=catalog-card__image-link><img class=catalog-card__image :src=item.productImageUrl :alt=item.productImageUrlAltText></a></div><img :src=item.brandImageUrl :alt=item.brandImageUrlAltText class=catalog-card__logo><div class=catalog-card__title v-html=item.productName></div></div><div class=\"catalog-card__area catalog-card__area-stats\"><div v-for=\"stat in item.stats\" class=catalog-card__stat><div class=catalog-card__stat-label v-html=stat.label></div><div class=catalog-card__stat-value><div class=unit-metric v-if=\"selectedUnit === 'metric'\" v-html=stat.valueMetric></div><div class=unit-us v-if=\"selectedUnit === 'us'\" v-html=stat.valueImperial></div></div></div></div><div class=\"catalog-card__area catalog-card__area-cta\"><a :href=item.url class=\"button tertiary-button\"><span class=button-text>{{viewProductLabel}}</span> <span class=button-icon></span></a></div></div></div>";

},{}],245:[function(require,module,exports){
module.exports = "<div class=ms-step-bar :class=rootClasses><ul ref=list class=ms-step-bar_step-list><li v-for=\"(s, i) in getSteps\" :class=s.classes @click=onClickStep(i)><div class=ms-step-bar_item-content><span>{{s.label}}</span><span class=ms-step-bar_item-selected-value v-if=s.selectedValue>{{s.selectedValue}}</span></div></li></ul></div>";

},{}]},{},[61])

//# sourceMappingURL=main.bundle.js.map
